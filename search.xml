<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【转】Mobx React  最佳实践</title>
    <url>/2019/10/23/%E3%80%90%E8%BD%AC%E3%80%91react-mobx%EF%BC%9A%E5%A6%82%E4%BD%95%E7%BB%84%E7%BB%87store/</url>
    <content><![CDATA[<blockquote>
<p>【转】Mobx React  最佳实践<br>转载自 <a href="https://juejin.im/post/5a3b1a88f265da431440dc4a" target="_blank" rel="noopener">https://juejin.im/post/5a3b1a88f265da431440dc4a</a></p>
</blockquote>
<p>在这一篇文章里，将展示一些使用了mobx的React的最佳实践方式，并按照一条一条的规则来展示。在你遇到问题的时候，可以依照着这些规则来解决。<br>这篇文章要求你对于mobx的stores有基本的理解，如果没有的话请先阅读<a href="https://mobx.js.org/best/store.html" target="_blank" rel="noopener">官方文档</a>。</p>
<a id="more"></a>

<h3 id="stores-代表着UI状态"><a href="#stores-代表着UI状态" class="headerlink" title="stores 代表着UI状态"></a>stores 代表着UI状态</h3><p>永远记住，你的stores代表着你的UI状态，这就意味着，当你将你的stores储存下来后，就算你关了网页，再次打开，载入这个stores，你得到的网页也应该是相同的。虽然stores并不是一个本地数据库的角色，但是他依然存储着一些类似于按钮是否可见，input里面的内容之类的UI状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class SearchStore &#123;</span><br><span class="line">  @observable searchText;</span><br><span class="line"></span><br><span class="line">  @action</span><br><span class="line">  setSearchText = (searchText) =&gt; &#123;</span><br><span class="line">    this.searchText = searchText</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@observer</span><br><span class="line">class SearchInput extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  handleInputChanged = (event) =&gt; &#123;</span><br><span class="line">    const &#123; searchStore &#125; = this.props;</span><br><span class="line">    searchStore.setSearchText(event.target.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; searchStore &#125; = this.props;</span><br><span class="line">    return (</span><br><span class="line">      &lt;input</span><br><span class="line">        value=&#123;searchStore.searchText&#125;</span><br><span class="line">        onChange=&#123;this.handleInputChanged&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将你的REST-API请求和store的action分离"><a href="#将你的REST-API请求和store的action分离" class="headerlink" title="将你的REST API请求和store的action分离"></a>将你的REST API请求和store的action分离</h3><p>不建议将REST API请求的函数放在stores里面，因为这样以来这些请求代码很难测试。你可以尝试把这些请求函数放在一个类里面，把这个类的代码和store放在一起，在store创建时，这个类也相应创建。然后当你测试时，你也可以优雅的把数据从这些类里面mock上去。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TodoApi &#123;</span><br><span class="line"></span><br><span class="line">  fetchTodos = () =&gt; request.get(&apos;/todos&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TodoStore &#123;</span><br><span class="line"></span><br><span class="line">  @observable todos = [];</span><br><span class="line"></span><br><span class="line">  constructor(todoApi) &#123;</span><br><span class="line">    this.todoApi = todoApi;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fetchTodos = async () =&gt; &#123;</span><br><span class="line">    const todos = await this.todoApi.fetchTodos();</span><br><span class="line"></span><br><span class="line">    runInAction(() =&gt; &#123;</span><br><span class="line">      this.todos = todos;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在你的主要函数里面</span><br><span class="line">const todoApi = new TodoApi();</span><br><span class="line">const todoStore = new TodoStore(todoApi);</span><br></pre></td></tr></table></figure>

<h3 id="把你的业务逻辑放在stores里面"><a href="#把你的业务逻辑放在stores里面" class="headerlink" title="把你的业务逻辑放在stores里面"></a>把你的业务逻辑放在stores里面</h3><p>尽量不要把业务逻辑写在你的组件里面。当你把业务逻辑写在组件里面的时候，你是没有办法来及时定位错误的，因为你的业务逻辑分散在各种不同的组件里面，让你很难来通过行为来定义到底是哪些代码涉及的这个错误。最好就把业务逻辑放在stores的方法里面，从组件里面调用。<br>避免使用全局的store实例<br>请尽量避免使用全局的store实例，因为这样你很难写出有条理而可靠的组件测试。取而代之的是，你可以使用Provider来把你的store inject到你的component实例的props里面。这样你就可以轻松的mock这些store来测试了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const searchStore = new SearchStore();</span><br><span class="line"></span><br><span class="line">const app = (</span><br><span class="line">  &lt;Provider searchStore=&#123;searchStore&#125;&gt;</span><br><span class="line">    &lt;SearchInput /&gt;</span><br><span class="line">  &lt;/Provider&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ReactDom.render(app, container);</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/mobxjs/mobx-react#provider-and-inject">mobxjs/mobx-react</a></p>
<h3 id="只有在store里面才允许改变属性"><a href="#只有在store里面才允许改变属性" class="headerlink" title="只有在store里面才允许改变属性"></a>只有在store里面才允许改变属性</h3><p>请不要直接在组件里面直接操作store的属性值。因为只有store才能够来修改自己的属性。当你要改变属性的时候，请使用相应的store方法。不然的话你的属性修改会散落在各处不受控制，这是很难debug的。</p>
<h3 id="时刻记得在组件声明-observer"><a href="#时刻记得在组件声明-observer" class="headerlink" title="时刻记得在组件声明 @observer"></a>时刻记得在组件声明 @observer</h3><p>在每个组件声明的时候使用@observer来更新组件的状态。不然在嵌套组件里面，子组件没有声明的话，每次状态更新涉及到的都是父组件级的重新渲染。当你都使用了@observer时，重新渲染的组件数量会大大降低。</p>
<h3 id="使用-computed"><a href="#使用-computed" class="headerlink" title="使用 @computed"></a>使用 @computed</h3><p>就像下面代码的例子，使用@computed属性来处理一些涉及多个属性的逻辑。使用@computed可以减少这样的判断类业务逻辑在组件里面出现的频率。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ApplicationStore &#123;</span><br><span class="line"></span><br><span class="line">  @observable loggedInUser;</span><br><span class="line"></span><br><span class="line">  @observable isInAdminMode;</span><br><span class="line"></span><br><span class="line">  @computed isAdminButtonEnabled = () =&gt; &#123;</span><br><span class="line">    return this.loggedInUser.role === &apos;admin&apos; &amp;&amp; this.isInAdminMode;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="你不需要-react-router-来管理状态"><a href="#你不需要-react-router-来管理状态" class="headerlink" title="你不需要 react router 来管理状态"></a>你不需要 react router 来管理状态</h3><p>你不需要使用react router管理状态。就像我前面所说的，你的store就代表了应用的状态。当你让router来管理部份应用状态的时候，这部分状态就从store里面剥离开来。所以尽量使用store来储存所有的UI状态，这样store的属性就是你的界面所得。</p>
<h3 id="倾向于编写可控组件"><a href="#倾向于编写可控组件" class="headerlink" title="倾向于编写可控组件"></a>倾向于编写可控组件</h3><p>多编写可控组件，这样会大大降低你的测试复杂度，也让你的组件易于管理。<br><a href="https://zh-hans.reactjs.org/docs/forms.html" target="_blank" rel="noopener">Forms – React</a></p>
<p>作者：Daniel Bischoff<br>原文：Mobx React — Best Practices<br>翻译：Dominic Ming</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript学习笔记</title>
    <url>/2019/10/20/typescript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>TypeScript学习笔记<br>author: <a href="https://tiffanysbear.github.io/" target="_blank" rel="noopener">@TiffanysBear</a></p>
</blockquote>
<p>1、类型注解<br>2、接口interface：使用interface可以申明一个类型<br>3、类</p>
<ul>
<li>创建类时，在构造函数的参数上使用public等同于创建了同名的成员变量。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Student &#123;</span><br><span class="line">    fullName: string;</span><br><span class="line">    constructor(public firstName, public middleInitial, public lastName) &#123;</span><br><span class="line">        this.fullName = firstName + &quot; &quot; + middleInitial + &quot; &quot; + lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 编译后</span><br><span class="line">var Student = /** @class */ (function () &#123;</span><br><span class="line">    function Student(firstName, middleInitial, lastName) &#123;</span><br><span class="line">        this.firstName = firstName;</span><br><span class="line">        this.middleInitial = middleInitial;</span><br><span class="line">        this.lastName = lastName;</span><br><span class="line">        this.fullName = firstName + &quot; &quot; + middleInitial + &quot; &quot; + lastName;</span><br><span class="line">    &#125;</span><br><span class="line">    return Student;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>4、基本类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// bool</span><br><span class="line">let isDone: boolean = false;</span><br><span class="line"></span><br><span class="line">// number</span><br><span class="line">let decLiteral: number = 6;</span><br><span class="line">let hexLiteral: number = 0xf00d;</span><br><span class="line">let binaryLiteral: number = 0b1010;</span><br><span class="line">let octalLiteral: number = 0o744;</span><br><span class="line"></span><br><span class="line">// string</span><br><span class="line">let name: string = &quot;bob&quot;;</span><br><span class="line"></span><br><span class="line">// array</span><br><span class="line">let list: number[] = [1, 2, 3];</span><br><span class="line">let list: Array&lt;number&gt; = [1, 2, 3];</span><br></pre></td></tr></table></figure>

<p>5、元组 Tuple</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// Declare a tuple type</span><br><span class="line">let x: [string, number];</span><br><span class="line">// Initialize it</span><br><span class="line">x = [&apos;hello&apos;, 10]; // OK</span><br><span class="line">// Initialize it incorrectly</span><br><span class="line">x = [10, &apos;hello&apos;]; // Error</span><br></pre></td></tr></table></figure>

<p>6、枚举</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum Color &#123;Red, Green, Blue&#125;</span><br><span class="line">let c: Color = Color.Green;</span><br></pre></td></tr></table></figure>

<p>7、Any 任意类型的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let notSure: any = 4;</span><br><span class="line">notSure = &quot;maybe a string instead&quot;;</span><br><span class="line">notSure = false; // okay, definitely a boolean</span><br></pre></td></tr></table></figure>

<p>在对现有代码进行改写的时候，any类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为 Object有相似的作用，就像它在其它语言中那样。 但是 Object类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法。<br>当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">let list: any[] = [1, true, &quot;free&quot;];</span><br><span class="line">list[1] = 100;</span><br></pre></td></tr></table></figure>

<p>8、void 没有任何类型<br>当一个函数没有返回值时，你通常会见到其返回值类型是 void：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function warnUser(): void &#123;</span><br><span class="line">    console.log(&quot;This is my warning message&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let unusable: void = undefined;</span><br></pre></td></tr></table></figure>

<p>9、Null 和 Undefined<br>TypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null。 和 void相似，它们的本身的类型用处不是很大：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Not much else we can assign to these variables!</span><br><span class="line">let u: undefined = undefined;</span><br><span class="line">let n: null = null;</span><br></pre></td></tr></table></figure>

<p>默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。</p>
<p>然而，当你指定了 <code>--strictNullChecks</code> 标记，<code>null</code> 和 <code>undefined</code> 只能赋值给void和它们各自。 这能避免 很多常见的问题。 也许在某处你想传入一个 <code>string或null或undefined</code>，你可以使用联合类型<code>string | null | undefined</code></p>
<p>10、Never<br>never类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类型保护所约束时。<br>never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 返回never的函数必须存在无法达到的终点</span><br><span class="line">function error(message: string): never &#123;</span><br><span class="line">    throw new Error(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 推断的返回值类型为never</span><br><span class="line">function fail() &#123;</span><br><span class="line">    return error(&quot;Something failed&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回never的函数必须存在无法达到的终点</span><br><span class="line">function infiniteLoop(): never &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>11、object<br>object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare function create(o: object | null): void;</span><br><span class="line"></span><br><span class="line">create(&#123; prop: 0 &#125;); // OK</span><br><span class="line">create(null); // OK</span><br><span class="line"></span><br><span class="line">create(42); // Error</span><br><span class="line">create(&quot;string&quot;); // Error</span><br><span class="line">create(false); // Error</span><br><span class="line">create(undefined); // Error</span><br></pre></td></tr></table></figure>

<p>12、可选属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line">  color?: string;</span><br><span class="line">  width?: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>13、只读属性<br>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Point &#123;</span><br><span class="line">    readonly x: number;</span><br><span class="line">    readonly y: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>14、函数类型<br>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface SearchFunc &#123;</span><br><span class="line">  (source: string, subString: string): boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let mySearch: SearchFunc;</span><br><span class="line">mySearch = function(source: string, subString: string) &#123;</span><br><span class="line">  let result = source.search(subString);</span><br><span class="line">  return result &gt; -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line">let mySearch: SearchFunc;</span><br><span class="line">mySearch = function(src: string, sub: string): boolean &#123;</span><br><span class="line">  let result = src.search(sub);</span><br><span class="line">  return result &gt; -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>15、联合类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function padLeft(value: string, padding: string | number) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>16、交叉类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function extend&lt;T, U&gt;(first: T, second: U): T &amp; U &#123;</span><br><span class="line">    let result = &lt;T &amp; U&gt;&#123;&#125;;</span><br><span class="line">    for (let id in first) &#123;</span><br><span class="line">        (&lt;any&gt;result)[id] = (&lt;any&gt;first)[id];</span><br><span class="line">    &#125;</span><br><span class="line">    for (let id in second) &#123;</span><br><span class="line">        if (!result.hasOwnProperty(id)) &#123;</span><br><span class="line">            (&lt;any&gt;result)[id] = (&lt;any&gt;second)[id];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>17、可以为null的类型<br>默认情况下，类型检查器认为 null与 undefined可以赋值给任何类型。 <code>null</code> 与 <code>undefined</code> 是所有其它类型的一个有效值。</p>
<p><code>--strictNullChecks</code> 标记可以解决此错误：当你声明一个变量时，它不会自动地包含 null或 undefined。</p>
<p>18、接口 Interface vs. 类型别名 type</p>
<ul>
<li>接口创建了一个新的名字，可以在其它任何地方使用。 类型别名并不创建新名字—比如，错误信息就不会使用别名。 在下面的示例代码里，在编译器中将鼠标悬停在 interfaced上，显示它返回的是 Interface，但悬停在 aliased上时，显示的却是对象字面量类型。</li>
<li>类型别名不能被 extends和 implements（自己也不能 extends和 implements其它类型）</li>
<li>如果你无法通过接口来描述一个类型并且需要使用联合类型或元组类型，这时通常会使用类型别名</li>
</ul>
<p>19、字符串字面量类型<br>字符串字面量类型允许你指定字符串必须的固定值。 在实际应用中，字符串字面量类型可以与联合类型，类型保护和类型别名很好的配合。 通过结合使用这些特性，你可以实现类似枚举类型的字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Easing = &quot;ease-in&quot; | &quot;ease-out&quot; | &quot;ease-in-out&quot;;</span><br><span class="line">class UIElement &#123;</span><br><span class="line">    animate(dx: number, dy: number, easing: Easing) &#123;</span><br><span class="line">        if (easing === &quot;ease-in&quot;) &#123;</span><br><span class="line">            // ...</span><br><span class="line">        &#125;</span><br><span class="line">        else if (easing === &quot;ease-out&quot;) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (easing === &quot;ease-in-out&quot;) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            // error! should not pass null or undefined.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let button = new UIElement();</span><br><span class="line">button.animate(0, 0, &quot;ease-in&quot;);</span><br><span class="line">button.animate(0, 0, &quot;uneasy&quot;); // error: &quot;uneasy&quot; is not allowed here</span><br></pre></td></tr></table></figure>

<p>字符串字面量类型还可以用于区分函数重载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createElement(tagName: &quot;img&quot;): HTMLImageElement;</span><br><span class="line">function createElement(tagName: &quot;input&quot;): HTMLInputElement;</span><br><span class="line">// ... more overloads ...</span><br><span class="line">function createElement(tagName: string): Element &#123;</span><br><span class="line">    // ... code goes here ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code></code></pre>]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题</title>
    <url>/2019/09/09/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>前端面试题<br>author: <a href="https://tiffanysbear.github.io/" target="_blank" rel="noopener">@TiffanysBear</a></p>
</blockquote>
<p>2年工作经验出去接受社会的毒打，参与的前端社招的公司和题目的记录如下，后续可能还会有增加，先暂时记录这么多：</p>
<h3 id="头条"><a href="#头条" class="headerlink" title="头条"></a>头条</h3><p>一面：<br>在一面之前先是做题，做题时间为40分钟，主要的笔试题和面试中涉及的部分包括以下：</p>
<ol>
<li>宽度自适应，未知高度元素的水平垂直居中，字体水平垂直居中</li>
<li>arguments是数组吗？怎么转换数组</li>
<li>promise、await、setTimeout的执行顺序问题</li>
<li>es6块级作用域、箭头函数</li>
<li>隐式转换问题</li>
<li>实现一个throttle</li>
<li>实现一个函数bind，bind具体使用场景</li>
<li>算法：求一个数组中n个数和为sum</li>
<li>node中的事件循环和浏览器中事件循环有什么不同</li>
<li>宏任务和微任务具体有哪些</li>
</ol>
<a id="more"></a>

<p>二面：</p>
<ol>
<li>实现一个函数柯里化</li>
<li>http协议</li>
<li>tcp为什么可靠</li>
<li>浏览器怎么知道一个网页的内容加载完了</li>
<li>手写事件发布和订阅</li>
<li>事件节流和防抖的应用场景</li>
<li>一个网页从输入网址到浏览器页面展示经历了哪些过程，在哪些地方有缓存</li>
<li>性能优化</li>
<li>浏览器缓存机制</li>
<li>项目问题</li>
<li>要实现用for…in迭代，需要怎么做</li>
</ol>
<p>三面：</p>
<ol>
<li>了解哪些代码设计原则</li>
<li>浏览器并发请求限制个数，怎么解决限制</li>
<li>为什么react会有redux、mobx等库存在，设计原理上有什么区别</li>
<li>观察者模式和订阅发布模式有什么区别</li>
<li>vuex用的什么模式</li>
<li>小程序为什么设计双webview</li>
<li>FIS和webpack最大的区别的是什么</li>
<li>平时有看什么书，怎么总结学习</li>
<li>怎么看待前端技术变革和发展</li>
</ol>
<h3 id="高德"><a href="#高德" class="headerlink" title="高德"></a>高德</h3><p>一面：</p>
<ol>
<li>两个升序数组合并为一个有序数组</li>
<li>vue数据双向绑定有监听不到的情况吗</li>
<li>箭头函数哪些情况不能使用</li>
<li>vue的生命周期</li>
<li>ES6常用过哪些</li>
<li>https加密传输过程</li>
<li>为什么vue的data数据更新是异步的，vue怎么实现的异步</li>
<li>vue双向绑定的原理</li>
<li>webpack打包相关，plugin、loader之类</li>
<li>margin重叠问题</li>
</ol>
<p>二面：</p>
<ol>
<li>使用flex实现一个布局</li>
<li>vue怎么实现的数据双向绑定</li>
<li>箭头函数能否改变this指向</li>
<li>this指向问题，代码相关题目</li>
<li>封装一个文件异步读取的函数（考点thunk函数）</li>
<li>promise的catch作用</li>
<li>promise有几个状态，怎么转化</li>
<li>call、bind、apply有什么区别</li>
<li>…记不太清了</li>
<li>项目相关</li>
</ol>
<p>三面 + 四面 ：<br>项目相关，主要考察整体项目拆分划分设计能力</p>
<h3 id="滴滴"><a href="#滴滴" class="headerlink" title="滴滴"></a>滴滴</h3><p>一面：<br>一面是卷子，大概一共有10+道题，还有一些扩展延伸的问题，顺序和题目可能有点记不太清不太全了，面试感受是侧重全栈，不仅仅是有前端基础；</p>
<ol>
<li>this指向问题</li>
<li>使用flex实现一个布局</li>
<li>vue生命周期</li>
<li>手写深复制</li>
<li>promise、setTimeout执行顺序</li>
<li>let块级作用域问题</li>
<li>手写实现一个promise.all</li>
<li>promise使用reject和catch捕获有什么区别</li>
<li>css样式计算优先级</li>
<li>事件循环Event Loop，浏览器和node端有什么区别</li>
<li>node前后端交互过程</li>
<li>node中间件</li>
<li>hybrid开发，jsbridge与端通信</li>
<li>…</li>
</ol>
<p>二面：<br>两道设计题：</p>
<ol>
<li>页面编辑器，类似于提供很多组件，实现选择式去拼凑一个页面，而不是前端自己再切图。有几个部分组件选择区，已经选择的部分，两个按钮保存和生成页面按钮，直接生成预览的链接url页面。</li>
<li>实现一个类似pass统一管理用户登录的单独模块</li>
</ol>
<h3 id="优酷电面"><a href="#优酷电面" class="headerlink" title="优酷电面"></a>优酷电面</h3><ol>
<li>AST抽象语法树是什么，具体有哪些应用</li>
<li>hybrid开发，jsbridge与端通信</li>
<li>this在各个情况中的指向问题</li>
<li>vue和react的区别</li>
<li>vuex的使用</li>
<li>中间件、插件的认识，node中间件、webpack插件、fis插件等</li>
<li>weex、react-native底层js与端是怎么通信映射的</li>
<li>call、apply、bind有什么区别</li>
<li>vue实现数据双向绑定的原理，vue的实现原理</li>
<li>怎么设计好的一个组件</li>
<li>…</li>
</ol>
]]></content>
      <categories>
        <category>javaScript</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>FIS 插件机制</title>
    <url>/2019/08/26/FIS-%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<blockquote>
<p>FIS 插件机制<br>author: <a href="https://tiffanysbear.github.io/" target="_blank" rel="noopener">@TiffanysBear</a></p>
</blockquote>
<p>当我们使用 FIS 插件的时候，有没有想过自己也开发一个基于 FIS 的插件，参与 FIS 打包编译的整个流程；那么问题就来了：</p>
<ul>
<li>FIS 的编译过程运行原理是怎样的呢？</li>
<li>FIS 编译打包的过程有哪些？</li>
<li>怎么参与FIS 的打包编译过程？</li>
<li>怎么实现一个基于FIS的插件？</li>
<li>FIS 是怎么引入自定义插件的？</li>
</ul>
<p>基于以下的问题，从原理再进行慢慢分析，了解 FIS 编译的基本流程和原理，以及如何自己自定义一个 FIS 插件。</p>
<h2 id="编译过程运行原理"><a href="#编译过程运行原理" class="headerlink" title="编译过程运行原理"></a>编译过程运行原理</h2><p>fis的编译过程可以分为两个阶段： 单文件编译 和 打包。处理流程如下图，图片来自 FIS 官网：</p>
<p><img src="https://github.com/Tiffanysbear/accumulation/raw/master/image/fis-1.png" alt></p>
<a id="more"></a>

<h3 id="单文件编译过程"><a href="#单文件编译过程" class="headerlink" title="单文件编译过程"></a>单文件编译过程</h3><p>从图上可以看出，单文件编译过程都是通过pipe管道进行的，并且在最初都建立有缓存，以提升编译效率，在单文件的处理过程中，又主要分为了以下的几个步骤：</p>
<blockquote>
</blockquote>
<ul>
<li>parser(编译器)：将其他语言编译为标准js、css，比如将前端模板、coffee-script编译为js，将less、sass编译为css。</li>
<li>preprocessor(标准预处理器)：在fis进行标准化处理之前进行某些修改，比如 支持image-set语法的预处理插件</li>
<li>standard(标准化处理)：前面两项处理会将文件处理为标准的js、css、html语法，fis内核的标准化处理过程对这些语言进行 三种语言能力 扩展处理。这也就意味着，使用less、coffee等语法在fis系统中一样具备 资源定位、内容嵌入，依赖声明 的能力。该过程 不可扩展。</li>
<li>postprocessor(标准后处理器)：对文件进行标准化之后的处理，比如利用依赖声明能力实现的 js包装器插件，可以获取js文件的依赖关系，并添加define包装。</li>
<li>lint(可选)(校验器)：代码校验阶段，使用 fis release命令的 –lint 参数会调用该过程。</li>
<li>test(可选)(测试器)：自动测试阶段，使用 fis release命令的 –test 参数会调用该过程。</li>
<li>optimize(可选)(优化器)：代码优化阶段，使用 fis release命令的 –optimize 参数会调用该过程。fis内置的fis-optimizer-uglify-js插件和fis-optimizer-clean-css插件都是这类扩展。</li>
</ul>
<h3 id="打包过程"><a href="#打包过程" class="headerlink" title="打包过程"></a>打包过程</h3><p>如果是文件的简单合并，可以使用 __inline 进行简单的内容嵌入，如果嵌入的内容中需要实时嵌入动态变量，可以考虑使用 bdtmpl 进行前端模块的编译和转换。</p>
<p>打包的原理是通过 FIS 的pack 配置，对文件资源进行合并等操作，最后产出关于文件打包信息到 map.json 文件中，并产生相应的打包文件。所以 FIS 的打包结果并 不会再嵌入到某个文件内，而是利用map.json中的数据进行运行时打包信息查询。</p>
<p>一、 在fis-conf.js中配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fis.config.merge(&#123;</span><br><span class="line">    pack : &#123;</span><br><span class="line">        &apos;aio.js&apos; : [&apos;a.js&apos;, &apos;b.js&apos;, &apos;c.js&apos;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>二、 执行命令 fis release –pack –dest ./output</p>
<p>三、 进入output目录，查看map.json文件，得到内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;res&quot; : &#123;</span><br><span class="line">        &quot;a.js&quot; : &#123;</span><br><span class="line">            &quot;uri&quot; : &quot;/a.js&quot;,</span><br><span class="line">            &quot;type&quot; : &quot;js&quot;,</span><br><span class="line">            &quot;pkg&quot; : &quot;p0&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;b.js&quot; : &#123;</span><br><span class="line">            &quot;uri&quot; : &quot;/b.js&quot;,</span><br><span class="line">            &quot;type&quot; : &quot;js&quot;,</span><br><span class="line">            &quot;pkg&quot; : &quot;p0&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;c.js&quot; : &#123;</span><br><span class="line">            &quot;uri&quot; : &quot;/c.js&quot;,</span><br><span class="line">            &quot;type&quot; : &quot;js&quot;,</span><br><span class="line">            &quot;pkg&quot; : &quot;p0&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;pkg&quot; : &#123;</span><br><span class="line">        &quot;p0&quot; : &#123;</span><br><span class="line">            &quot;uri&quot; : &quot;/aio.js&quot;,</span><br><span class="line">            &quot;type&quot; : &quot;js&quot;,</span><br><span class="line">            &quot;has&quot; : [&quot;a.js&quot;, &quot;b.js&quot;, &quot;c.js&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>四、 将map.json交给某个前端或后端框架，当运行时需要“a.js”资源的时候，该框架应该读取map.json的信息，并根据一定的策略决定是否应该返回“a.js”资源所标记的“p0”包的uri。</p>
<p>因此也可以看出，FIS 团队强调的一点，打包只是资源的备份。</p>
<p>fis系统的打包过程提供了4个可扩展的处理过程，它们是：</p>
<ol>
<li>prepackager(打包预处理器)：在打包前进行资源预处理。</li>
<li>packager(打包处理器)：对资源进行打包。默认的打包器就是收集资源表，建立map.json的过程</li>
<li>spriter(csssprite处理器)：对css进行sprites化处理</li>
<li>postpackager(打包后处理器)：打包之后对文件进行处理，通常用来将map.json转换成其他语言的文件，比如php</li>
</ol>
<h2 id="插件调用机制"><a href="#插件调用机制" class="headerlink" title="插件调用机制"></a>插件调用机制</h2><p>fis的插件也是一个npm包，利用fis.require函数来加载。当我们在fis系统中加载一个插件的时候，会利用 nodejs的require向上查找机制 从 fis-kernel 模块出发，向上查找所需模块。</p>
<p>fis插件系统巧妙的利用了nodejs的require机制来实现其扩展机制。这意味着，要想扩展fis可以有 三种途径 ：</p>
<p>1、使用fis的用户，自己需要某种插件，可以在fis安装目录的 同级，安装自己扩展的插件。比如： <code>npm install -g fis</code>   <code>npm install -g fis-parser-coffee-script</code><br>2、使用 FIS 内置的插件，目前已经内置的插件包括：</p>
<ul>
<li>fis-kernel：fis编译机制内核</li>
<li>fis-command-release：fis release命令的提供者，处理编译过程，并提供文件监听、自动上传等功能</li>
<li>fis-command-install：fis install命令的提供者，用于从fis仓库下载组件、配置、框架、素材等资源</li>
<li>fis-command-server：fis server命令的提供者，用于开启一个本地php-cgi服务器，对项目进行预览、调试。</li>
<li>fis-optimizer-uglify-js：fis的优化插件，调用uglify-js对文件内容进行js压缩。</li>
<li>fis-optimizer-clean-css：fis的优化插件，调用clean-css对文件内容进行css压缩。</li>
<li>fis-postprocessor-jswrapper：fis的后处理器插件，用于对js文件进行包装，支持amd的define包装或者匿名自执行函数包装。</li>
</ul>
<p>3、开发一个依赖于fis模块的npm包，并在这个包里定制所需要的插件。这种方式与上一条类似，也是将插件安装在fis的同级目录下。</p>
<h3 id="可扩展时机"><a href="#可扩展时机" class="headerlink" title="可扩展时机"></a>可扩展时机</h3><p>在整个编译流程可以扩展的点有以下，也就说说我们自己自定义的插件可以在下列的时机进行自己需求的定制，通过回调获取该阶段编译的结果，进行自定义配置。<br>编译阶段：</p>
<ul>
<li>parser</li>
<li>preprocessor</li>
<li>postprocessor</li>
<li>lint</li>
<li>test</li>
</ul>
<p>打包阶段：</p>
<ul>
<li>prepackager</li>
<li>packager</li>
<li>spriter</li>
<li>postpackager</li>
</ul>
<h3 id="自定义插件"><a href="#自定义插件" class="headerlink" title="自定义插件"></a>自定义插件</h3><p>自定义插件需要的，需要封装一个npm包，结合上面的可扩展时机，命名规则一般为：fis-[需要插入的时机名称]-[自定义插件名]，例如：fis-parse-my-css;</p>
<h4 id="编译阶段插件"><a href="#编译阶段插件" class="headerlink" title="编译阶段插件"></a>编译阶段插件</h4><p>1、在自定义插件的index.js中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * fis</span><br><span class="line"> * http://fis.baidu.com/</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">&apos;use strict&apos;;</span><br><span class="line"></span><br><span class="line">var sass = require(&apos;node-sass&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = function(content, file, settings) &#123;</span><br><span class="line">    // content: 内容</span><br><span class="line">    // file: 文件</span><br><span class="line">    // settings: 现在的配置</span><br><span class="line">    var opts = fis.util.clone(settings);</span><br><span class="line">    opts.data = content;</span><br><span class="line">    return sass.renderSync(opts);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2、插件配置调用<br>在fis-config.js中调用格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// vi fis-conf.js</span><br><span class="line">// 文件后缀 .scss 的调用插件 my-sass 进行解析</span><br><span class="line">fis.config.set(&apos;modules.parser.scss&apos;, &apos;my-sass&apos;);</span><br><span class="line">fis.config.set(&apos;settings.parser.my-sass&apos;, &#123;</span><br><span class="line">    // my-sass 的配置</span><br><span class="line">&#125;);</span><br><span class="line">fis.config.set(&apos;roadmap.ext.scss&apos;, &apos;css&apos;); // 由于 scss 文件最终会编译成 css，设置最终产出文件后缀为 css</span><br></pre></td></tr></table></figure>

<p>3、发布npm包，这个可以参考我之前写过的一个文档，<a href="https://juejin.im/post/5d5a4284518825388716035f" target="_blank" rel="noopener">从0到1发布一个npm包</a></p>
<h4 id="打包阶段插件"><a href="#打包阶段插件" class="headerlink" title="打包阶段插件"></a>打包阶段插件</h4><p>1、插件接口如此：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 打包阶段插件接口</span><br><span class="line"> * @param  &#123;Object&#125; ret      一个包含处理后源码的结构</span><br><span class="line"> * @param  &#123;Object&#125; conf     一般不需要关心，自动打包配置文件</span><br><span class="line"> * @param  &#123;Object&#125; settings 插件配置属性</span><br><span class="line"> * @param  &#123;Object&#125; opt      命令行参数</span><br><span class="line"> * @return &#123;undefined&#125;          </span><br><span class="line"> */</span><br><span class="line">module.exports = function (ret, conf, settings, opt) &#123;</span><br><span class="line">    // ret.src 所有的源码，结构是 &#123;&apos;&lt;subpath&gt;&apos;: &lt;File 对象&gt;&#125;</span><br><span class="line">    // ret.ids 所有源码列表，结构是 &#123;&apos;&lt;id&gt;&apos;: &lt;File 对象&gt;&#125;</span><br><span class="line">    // ret.map 如果是 spriter、postpackager 这时候已经能得到打包结果了，</span><br><span class="line">    // 可以修改静态资源列表或者其他</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以prepackager插件为例。prepackager即打包前需要对文件做某些处理，比如想在所有的html注释里面插入编译时间。</p>
<p>2、插件开发</p>
<p>我们为这个插件取名叫 append-build-time</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;npm/global/path&gt;/fis-prepackager-append-build-time</span><br><span class="line">&lt;npm/global/path&gt;/fis-prepackager-append-build-time/index.js</span><br></pre></td></tr></table></figure>

<p>在其 index.js 中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports = function(ret, conf, settings, opt) &#123;</span><br><span class="line">    fis.util.map(ret.src, function(subpath, file) &#123;</span><br><span class="line">        if (file.isHtmlLike) &#123;</span><br><span class="line">            var content = file.getContent();</span><br><span class="line">            content += &apos;&lt;!-- build &apos;+ (new Date())+&apos;--&gt;&apos;;</span><br><span class="line">            file.setContent(content);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>3、配置使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// vi fis-conf.js</span><br><span class="line">fis.config.set(&apos;modules.prepackager&apos;, &apos;append-build-time&apos;); // packager阶段插件处理所有文件，所以不需要给某一类后缀的文件设置。</span><br><span class="line">fis.config.set(&apos;settings.prepackager.append-build-time&apos;, &#123;</span><br><span class="line">    // settings</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>4、发布npm包，这个可以参考我之前写过的一个文档，<a href="https://juejin.im/post/5d5a4284518825388716035f" target="_blank" rel="noopener">从0到1发布一个npm包</a></p>
<h4 id="小提示："><a href="#小提示：" class="headerlink" title="小提示："></a>小提示：</h4><p>当然为了更快速的搞定一些小需求，可以把插件功能直接写到配置文件 fis-conf.js 中；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// vi fis-conf.js</span><br><span class="line">fis.config.set(&apos;modules.postprocessor.js&apos;, function (content) &#123;</span><br><span class="line">    return content += &apos;\n// build time: &apos; + Date.now();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>注意：配置使用插件时，同一个扩展点可以配置多个插件，比如；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 调用 fis-prepackager-a, fis-prepackager-b ...插件</span><br><span class="line">fis.config.set(&apos;modules.prepackager&apos;, &apos;a,b,c,d&apos;);</span><br><span class="line">// or</span><br><span class="line">fis.config.set(&apos;modules.prepackager&apos;, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]);</span><br><span class="line">// or</span><br><span class="line">fis.config.set(&apos;modules.prepackager&apos;, [function () &#123;&#125;, function () &#123;&#125;])</span><br></pre></td></tr></table></figure>

<p>具体的原理和封装步骤就讲到这么多，具体封装解决方案可以见 FIS 的官网 —— <a href="http://fex-team.github.io/fis-site/docs/dev/solution.html" target="_blank" rel="noopener">封装解决方案</a></p>
<p>本文参考文档：</p>
<p>1、<a href="http://fex-team.github.io/fis-site/docs/more/extension-point.html" target="_blank" rel="noopener">插件扩展点列表</a> <a href="http://fex-team.github.io/fis-site/docs/more/extension-point.html" target="_blank" rel="noopener">http://fex-team.github.io/fis-site/docs/more/extension-point.html</a><br>2、<a href="http://fex-team.github.io/fis-site/docs/more/how-plugin-works.html" target="_blank" rel="noopener">插件调用机制</a> <a href="http://fex-team.github.io/fis-site/docs/more/how-plugin-works.html" target="_blank" rel="noopener">http://fex-team.github.io/fis-site/docs/more/how-plugin-works.html</a><br>3、<a href="http://fex-team.github.io/fis-site/docs/more/fis-base.html" target="_blank" rel="noopener">编译过程运行原理</a> <a href="http://fex-team.github.io/fis-site/docs/more/fis-base.html" target="_blank" rel="noopener">http://fex-team.github.io/fis-site/docs/more/fis-base.html</a></p>
<p>我的博客即将同步至腾讯云+社区，邀请大家一同入驻：<a href="https://cloud.tencent.com/developer/support-plan?invite_code=jam988nsd8ol" target="_blank" rel="noopener">https://cloud.tencent.com/developer/support-plan?invite_code=jam988nsd8ol</a></p>
]]></content>
      <categories>
        <category>插件</category>
      </categories>
      <tags>
        <tag>FIS</tag>
      </tags>
  </entry>
  <entry>
    <title>重新理解前端系列 — AMD、CMD</title>
    <url>/2019/08/21/%E9%87%8D%E6%96%B0%E7%90%86%E8%A7%A3AMD%E3%80%81CMD/</url>
    <content><![CDATA[<blockquote>
<p>重新理解前端系列 — AMD、CMD<br>author: <a href="https://tiffanysbear.github.io/" target="_blank" rel="noopener">@TiffanysBear</a></p>
</blockquote>
<p>本文主要是针对之前一些熟悉的前端概念，再次回顾的时候，结合自己的开发经验和使用，进行再次理解。经过了开发和线上使用之后，会有更为深刻的印象。对比requirejs源码分析，实现一个模块加载器，需要考虑哪些问题。</p>
<h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>其实对于AMD和CMD的不同，之前一直是拘泥在使用上的不同。没有深刻的认识为什么会有不同，其实主要是因为浏览器端和 Node 端不同性能特点和瓶颈带来的不同。</p>
<p>早期的js模块化主要用于浏览器端，主要的需求和瓶颈在于带宽，需要将js从服务端下载下来，从而带来的网络性能开销，因此主要是满足对于作用域、按需加载的需求。因此AMD（异步模块定义）的出现，适合浏览器端环境。</p>
<p>而后出现Node之后，主要的性能开销不再是网络性能，磁盘的读写和开销可以忽略不计；CMD的出现更符合Node 对于CommonJS的定义和理解，在运行时进行加载，引入时只是产生引用指向关系。</p>
<p>因此两者产生了不同的使用特点，在出现循环引用时，就产生了不同的现象。以下是针对 requirejs 源码部分的解读。如果有问题，欢迎提问纠正。</p>
<h4 id="1、动态加载一个js模块的方法，怎么保证异步和回调的执行"><a href="#1、动态加载一个js模块的方法，怎么保证异步和回调的执行" class="headerlink" title="1、动态加载一个js模块的方法，怎么保证异步和回调的执行"></a>1、动态加载一个js模块的方法，怎么保证异步和回调的执行</h4><p>一先开始是需要判断环境，浏览器环境和webworker环境；如果是浏览器环境，通过<code>document.createElement</code> 创建script标签，使用async属性使js能进行异步加载, IE等不兼容async字段的，通过监听 load 、 onreadystatechange 事件执行回调，监听脚本加载完成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">req.createNode = function (config, moduleName, url) &#123;</span><br><span class="line">    var node = config.xhtml ?</span><br><span class="line">        document.createElementNS(&apos;http://www.w3.org/1999/xhtml&apos;, &apos;html:script&apos;) :</span><br><span class="line">        document.createElement(&apos;script&apos;);</span><br><span class="line">    node.type = config.scriptType || &apos;text/javascript&apos;;</span><br><span class="line">    node.charset = &apos;utf-8&apos;;</span><br><span class="line">    node.async = true; //创建script标签添加了async属性</span><br><span class="line">    return node;</span><br><span class="line">&#125;;</span><br><span class="line">req.load = function (context, moduleName, url) &#123; //用来进行js模块加载的方法</span><br><span class="line">    var config = (context &amp;&amp; context.config) || &#123;&#125;,</span><br><span class="line">    	node;</span><br><span class="line">    if (isBrowser) &#123; //在浏览器中加载js文件</span><br><span class="line">    </span><br><span class="line">        node = req.createNode(config, moduleName, url); //创建一个script标签</span><br><span class="line">        </span><br><span class="line">        node.setAttribute(&apos;data-requirecontext&apos;, context.contextName); //requirecontext默认为&apos;_&apos;</span><br><span class="line">        node.setAttribute(&apos;data-requiremodule&apos;, moduleName); //当前模块名</span><br><span class="line">        </span><br><span class="line">        if (node.attachEvent &amp;&amp;</span><br><span class="line">            !(node.attachEvent.toString &amp;&amp; node.attachEvent.toString().indexOf(&apos;[native code&apos;) &lt; 0) &amp;&amp;</span><br><span class="line">            !isOpera) &#123;</span><br><span class="line">            </span><br><span class="line">            useInteractive = true;</span><br><span class="line">            </span><br><span class="line">            node.attachEvent(&apos;onreadystatechange&apos;, context.onScriptLoad);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            node.addEventListener(&apos;load&apos;, context.onScriptLoad, false);</span><br><span class="line">            node.addEventListener(&apos;error&apos;, context.onScriptError, false);</span><br><span class="line">        &#125;</span><br><span class="line">        node.src = url;</span><br><span class="line">        </span><br><span class="line">        if (config.onNodeCreated) &#123; //script标签创建时的回调</span><br><span class="line">            config.onNodeCreated(node, config, moduleName, url);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        currentlyAddingScript = node;</span><br><span class="line">        if (baseElement) &#123; //将script标签添加到页面中</span><br><span class="line">            head.insertBefore(node, baseElement);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            head.appendChild(node);</span><br><span class="line">        &#125;</span><br><span class="line">        currentlyAddingScript = null;</span><br><span class="line">        </span><br><span class="line">        return node;</span><br><span class="line">    &#125; else if (isWebWorker) &#123; //在webWorker环境中</span><br><span class="line">    	try &#123;</span><br><span class="line">            setTimeout(function () &#123; &#125;, 0);</span><br><span class="line">            importScripts(url); //webWorker中使用importScripts来加载脚本</span><br><span class="line">            </span><br><span class="line">            context.completeLoad(moduleName);</span><br><span class="line">    	&#125; catch (e) &#123; //加载失败</span><br><span class="line">            context.onError(makeError(&apos;importscripts&apos;,</span><br><span class="line">                &apos;importScripts failed for &apos; +</span><br><span class="line">                moduleName + &apos; at &apos; + url,</span><br><span class="line">                e,</span><br><span class="line">                [moduleName]));</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2、怎么判断去加载js，怎么保证加载的顺序"><a href="#2、怎么判断去加载js，怎么保证加载的顺序" class="headerlink" title="2、怎么判断去加载js，怎么保证加载的顺序"></a>2、怎么判断去加载js，怎么保证加载的顺序</h4><p>通过 setTimeout 放入下一个队列中，保证加载顺序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//通过setTimeout的方式加载依赖，放入下一个队列，保证加载顺序</span><br><span class="line">context.nextTick(function () &#123;</span><br><span class="line">	//Some defines could have been added since the</span><br><span class="line">	//require call, collect them.</span><br><span class="line">	intakeDefines();</span><br><span class="line"></span><br><span class="line">	requireMod = getModule(makeModuleMap(null, relMap));</span><br><span class="line"></span><br><span class="line">	//Store if map config should be applied to this require</span><br><span class="line">	//call for dependencies.</span><br><span class="line">	requireMod.skipMap = options.skipMap;</span><br><span class="line"></span><br><span class="line">	requireMod.init(deps, callback, errback, &#123;</span><br><span class="line">		enabled: true</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	checkLoaded();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="3、require中的js文件是怎么判断已经loaded，怎么保证加载数据的数量是正确的？"><a href="#3、require中的js文件是怎么判断已经loaded，怎么保证加载数据的数量是正确的？" class="headerlink" title="3、require中的js文件是怎么判断已经loaded，怎么保证加载数据的数量是正确的？"></a>3、require中的js文件是怎么判断已经loaded，怎么保证加载数据的数量是正确的？</h4><p>依赖数量，是通过 depCount 来计算的，通过循环遍历，统计具体的依赖数量；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// ...</span><br><span class="line">enable: function () &#123;</span><br><span class="line">	enabledRegistry[this.map.id] = this;</span><br><span class="line">	this.enabled = true;</span><br><span class="line"></span><br><span class="line">	//Set flag mentioning that the module is enabling,</span><br><span class="line">	//so that immediate calls to the defined callbacks</span><br><span class="line">	//for dependencies do not trigger inadvertent load</span><br><span class="line">	//with the depCount still being zero.</span><br><span class="line">	this.enabling = true;</span><br><span class="line"></span><br><span class="line">	//enable每一个依赖</span><br><span class="line">	each(this.depMaps, bind(this, function (depMap, i) &#123;</span><br><span class="line">		var id, mod, handler;</span><br><span class="line"></span><br><span class="line">		if (typeof depMap === &apos;string&apos;) &#123;</span><br><span class="line">			//Dependency needs to be converted to a depMap</span><br><span class="line">			//and wired up to this module.</span><br><span class="line">			depMap = makeModuleMap(depMap,</span><br><span class="line">				(this.map.isDefine ? this.map : this.map.parentMap),</span><br><span class="line">				false,</span><br><span class="line">				!this.skipMap);</span><br><span class="line">			this.depMaps[i] = depMap; //获取的依赖映射</span><br><span class="line"></span><br><span class="line">			handler = getOwn(handlers, depMap.id);</span><br><span class="line"></span><br><span class="line">			if (handler) &#123;</span><br><span class="line">				this.depExports[i] = handler(this);</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			this.depCount += 1; //依赖项+1</span><br><span class="line"></span><br><span class="line">			on(depMap, &apos;defined&apos;, bind(this, function (depExports) &#123;</span><br><span class="line">				if (this.undefed) &#123;</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line">				this.defineDep(i, depExports); //加载完毕的依赖模块放入depExports中，通过apply方式传入require定义的函数中</span><br><span class="line">				this.check();</span><br><span class="line">			&#125;)); //绑定defined事件，同时将dep添加到registry中</span><br><span class="line"></span><br><span class="line">			if (this.errback) &#123;</span><br><span class="line">				on(depMap, &apos;error&apos;, bind(this, this.errback));</span><br><span class="line">			&#125; else if (this.events.error) &#123;</span><br><span class="line">				// No direct errback on this module, but something</span><br><span class="line">				// else is listening for errors, so be sure to</span><br><span class="line">				// propagate the error correctly.</span><br><span class="line">				on(depMap, &apos;error&apos;, bind(this, function (err) &#123;</span><br><span class="line">					this.emit(&apos;error&apos;, err);</span><br><span class="line">				&#125;));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		id = depMap.id;</span><br><span class="line">		mod = registry[id];</span><br><span class="line"></span><br><span class="line">		//跳过一些特殊模块，比如：&apos;require&apos;, &apos;exports&apos;, &apos;module&apos;</span><br><span class="line">		//Also, don&apos;t call enable if it is already enabled,</span><br><span class="line">		//important in circular dependency cases.</span><br><span class="line">		if (!hasProp(handlers, id) &amp;&amp; mod &amp;&amp; !mod.enabled) &#123;</span><br><span class="line">			context.enable(depMap, this); //加载依赖</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;));</span><br><span class="line"></span><br><span class="line">	//Enable each plugin that is used in</span><br><span class="line">	//a dependency</span><br><span class="line">	eachProp(this.pluginMaps, bind(this, function (pluginMap) &#123;</span><br><span class="line">		var mod = getOwn(registry, pluginMap.id);</span><br><span class="line">		if (mod &amp;&amp; !mod.enabled) &#123;</span><br><span class="line">			context.enable(pluginMap, this);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;));</span><br><span class="line"></span><br><span class="line">	this.enabling = false;</span><br><span class="line"></span><br><span class="line">	this.check();</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>判断单个文件加载成功，是通过 checkLoaded 每间隔 50s 做一次轮询进行判断，变量 inCheckLoaded 作为标识；下面是 checkLoaded 函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function checkLoaded() &#123;</span><br><span class="line">	var err, usingPathFallback,</span><br><span class="line">		waitInterval = config.waitSeconds * 1000,</span><br><span class="line">		//It is possible to disable the wait interval by using waitSeconds of 0.</span><br><span class="line">		expired = waitInterval &amp;&amp; (context.startTime + waitInterval) &lt; new Date().getTime(),</span><br><span class="line">		noLoads = [],</span><br><span class="line">		reqCalls = [],</span><br><span class="line">		stillLoading = false,</span><br><span class="line">		needCycleCheck = true;</span><br><span class="line"></span><br><span class="line">	//Do not bother if this call was a result of a cycle break.</span><br><span class="line">	if (inCheckLoaded) &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	inCheckLoaded = true;</span><br><span class="line"></span><br><span class="line">	//Figure out the state of all the modules.</span><br><span class="line">	eachProp(enabledRegistry, function (mod) &#123;</span><br><span class="line">		var map = mod.map,</span><br><span class="line">			modId = map.id;</span><br><span class="line"></span><br><span class="line">		//Skip things that are not enabled or in error state.</span><br><span class="line">		if (!mod.enabled) &#123;</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (!map.isDefine) &#123;</span><br><span class="line">			reqCalls.push(mod);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		if (!mod.error) &#123;</span><br><span class="line">			//If the module should be executed, and it has not</span><br><span class="line">			//been inited and time is up, remember it.</span><br><span class="line">			if (!mod.inited &amp;&amp; expired) &#123;</span><br><span class="line">				if (hasPathFallback(modId)) &#123;</span><br><span class="line">					usingPathFallback = true;</span><br><span class="line">					stillLoading = true;</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					noLoads.push(modId);</span><br><span class="line">					removeScript(modId);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; else if (!mod.inited &amp;&amp; mod.fetched &amp;&amp; map.isDefine) &#123;</span><br><span class="line">				stillLoading = true;</span><br><span class="line">				if (!map.prefix) &#123;</span><br><span class="line">					//No reason to keep looking for unfinished</span><br><span class="line">					//loading. If the only stillLoading is a</span><br><span class="line">					//plugin resource though, keep going,</span><br><span class="line">					//because it may be that a plugin resource</span><br><span class="line">					//is waiting on a non-plugin cycle.</span><br><span class="line">					return (needCycleCheck = false);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	if (expired &amp;&amp; noLoads.length) &#123;</span><br><span class="line">		//If wait time expired, throw error of unloaded modules.</span><br><span class="line">		err = makeError(&apos;timeout&apos;, &apos;Load timeout for modules: &apos; + noLoads, null, noLoads);</span><br><span class="line">		err.contextName = context.contextName;</span><br><span class="line">		return onError(err);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//Not expired, check for a cycle.</span><br><span class="line">	if (needCycleCheck) &#123;</span><br><span class="line">		each(reqCalls, function (mod) &#123;</span><br><span class="line">			breakCycle(mod, &#123;&#125;, &#123;&#125;);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	//If still waiting on loads, and the waiting load is something</span><br><span class="line">	//other than a plugin resource, or there are still outstanding</span><br><span class="line">	//scripts, then just try back later.</span><br><span class="line">	if ((!expired || usingPathFallback) &amp;&amp; stillLoading) &#123;</span><br><span class="line">		//Something is still waiting to load. Wait for it, but only</span><br><span class="line">		//if a timeout is not already in effect.</span><br><span class="line">		if ((isBrowser || isWebWorker) &amp;&amp; !checkLoadedTimeoutId) &#123;</span><br><span class="line">			checkLoadedTimeoutId = setTimeout(function () &#123;</span><br><span class="line">				checkLoadedTimeoutId = 0;</span><br><span class="line">				checkLoaded();</span><br><span class="line">			&#125;, 50);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	inCheckLoaded = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4、如果有循环引用，怎么判断出的，怎么解决的"><a href="#4、如果有循环引用，怎么判断出的，怎么解决的" class="headerlink" title="4、如果有循环引用，怎么判断出的，怎么解决的"></a>4、如果有循环引用，怎么判断出的，怎么解决的</h4><p>这部分暂且还有点疑惑，先mark一下，之后再理解；</p>
<p>看到有个 breakCycle 函数，执行条件是 needCycleCheck 为 true，但是当 <code>!mod.inited &amp;&amp; mod.fetched &amp;&amp; map.isDefine</code> 模块未被初始化完成，但是已经获取过定义过之后，且 在 map.prefix 有前缀，会启动 breakCycle 检查；至于为什么要这么做，只能猜测是为了到模块require时循环引用打破轮询查询加载状态等待的问题，现在先留一个疑问。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function breakCycle(mod, traced, processed) &#123;</span><br><span class="line">	var id = mod.map.id;</span><br><span class="line"></span><br><span class="line">	if (mod.error) &#123;</span><br><span class="line">		mod.emit(&apos;error&apos;, mod.error);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		traced[id] = true;</span><br><span class="line">		each(mod.depMaps, function (depMap, i) &#123;</span><br><span class="line">			var depId = depMap.id,</span><br><span class="line">				dep = getOwn(registry, depId);</span><br><span class="line"></span><br><span class="line">			//Only force things that have not completed</span><br><span class="line">			//being defined, so still in the registry,</span><br><span class="line">			//and only if it has not been matched up</span><br><span class="line">			//in the module already.</span><br><span class="line">			if (dep &amp;&amp; !mod.depMatched[i] &amp;&amp; !processed[depId]) &#123;</span><br><span class="line">				if (getOwn(traced, depId)) &#123;</span><br><span class="line">					mod.defineDep(i, defined[depId]);</span><br><span class="line">					mod.check(); //pass false?</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					breakCycle(dep, traced, processed);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		processed[id] = true;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在CommonJs中时，存在依赖的情况下，因为存在的只是引用，代码执行是在实际调用时才发生，在文件的开头和结尾也会有变量标识是否加载完成。一旦某个模块出现循环依赖加载<br>，就只输出已经执行到的部分，还未执行的部分不会输出。</p>
<p>在ES6模块加载的循环加载情况下，ES6是动态引用的，不存在缓存值问题，而且模块里面的变量绑定所在的模块；不关心是否发生了循环加载，只是生成一个指向被加载模块的引用，需要开发者自己来保证真正取值的时候能够取到值。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>AMD、CMD</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js中watch的高级用法</title>
    <url>/2019/08/21/Vue.js%E4%B8%ADwatch%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>Vue.js中watch的高级用法<br>转载自 <a href="https://juejin.im/post/5ae91fa76fb9a07aa7677543" target="_blank" rel="noopener">https://juejin.im/post/5ae91fa76fb9a07aa7677543</a><br>author: <a href="blog.dunizb.com/">Dunizb</a></p>
</blockquote>
<p>在 Vue.js 的学习中，看到这篇文章，转载记录一下用作备忘。</p>
<p>假设有如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">      &lt;p&gt;FullName: &#123;&#123;fullName&#125;&#125;&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;FirstName: &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#root&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: &apos;Dawei&apos;,</span><br><span class="line">    lastName: &apos;Lou&apos;,</span><br><span class="line">    fullName: &apos;&apos;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    firstName(newName, oldName) &#123;</span><br><span class="line">      this.fullName = newName + &apos; &apos; + this.lastName;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>复制代码上面的代码的效果是，当我们输入firstName后，wacth监听每次修改变化的新值，然后计算输出fullName。</p>
<h3 id="handler方法和immediate属性"><a href="#handler方法和immediate属性" class="headerlink" title="handler方法和immediate属性"></a>handler方法和immediate属性</h3><p>这里 watch 的一个特点是，最初绑定的时候是不会执行的，要等到 firstName 改变时才执行监听计算。那我们想要一开始就让他最初绑定的时候就执行改怎么办呢？我们需要修改一下我们的 watch 写法，修改过后的 watch 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  firstName: &#123;</span><br><span class="line">    handler(newName, oldName) &#123;</span><br><span class="line">      this.fullName = newName + &apos; &apos; + this.lastName;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 代表在wacth里声明了firstName这个方法之后立即先去执行handler方法</span><br><span class="line">    immediate: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>复制代码注意到handler了吗，我们给 firstName 绑定了一个handler方法，之前我们写的 watch 方法其实默认写的就是这个handler，Vue.js会去处理这个逻辑，最终编译出来其实就是这个handler。<br>而immediate:true代表如果在 wacth 里声明了 firstName 之后，就会立即先去执行里面的handler方法，如果为 false就跟我们以前的效果一样，不会在绑定的时候就执行。</p>
<h3 id="deep属性"><a href="#deep属性" class="headerlink" title="deep属性"></a>deep属性</h3><p>watch 里面还有一个属性 deep，默认值是 false，代表是否深度监听，比如我们 data 里有一个obj属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">      &lt;p&gt;obj.a: &#123;&#123;obj.a&#125;&#125;&lt;/p&gt;</span><br><span class="line">      &lt;p&gt;obj.a: &lt;input type=&quot;text&quot; v-model=&quot;obj.a&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#root&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    obj: &#123;</span><br><span class="line">      a: 123</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    obj: &#123;</span><br><span class="line">      handler(newName, oldName) &#123;</span><br><span class="line">         console.log(&apos;obj.a changed&apos;);</span><br><span class="line">      &#125;,</span><br><span class="line">      immediate: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>复制代码当我们在在输入框中输入数据视图改变obj.a的值时，我们发现是无效的。受现代 JavaScript 的限制 (以及废弃 Object.observe)，Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。<br>默认情况下 handler 只监听obj这个属性它的引用的变化，我们只有给obj赋值的时候它才会监听到，比如我们在 mounted事件钩子函数中对obj进行重新赋值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mounted: &#123;</span><br><span class="line">  this.obj = &#123;</span><br><span class="line">    a: &apos;456&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复制代码这样我们的 handler 才会执行，打印obj.a changed。<br>相反，如果我们需要监听obj里的属性a的值呢？这时候deep属性就派上用场了！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  obj: &#123;</span><br><span class="line">    handler(newName, oldName) &#123;</span><br><span class="line">      console.log(&apos;obj.a changed&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    immediate: true,</span><br><span class="line">    deep: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复制代码deep的意思就是深入观察，监听器会一层层的往下遍历，给对象的所有属性都加上这个监听器，但是这样性能开销就会非常大了，任何修改obj里面任何一个属性都会触发这个监听器里的 handler。<br>优化，我们可以是使用字符串形式监听。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  &apos;obj.a&apos;: &#123;</span><br><span class="line">    handler(newName, oldName) &#123;</span><br><span class="line">      console.log(&apos;obj.a changed&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line">    immediate: true,</span><br><span class="line">    // deep: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复制代码这样Vue.js才会一层一层解析下去，直到遇到属性a，然后才给a设置监听函数。</p>
<h3 id="注销watch"><a href="#注销watch" class="headerlink" title="注销watch"></a>注销watch</h3><p>为什么要注销 watch？因为我们的组件是经常要被销毁的，比如我们跳一个路由，从一个页面跳到另外一个页面，那么原来的页面的 watch 其实就没用了，这时候我们应该注销掉原来页面的 watch 的，不然的话可能会导致内置溢出。好在我们平时 watch 都是写在组件的选项中的，他会随着组件的销毁而销毁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const app = new Vue(&#123;</span><br><span class="line">  template: &apos;&lt;div id=&quot;root&quot;&gt;&#123;&#123;text&#125;&#125;&lt;/div&gt;&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    text: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    text(newVal, oldVal)&#123;</span><br><span class="line">      console.log(`$&#123;newVal&#125; : $&#123;oldVal&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>复制代码但是，如果我们使用下面这样的方式写 watch，那么就要手动注销了，这种注销其实也很简单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const unWatch = app.$watch(&apos;text&apos;, (newVal, oldVal) =&gt; &#123;</span><br><span class="line">  console.log(`$&#123;newVal&#125; : $&#123;oldVal&#125;`);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">unWatch(); // 手动注销watch</span><br></pre></td></tr></table></figure>

<p>复制代码app.$watch调用后会返回一个值，就是unWatch方法，你要注销 watch 只要调用unWatch方法就可以了。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue学习</tag>
      </tags>
  </entry>
  <entry>
    <title>从0到1发布一个npm包</title>
    <url>/2019/08/15/%E4%BB%8E0%E5%88%B01%E5%8F%91%E5%B8%83%E4%B8%80%E4%B8%AAnpm%E5%8C%85/</url>
    <content><![CDATA[<blockquote>
<p>从0到1发布一个npm包<br>author: <a href="https://tiffanysbear.github.io/" target="_blank" rel="noopener">@TiffanysBear</a></p>
</blockquote>
<p>最近在项目业务中有遇到一些问题，一些通用的方法或者封装的模块在PC、WAP甚至是APP中都需要使用，但是对于业务的PC、WAP、APP往往是不同的业务、不同的代码库中，尽管已经将公用的组件和方法抽离到各自公共common中，但是各个大业务大方向上的公用封装依然不能满足需求。</p>
<p>比如一个计算文档类型大小的方法，可能都同时存在于各个业务的common中，假设是有3处代码库中均有；如果此时的需求是将文档类型或者大小的方法进行一些修改，增加一种文档类型或者减少一种文档类型，那咱们是否是需要去共同修改上面的3处方法。这样做，很不利于代码的维护，浪费人力，增加了代码工作量。</p>
<p>那么，如何做到管理一些公共依赖的基础模块代码呢？这时候，封装发布一个npm包进行统一管理就是一个很好的办法了。</p>
<p>先po一下我在写这篇文章时，根据以下的步骤发布的一个简单封装的npm包以及github地址，大家可以先看：</p>
<p><a href="https://www.npmjs.com/package/page-performance-monitor" target="_blank" rel="noopener">npm包：page-performance-monitor</a><br><a href="https://github.com/Tiffanysbear/page-performance-monitor">github地址：page-performance-monitor，欢迎 star、issue</a></p>
<p>下面，就从0开始讲起，如何从0到1发布一个npm包。先介绍一下什么是npm~</p>
<h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>npm 是JavaScript 世界的包管理工具，并且是Node.js 平台的默认包管理工具。通过npm 可以安装、共享、分发代码，管理项目依赖关系。</p>
<p><a href="https://www.npmjs.com/" target="_blank" rel="noopener">官网地址</a></p>
<p>比如有一些非常通用的公用方法，抽象封装，剔除一些冗余的业务需求，可以封装在一个npm包中，提供给相应的多个业务去使用。</p>
<p>那么接下来就列举一下封装一个简单的封装步骤；</p>
<h2 id="发布步骤"><a href="#发布步骤" class="headerlink" title="发布步骤"></a>发布步骤</h2><p>以我之前的博客中列举的页面性能监控工具performance为例，具体的<a href="https://juejin.im/post/5d53a1056fb9a06b1d213ac7" target="_blank" rel="noopener">performance介绍</a>可以点击链接，做一个简单的封装，满足基本的业务上的打点统计需求即可；后面也会讲到后续如何去封装一个高质量的npm包，比如加上一些example、测试test、完善README.md等，逐步去完善。大概是有以下几个步骤：</p>
<p>1、新建项目，准备需要发布的代码<br>2、准备package.json<br>3、注册npm账号、并登录<br>4、发布</p>
<p>其实发布的过程并不难，要发布一个好的质量高的npm包往往是取决于要封装的代码、以及对代码单测覆盖、demo案例、README介绍等</p>
<h3 id="准备项目："><a href="#准备项目：" class="headerlink" title="准备项目："></a>准备项目：</h3><p>开始准备的步骤，从一个最基础的项目新建开始，都是在Mac的Linux环境上进行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 新建项目文件夹</span><br><span class="line"> mkdir page-performance</span><br><span class="line"> </span><br><span class="line"> // 初始化npm，初始化package.json</span><br><span class="line"> npm init</span><br><span class="line"> </span><br><span class="line"> // 准备好封装代码</span><br><span class="line"> // 一般源码是放在src，通过其他打包工具生成的一般是在dist目录或者build目录</span><br><span class="line"> mkdir src</span><br><span class="line"> </span><br><span class="line"> // 可以将自己需要的代码往src中添加了</span><br><span class="line"> // 假设我们只需要发布一个index.js就好</span><br><span class="line"> // ......</span><br></pre></td></tr></table></figure>

<h3 id="发布一个最简单的npm包："><a href="#发布一个最简单的npm包：" class="headerlink" title="发布一个最简单的npm包："></a>发布一个最简单的npm包：</h3><p>1、先去<a href="https://www.npmjs.com/" target="_blank" rel="noopener">官网</a>注册一个账号，填写好账号、密码、邮箱<br>2、然后登录npm账号 <code>npm login</code>，如果你们公司有自己的默认npm仓库或者使用的淘宝镜像，注意需要指定一下仓库地址；<code>npm login --registry=https://registry.npmjs.org</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 会依次让你输入用户名、密码、和邮箱</span><br><span class="line">Username:  </span><br><span class="line">Password:</span><br><span class="line">Email: (this IS public)</span><br></pre></td></tr></table></figure>

<p>3、发布包 <code>npm publish --registry=https://registry.npmjs.org</code></p>
<p>会提示+ <a href="mailto:page-performance-monitor@1.0.0" target="_blank" rel="noopener">page-performance-monitor@1.0.0</a> 你的包名字和版本，那么说明就发布好了。</p>
<p>我在发布的时候遇到了两个小问题，记录一下，如果你们也有相同的问题，可以使用下面的解决办法：<br>1). 提示 publish Failed PUT 403</p>
<p>you must verify your email before publishing a new package: <a href="https://www.npmjs.com/email-edit" target="_blank" rel="noopener">https://www.npmjs.com/email-edit</a> : page-performance-monitor</p>
<p><img src="https://github.com/Tiffanysbear/accumulation/raw/master/image/npm-1.png" alt></p>
<p>之前登录的邮箱需要验证，去注册邮箱中找到npm发的邮件，点击验证一下就行.</p>
<p>2）第二个问题是：You do not have permission to publish “page-performance”. Are you logged in as the correct user? : page-performance<br><img src="https://github.com/Tiffanysbear/accumulation/raw/master/image/npm-1.png" alt></p>
<p>提示是说你没有权限发布这个包，其实是因为你的这个包名字和已有的重复了，需要在 package.json 里面换一个包名就行。</p>
<p>到这里，一个简单的npm包就封装好了，如何确认自己的包确认好了呢？去官网的搜索框输入你的包名<a href="https://www.npmjs.com/package/page-performance-monitor" target="_blank" rel="noopener">搜一下</a>，找到你的就ok啦~</p>
<p>到这步，你就会发布一个简单的npm包啦，如果只是一个很小的需求的化，就完全够用了；但是如果想要发布一个质量好有各种小标签logo的，那么就需要如下的步骤进行一下优化。</p>
<h3 id="优化npm包："><a href="#优化npm包：" class="headerlink" title="优化npm包："></a>优化npm包：</h3><a id="more"></a>

<h4 id="1、代码环境依赖-线上线下环境"><a href="#1、代码环境依赖-线上线下环境" class="headerlink" title="1、代码环境依赖-线上线下环境"></a>1、代码环境依赖-线上线下环境</h4><p>如果项目在线上线下使用的配置都不同的化，可以通过命令输入的不同，区分是debug模式还是生产production模式。</p>
<p><code>process.env.NODE_ENV === &#39;production&#39;</code></p>
<p>在相应的package.json中的配置中，就需要加上 <code>npm run build --mode production</code> 来进行区分。</p>
<h4 id="2、配置打包编译"><a href="#2、配置打包编译" class="headerlink" title="2、配置打包编译"></a>2、配置打包编译</h4><p>好的一个npm包，往往需要不同的产出模式，比如利于script标签使用的iife模式，或者是采用amd、cmd等的打包方式进行export；或者需要采用babel进行转义，增加polyfill；或者你需要增加demo，为demo输出不同的样例，都需要使用配置打包编译。</p>
<p>目前常见的打包编译工具有webpack、rollup、fis、gulp等工具，相信也非常熟悉了；因为我的这个只是个简单的检测页面性能的工具方法，采用较为简单的适合工具库类型打包的rollup进行打包编译。</p>
<p>rollup.config.js配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @file: rollup.config.js</span><br><span class="line"> * @author: Tiffany</span><br><span class="line"> */</span><br><span class="line">// Rollup plugins</span><br><span class="line">import resolve from &apos;rollup-plugin-node-resolve&apos;;</span><br><span class="line">import commonjs from &apos;@baidu/rollup-plugin-commonjs&apos;;</span><br><span class="line">import babel from &apos;rollup-plugin-babel&apos;;</span><br><span class="line">import uglify from &apos;rollup-plugin-uglify-es&apos;;</span><br><span class="line">export default [</span><br><span class="line">    &#123;</span><br><span class="line">        input: &apos;src/index.js&apos;,</span><br><span class="line">        output: &#123;</span><br><span class="line">            file: &apos;dist/index.js&apos;,</span><br><span class="line">            format: &apos;umd&apos;,</span><br><span class="line">            name: &apos;Perf&apos;,</span><br><span class="line">            legacy: true,</span><br><span class="line">            strict: false,</span><br><span class="line">            sourceMap: true</span><br><span class="line">        &#125;,</span><br><span class="line">        plugins: [</span><br><span class="line">            resolve(),</span><br><span class="line">            commonjs(),</span><br><span class="line">            babel(&#123;</span><br><span class="line">                runtimeHelpers: true,</span><br><span class="line">                exclude: &apos;node_modules/**&apos;</span><br><span class="line">            &#125;),</span><br><span class="line">            uglify()</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>配合babel的配置，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;: [</span><br><span class="line">        [</span><br><span class="line">            &quot;latest&quot;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;es2015&quot;: &#123;</span><br><span class="line">                    &quot;modules&quot;: false</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    ],</span><br><span class="line">    &quot;plugins&quot;: [</span><br><span class="line">        &quot;external-helpers&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就可以根据自己的需求，选择打包format的模式，产出自己需要的结果。大家也可以根据自己的项目需求、大小等，进行配置。</p>
<h4 id="3、增加单测"><a href="#3、增加单测" class="headerlink" title="3、增加单测"></a>3、增加单测</h4><p>现在前端单测的库有很多，在这里就不再赘述；在这里采用的是 mocha + chai 断言库，因为这个库是运行在浏览器端，需要依赖于 JSDOM 中的 window 对象，因为采用了 JSDOM 库来实现 DOM 对象等的构建以及全局变量 window 的加入，以下是具体的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// test/index.test.js</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @file: index.test.js</span><br><span class="line"> * @author: zhoufang04</span><br><span class="line"> * @description: mocha + chai test</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">const expect = require(&apos;chai&apos;).expect;</span><br><span class="line">const &#123;JSDOM&#125; = require(&apos;jsdom&apos;);</span><br><span class="line">const perf = require(&apos;../dist/index.js&apos;);</span><br><span class="line">const &#123;window&#125; = new JSDOM(`&lt;!DOCTYPE html&gt;</span><br><span class="line">    &lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0, maximum-scale=1.0,user-scalable=no&quot;&gt;</span><br><span class="line">        &lt;meta name=&quot;author&quot; content=&quot;test&quot;&gt;</span><br><span class="line">        &lt;title&gt;performance test&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div id=&quot;values&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">    &lt;/html&gt;`);</span><br><span class="line"></span><br><span class="line">global.window = window;</span><br><span class="line"></span><br><span class="line">describe(&apos;页面性能测试&apos;, function () &#123;</span><br><span class="line">    it(&apos;加载完成返回数据为对象&apos;, function () &#123;</span><br><span class="line">        expect(perf.getPerformanceTiming()).to.be.an(&apos;object&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">    it(&apos;返回耗时&apos;, function () &#123;</span><br><span class="line">        expect(perf.getPerformanceTiming().duration).to.be.an(&apos;number&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">    it(&apos;返回ttfb耗时&apos;, function () &#123;</span><br><span class="line">        expect(perf.getPerformanceTiming().ttfb).to.be.an(&apos;number&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">    it(&apos;返回requestTime耗时&apos;, function () &#123;</span><br><span class="line">        expect(perf.getPerformanceTiming().requestTime).to.be.an(&apos;number&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>运行<code>node ./node_modules/mocha/bin/mocha</code>，效果如下图：</p>
<p><img src="https://github.com/Tiffanysbear/accumulation/raw/master/image/npm-3.png" alt></p>
<p>需要注意的是，本地node版本太低可能会导致mocha会有报错，这时候采用 nvm 升级一下node版本，再次运行就行。</p>
<h4 id="4、增加Example"><a href="#4、增加Example" class="headerlink" title="4、增加Example"></a>4、增加Example</h4><p>增加example文件夹，里面可以通过对这个包的使用，增加一些Demo案例，让别人能更好的知道怎么使用这个库。</p>
<h4 id="5、完善README-md"><a href="#5、完善README-md" class="headerlink" title="5、完善README.md"></a>5、完善README.md</h4><p>在项目文件中增加README.md，提供使用方法、demo、注意事项等信息，方便别人使用，更容易让人明白。</p>
<p>可以看下在 <code>page-performance-monitor</code> 这个库中，我这边写的README.md，<a href="https://github.com/Tiffanysbear/page-performance-monitor">点击链接可查看</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面的步骤就是如何从0到1封装的一个npm包，可以封装一个简单的适于业务快速开发的，也可以封装一个高质量封装一起使用；可以根据自己的业务需求、时间成本等自行选择。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>页面性能监测之performance</title>
    <url>/2019/08/14/%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E7%9B%91%E6%B5%8B%E4%B9%8Bperformance/</url>
    <content><![CDATA[<blockquote>
<p>页面性能监测之performance<br>author: <a href="https://tiffanysbear.github.io/" target="_blank" rel="noopener">@TiffanysBear</a></p>
</blockquote>
<p>最近，需要对业务上的一些性能做一些优化，比如降低首屏时间、减少核心按钮可操作时间等的一些操作；在这之前，需要建立的就是数据监控的准线，也就是说一开始的页面首屏数据是怎样的，优化之后的数据是怎样，需要有一个对比效果。此时，performance 这个API就非常合适了。</p>
<h3 id="performance"><a href="#performance" class="headerlink" title="performance"></a>performance</h3><blockquote>
<p>Performance 接口可以获取到当前页面中与性能相关的信息。它是 High Resolution Time API 的一部分，同时也融合了 Performance Timeline API、Navigation Timing API、 User Timing API 和 Resource Timing API。</p>
</blockquote>
<blockquote>
<p>该类型的对象可以通过调用只读属性 Window.performance 来获得。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance" target="_blank" rel="noopener">参考链接</a> <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Performance</a></p>
</blockquote>
<h3 id="performance-timing对象"><a href="#performance-timing对象" class="headerlink" title="performance.timing对象"></a>performance.timing对象</h3><p>performance对象是全局的，它的timing属性是一个对象，它包含了各种与浏览器性能有关的时间数据，提供浏览器处理网页各个阶段的耗时。偷一个图~<br><img src="https://github.com/Tiffanysbear/accumulation/raw/master/image/perf-1.png" alt></p>
<p>performance.timing对象包含下列属性（全部只读）：</p>
<ul>
<li><p>navigationStart：当前浏览器窗口的前一个网页关闭，发生unload事件时的Unix毫秒时间戳。如果没有前一个网页，则等于fetchStart属性。</p>
</li>
<li><p>unloadEventStart：如果前一个网页与当前网页属于同一个域名，则返回前一个网页的unload事件发生时的Unix毫秒时间戳。如果没有前一个网页，或者之前的网页跳转不是在同一个域名内，则返回值为0。</p>
</li>
<li><p>unloadEventEnd：如果前一个网页与当前网页属于同一个域名，则返回前一个网页unload事件的回调函数结束时的Unix毫秒时间戳。如果没有前一个网页，或者之前的网页跳转不是在同一个域名内，则返回值为0。</p>
</li>
<li><p>redirectStart：返回第一个HTTP跳转开始时的Unix毫秒时间戳。如果没有跳转，或者不是同一个域名内部的跳转，则返回值为0。</p>
</li>
<li><p>redirectEnd：返回最后一个HTTP跳转结束时（即跳转回应的最后一个字节接受完成时）的Unix毫秒时间戳。如果没有跳转，或者不是同一个域名内部的跳转，则返回值为0。</p>
</li>
<li><p>fetchStart：返回浏览器准备使用HTTP请求读取文档时的Unix毫秒时间戳。该事件在网页查询本地缓存之前发生。</p>
</li>
<li><p>domainLookupStart：返回域名查询开始时的Unix毫秒时间戳。如果使用持久连接，或者信息是从本地缓存获取的，则返回值等同于fetchStart属性的值。</p>
</li>
<li><p>domainLookupEnd：返回域名查询结束时的Unix毫秒时间戳。如果使用持久连接，或者信息是从本地缓存获取的，则返回值等同于fetchStart属性的值。</p>
</li>
<li><p>connectStart：返回HTTP请求开始向服务器发送时的Unix毫秒时间戳。如果使用持久连接（persistent connection），则返回值等同于fetchStart属性的值。</p>
</li>
<li><p>connectEnd：返回浏览器与服务器之间的连接建立时的Unix毫秒时间戳。如果建立的是持久连接，则返回值等同于fetchStart属性的值。连接建立指的是所有握手和认证过程全部结束。</p>
</li>
<li><p>secureConnectionStart：返回浏览器与服务器开始安全链接的握手时的Unix毫秒时间戳。如果当前网页不要求安全连接，则返回0。</p>
</li>
<li><p>requestStart：返回浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的Unix毫秒时间戳。</p>
</li>
<li><p>responseStart：返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的Unix毫秒时间戳。</p>
</li>
<li><p>responseEnd：返回浏览器从服务器收到（或从本地缓存读取）最后一个字节时（如果在此之前HTTP连接已经关闭，则返回关闭时）的Unix毫秒时间戳。</p>
</li>
<li><p>domLoading：返回当前网页DOM结构开始解析时（即Document.readyState属性变为“loading”、相应的readystatechange事件触发时）的Unix毫秒时间戳。</p>
</li>
<li><p>domInteractive：返回当前网页DOM结构结束解析、开始加载内嵌资源时（即Document.readyState属性变为“interactive”、相应的readystatechange事件触发时）的Unix毫秒时间戳。</p>
</li>
<li><p>domContentLoadedEventStart：返回当前网页DOMContentLoaded事件发生时（即DOM结构解析完毕、所有脚本开始运行时）的Unix毫秒时间戳。</p>
</li>
<li><p>domContentLoadedEventEnd：返回当前网页所有需要执行的脚本执行完成时的Unix毫秒时间戳。</p>
</li>
<li><p>domComplete：返回当前网页DOM结构生成时（即Document.readyState属性变为“complete”，以及相应的readystatechange事件发生时）的Unix毫秒时间戳。</p>
</li>
<li><p>loadEventStart：返回当前网页load事件的回调函数开始时的Unix毫秒时间戳。如果该事件还没有发生，返回0。</p>
</li>
<li><p>loadEventEnd：返回当前网页load事件的回调函数运行结束时的Unix毫秒时间戳。如果该事件还没有发生，返回0。</p>
</li>
</ul>
<a id="more"></a>

<h3 id="performance-API"><a href="#performance-API" class="headerlink" title="performance API"></a>performance API</h3><h4 id="1、performance-now"><a href="#1、performance-now" class="headerlink" title="1、performance.now()"></a>1、performance.now()</h4><p>performance.now()方法返回当前网页自从performance.timing.navigationStart到当前时间之间的毫秒数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">performance.now()</span><br><span class="line"></span><br><span class="line">// Date.now() 近似等于 (performance.timing.navigationStart + performance.now())</span><br></pre></td></tr></table></figure>

<h4 id="2、performance-mark"><a href="#2、performance-mark" class="headerlink" title="2、performance.mark()"></a>2、performance.mark()</h4><p>该方法是做一个标记mark，结合measures方法，可以计算两个标记之间间隔的时间差；因此可以直接依据业务上的不同，计算两个业务逻辑之间的距离。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 以一个标志开始。</span><br><span class="line">performance.mark(&apos;mySetTimeout-start&apos;);</span><br><span class="line"></span><br><span class="line">// 等待一些时间。</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  // 标志时间的结束。</span><br><span class="line">  performance.mark(&apos;mySetTimeout-end&apos;);</span><br><span class="line"></span><br><span class="line">  // 测量两个不同的标志。</span><br><span class="line">  performance.measure(</span><br><span class="line">    &apos;mySetTimeout&apos;,</span><br><span class="line">    &apos;mySetTimeout-start&apos;,</span><br><span class="line">    &apos;mySetTimeout-end&apos;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  // 获取所有的测量输出。</span><br><span class="line">  // 在这个例子中只有一个。</span><br><span class="line">  var measures = performance.getEntriesByName(&apos;mySetTimeout&apos;);</span><br><span class="line">  var measure = measures[0];</span><br><span class="line">  console.log(&apos;setTimeout milliseconds:&apos;, measure.duration)</span><br><span class="line"></span><br><span class="line">  // 清除存储的标志位</span><br><span class="line">  performance.clearMarks();</span><br><span class="line">  performance.clearMeasures();</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>

<h4 id="3、performance-getEntries"><a href="#3、performance-getEntries" class="headerlink" title="3、performance.getEntries()"></a>3、performance.getEntries()</h4><p>浏览器获取网页时，会对网页中每一个对象（脚本文件、样式表、图片文件等等）发出一个HTTP请求。performance.getEntries方法以数组形式，返回这些请求的时间统计信息，有多少个请求，返回数组就会有多少个成员。</p>
<p>由于该方法与浏览器处理网页的过程相关，所以只能在浏览器中使用。</p>
<p><img src="https://github.com/Tiffanysbear/accumulation/raw/master/image/perf-0.png" alt></p>
<h4 id="4、performance-navigation对象"><a href="#4、performance-navigation对象" class="headerlink" title="4、performance.navigation对象"></a>4、performance.navigation对象</h4><p>（1）performance.navigation.type: 该属性返回一个整数值，表示网页的加载来源</p>
<blockquote>
<p>0：网页通过点击链接、地址栏输入、表单提交、脚本操作等方式加载，相当于常数performance.navigation.TYPE_NAVIGATENEXT。</p>
</blockquote>
<blockquote>
<p>1：网页通过“重新加载”按钮或者location.reload()方法加载，相当于常数performance.navigation.TYPE_RELOAD。</p>
</blockquote>
<blockquote>
<p>2：网页通过“前进”或“后退”按钮加载，相当于常数performance.navigation.TYPE_BACK_FORWARD。</p>
</blockquote>
<blockquote>
<p>255：任何其他来源的加载，相当于常数performance.navigation.TYPE_UNDEFINED。</p>
</blockquote>
<p>（2）performance.navigation.redirectCount: 该属性表示当前网页经过了多少次重定向跳转。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>因此根据图上的解释，封装了一个计算页面性能监控的基于performance的函数，用于返回性能数据。<br>可以根据自己的需求，在适合的时机执行函数，得到你需要的间隔时间duration。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @file: performance.js</span><br><span class="line"> * @author: Tiffany</span><br><span class="line"> * @description: 页面性能统计</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var getPerformanceTiming = function () &#123;</span><br><span class="line">    var performance = window.performance;</span><br><span class="line"></span><br><span class="line">    if (!performance) &#123;</span><br><span class="line">        // 当前浏览器不支持 performance</span><br><span class="line">        return &#123;msg: &apos;not suport performance&apos;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    var t = performance.timing || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    var ns = t.navigationStart;</span><br><span class="line">    var times = &#123;</span><br><span class="line">        // 间隔时间浏览器打开页面的耗时，</span><br><span class="line">        // 在首屏时间点执行这段函数呢，那就是首屏的耗时；</span><br><span class="line">        // 可以根据自己的业务需求，进行执行</span><br><span class="line">        duration: new Date().getTime() - ns,</span><br><span class="line">        // 页面渲染出第一个字符的耗时</span><br><span class="line">        ttfb: t.responseStart - ns,</span><br><span class="line">        // 响应结束到开始请求的时间，</span><br><span class="line">        // 可以参考静态资源的加载时间是否过长，是否能有优化的时间点</span><br><span class="line">        requestTime: t.responseEnd - t.requestStart</span><br><span class="line">    &#125;;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">    return times;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    getPerformanceTiming: getPerformanceTiming</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>性能监控</tag>
      </tags>
  </entry>
  <entry>
    <title>一些值得思考的前端面试题</title>
    <url>/2019/08/08/%E4%B8%80%E4%BA%9B%E5%80%BC%E5%BE%97%E6%80%9D%E8%80%83%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>一些值得思考的前端面试题<br>还在继续补充中……<br>author: <a href="https://tiffanysbear.github.io/" target="_blank" rel="noopener">@TiffanysBear</a></p>
</blockquote>
<h3 id="ALL"><a href="#ALL" class="headerlink" title="ALL"></a>ALL</h3><ol>
<li><p>在nodejs开发的时候 处理过什么windows和mac的平台兼容性问题</p>
<ul>
<li>兼容环境变量设置</li>
<li>windows不支持 &amp; ,并行执行npm-script用npm-run-all或者concurrently</li>
<li>异步同步化:util.promisify + async/await</li>
<li>fs.readFileSync，用fs-extra去代替</li>
<li>拼接路径要用path.join，Unix系是/，Windows是\</li>
<li>……</li>
</ul>
</li>
<li><p>设计一个方案，在浏览器中点击一个button，然后能在你的前端项目源码文件中增加一个index.js文件，如何实现？提供思路</p>
</li>
<li><p>用nodejs，将base64转化成png文件，或者将png文件转化为base64</p>
</li>
<li><p>如果你用nodejs实现的爬虫服务器的IP被指定网站封了，如何解封？</p>
</li>
<li><p>请设计一个方案：有a、b、c三个npm插件，它们会经常更新，在前端项目npm run start启动后，要求a、b、c三个npm插件自动更新到最新版本</p>
</li>
<li><p>大文件转存问题：服务器A有一个1000G的文件， 需要通过服务端B转发到服务端C，但是服务器B内存只有1个g， 怎么去实现这个大文件转存</p>
</li>
<li><p>如何劫持https的请求，提供思路</p>
</li>
<li><p>前端如何进行seo优化; 前后端分离的项目如何seo</p>
</li>
<li><p>简单实现async/await中的async函数</p>
</li>
<li><p>1000-div问题：一次性插入1000个div。</p>
<ul>
<li>使用Fragment</li>
<li>向1000个并排的div元素中，插入一个平级的div元素，如何优化插入的性能；先 display: none 然后插入 再 display: block ；赋予key，然后使用virtual-dom，先render，然后diff，最后patch；脱离文档流，用GPU去渲染，开启硬件加速；</li>
</ul>
</li>
<li><p>2万小球问题：在浏览器端，用js存储2万个小球的信息，包含小球的大小，位置，颜色等，如何做到对这2万条小球信息进行最优检索和存储</p>
<ul>
<li>用ArrayBuffer实现极致存储</li>
<li>哈夫曼编码 + 字典查询树实现更优索引</li>
<li>用bit-map实现大数据筛查</li>
<li>用hash索引实现简单快捷的检索</li>
<li>用IndexedDB实现动态存储扩充浏览器端虚拟容量</li>
<li>用iframe的漏洞实现浏览器端localStorage无限存储，实现2千万小球信息存储</li>
</ul>
</li>
<li><p>http的状态码中，499是什么？如何出现499，如何排查跟解决</p>
<ul>
<li>499对应的是 “client has closed connection”，客户端请求等待链接已经关闭，这很有可能是因为服务器端处理的时间过长，客户端等得“不耐烦”了。还有一种原因是两次提交post过快就会出现499。<br>解决方法：1、前端将timeout最大等待时间设置大一些；2、nginx上配置<code>proxy_ignore_client_abort on</code>;</li>
</ul>
</li>
<li><p>如何遍历一个dom树</p>
</li>
<li><p>new操作符都做了什么</p>
<ul>
<li>创建一个空对象，并且 this 变量引用该对象，// lat target = {};</li>
<li>继承了函数的原型。// target.proto = func.prototype;</li>
<li>属性和方法被加入到 this 引用的对象中。并执行了该函数func// func.call(target);</li>
<li>新创建的对象由 this 所引用，并且最后隐式的返回 this 。// 如果func.call(target)返回的res是个对象或者function 就返回它</li>
</ul>
</li>
</ol>
<ol start="15">
<li>请设计一个攻击服务器的策略;伪造虚假npm包 + nodejs版本的payload, nodejs的反序列化攻击</li>
<li>请写一个正则，去除掉html标签字符串里的所有属性，并保留src和href两种属性。<a href="https://github.com/airuikun/Weekly-FE-Interview/issues/24">答案</a></li>
<li>十万条数据插入数据库，怎么去优化和处理高并发情况下的DB插入。<a href="https://github.com/airuikun/Weekly-FE-Interview/issues/26">想法</a></li>
<li>一个iframe，内嵌了一个A页面，iframe的宽高不停变化，如何让A页面的宽高实时自适应这个iframe的宽高大小。请说出至少3种方法</li>
<li>v8有了解过吗？讲讲了解过v8的那几个模块和部分</li>
<li>现在有多个spa的项目，有angular的，有vue的和react的，如何将他们合并成一个大统一的spa项目。<a href="https://github.com/hubvue/Micro-FE">提示</a></li>
</ol>
<h3 id="项目相关"><a href="#项目相关" class="headerlink" title="项目相关"></a>项目相关</h3><ol>
<li>怎么实现页面性能监控，首屏时间计算等</li>
<li>怎么实现一个JS错误监控</li>
</ol>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><ol>
<li>Http请求中的keep-alive有了解吗？</li>
<li>http的状态码中，499是什么？如何出现499，如何排查跟解决</li>
<li>http三次握手四次挥手，可以优化吗？</li>
<li>什么是断点续传？怎么实现？</li>
<li>http 2.0 有什么特点，相比于 1.1 多了哪些优化？</li>
<li>http中的对称加密和非对称加密</li>
<li>浏览器缓存机制</li>
<li>浏览器建立长连接</li>
<li>http状态码206</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ol>
<li>手写代码，简单实现call</li>
<li>手写代码，简单实现apply</li>
<li>手写代码，简单实现bind</li>
<li>简单手写实现promise、promise.all</li>
<li>实现一个Lazyman</li>
<li>用JS代码求出页面上一个元素的最终的background-color，不考虑IE浏览器，不考虑元素float情况。</li>
<li>实现一个 axios 的 timeout 方法</li>
<li>实现一个 render 方法进行模板字符串替换</li>
<li>实现一个new，说一说new执行了哪些操作</li>
<li>发布订阅模式</li>
<li>实现一个简单的Vue</li>
</ol>
<h3 id="HTML-amp-CSS"><a href="#HTML-amp-CSS" class="headerlink" title="HTML &amp; CSS"></a>HTML &amp; CSS</h3><ol>
<li>bootstrap是怎么实现grid系统</li>
<li>BFC：清除浮动、margin重叠</li>
<li>两列等高布局的实现</li>
</ol>
<h3 id="源码相关"><a href="#源码相关" class="headerlink" title="源码相关"></a>源码相关</h3><ol>
<li>Jquery的源代码怎么进行Object的深复制</li>
</ol>
<h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><ol>
<li>vue 中的一个 tick 是什么，node 中的 tick 呢</li>
<li>vue 自定义指令</li>
<li>vue 编译后是什么，runtime 的作用</li>
<li>keep-alive</li>
</ol>
<h3 id="打包相关"><a href="#打包相关" class="headerlink" title="打包相关"></a>打包相关</h3><ol>
<li>webpack常见使用</li>
<li>fis、webpack等打包插件的原理</li>
<li>webpack一些常用的使用功能：提取公共部分、代码分割和按需加载、treeShaking、webpack-dev-server等的一些使用</li>
</ol>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>支持分享的在线代码编辑器推荐</title>
    <url>/2019/08/05/%E6%94%AF%E6%8C%81%E5%88%86%E4%BA%AB%E7%9A%84%E5%9C%A8%E7%BA%BF%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<blockquote>
<p>支持分享的在线代码编辑器推荐<br>author: <a href="https://tiffanysbear.github.io/" target="_blank" rel="noopener">@TiffanysBear</a></p>
</blockquote>
<p>博客中往往加一些在线代码编辑器进行代码DEMO的展示，往往有很好的效果。<br>下面就推荐几款支持分享的在线代码编辑器。</p>
<h3 id="JSFiddle"><a href="#JSFiddle" class="headerlink" title="JSFiddle"></a>JSFiddle</h3><p><a href="https://jsfiddle.net/" target="_blank" rel="noopener">https://jsfiddle.net/</a></p>
<p>国内访问慢或资源加载不了，建议使用代理。</p>
<p>高级特性：</p>
<ul>
<li>支持从预置模板生成代码集，快速开始</li>
<li>支持实时合作</li>
<li>支持页面嵌入，可设置黑白主题色或自定义颜色</li>
<li>每次保存都会产生历史版本</li>
<li>CSS支持SCSS，样式重置可选择使用Normalize.css</li>
<li>JS支持CoffeeScript，Babel JSX，Type Script，Vue，React，Preact</li>
<li>JS内置可选的常用框架与扩展，可定义加载时机，设置<code>&lt;script&gt;</code>标签属性attribute</li>
<li>外链支持从CDNJS搜索名称来加入对应资源</li>
<li>支持模拟异步请求</li>
<li>可设置界面布局、代码提示（beta）、自动运行、自动保存、高亮匹配标签、快捷键映射方案（Sublime、vim、Emacs）</li>
</ul>
<a id="more"></a>

<h3 id="JS-Bin"><a href="#JS-Bin" class="headerlink" title="JS Bin"></a>JS Bin</h3><p><a href="http://jsbin.com/" target="_blank" rel="noopener">http://jsbin.com/</a></p>
<p>高级特性：</p>
<ul>
<li>将代码集保存到GitHub Gist</li>
<li>将代码集保存为模板</li>
<li>自动保存，可设置自动运行</li>
<li>可打开单独窗口运行代码集</li>
<li>ctrl+s保存快照，相当于历史版本，通过Open bin…来选择</li>
<li>支持展示Console窗口</li>
<li>HTML支持Markdown，Jade，并提供转换为HTML功能</li>
<li>CSS支持Less，Myth，Sass，SCSS，Stylus，并提供转换为CSS功能</li>
<li>JS支持ES6 / Babel，JSX，CoffeeScript，Traceur，TypeScript，Processing，LiveScript，ClojureScript，并提供转换为原生JavaScript功能</li>
<li>JS内置可选的常用框架与扩展</li>
<li>支持页面嵌入，可选择快照还是最新版本，可选择编辑视图或只有结果界面</li>
<li>支持键盘快捷键，支持部分Sumlime快捷键</li>
</ul>
<p>升级为付费用户：</p>
<ul>
<li>上传本地资源</li>
<li>创建私有代码集</li>
<li>自定义嵌入样式</li>
<li>同步到Dropbox</li>
<li>个性域名</li>
</ul>
<h3 id="codepen"><a href="#codepen" class="headerlink" title="codepen"></a>codepen</h3><p><a href="https://codepen.io/" target="_blank" rel="noopener">https://codepen.io/</a></p>
<p>平台特色</p>
<ul>
<li>支持用markdown语法创建文章，文章可嵌入代码集</li>
<li>免费用户可创建1个项目，包含10个文件</li>
<li>支持创建专辑</li>
</ul>
<p>高级特性：</p>
<ul>
<li>将代码集保存为模板</li>
<li>将代码集保存到GitHub Gist</li>
<li>将代码集导出到zip包</li>
<li>可打开单独窗口运行代码</li>
<li>提供一些开箱即用的样式资源</li>
<li>可对代码集进行评论</li>
<li>可设置自动保存、自动运行</li>
<li>支持页面嵌入，可设置黑白主题色、点击后加载，升级付费用户后可设置代码可编辑</li>
<li>保存不产生历史版本，每次访问都是最新代码</li>
<li>HTML支持Haml，Markdown，Slim，Pug</li>
<li>CSS支持Less，PostCSS，Sass，SCSS，Stylus，样式重置可选择使用Normalize.css，Reset.css，前缀生成可选择Autoprefixer，Prefixfree</li>
<li>JS支持Babel，TypeScript，CoffeeScript，LiveScript</li>
<li>支持键盘快捷键</li>
</ul>
<p>升级为付费用户/团队：</p>
<ul>
<li>创建私有代码集</li>
<li>自定义嵌入主题样式</li>
<li>更多项目更多文件</li>
<li>项目可部署</li>
<li>合作模式</li>
<li>专家模式</li>
<li>资源文件托管</li>
</ul>
<h3 id="codesandbox"><a href="#codesandbox" class="headerlink" title="codesandbox"></a>codesandbox</h3><p><a href="https://codesandbox.io/" target="_blank" rel="noopener">https://codesandbox.io/</a></p>
<p>codesandbox更新像是在线IDE，可配置首选项，与GitHub、ZEIT集成，以项目为单位，免费用户可创建50个项目。</p>
<p>高级特性：</p>
<ul>
<li>支持从预置模板生成项目，快速开始</li>
<li>支持添加npm依赖包</li>
<li>支持上传文件</li>
<li>支持编写配置文件package.json，.babelrc，.prettierrc，sandbox.config.json</li>
<li>支持实时合作</li>
<li>将项目导出到zip包</li>
<li>可打开单独窗口运行代码</li>
<li>支持项目分享</li>
<li>保存不产生历史版本，每次访问都是最新代码</li>
</ul>
<p>升级为付费用户：</p>
<ul>
<li>团队权限限制解除</li>
<li>创建私有代码集</li>
<li>无限量代码集</li>
<li>静态文件托管从免费20Mb增加到500Mb</li>
<li>codepen 只能分享最新代码，要比较代码变更情况，需要先Fork再编辑。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>codesandbox 接近一个完整的IDE，功能强大，可创建公开的多文件项目，适合用在各种框架配置教程中。</p>
<p>JSFiddle、JS Bin 更适合用于在线分享、学习、制作demo、测试代码。</p>
<p>JS Bin 支持代码下载，保存到Gist。</p>
<p>JSFiddle 提供了一些开箱即用的功能，无需复杂的配置，支持代码提示。</p>
]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Computer Skills</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常见用法和问题</title>
    <url>/2019/08/05/Git%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E5%92%8C%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>Git常见用法和问题<br>author: <a href="https://tiffanysbear.github.io/" target="_blank" rel="noopener">@TiffanysBear</a></p>
</blockquote>
<p>现在git已经成为各个大厂代码管理的基本工具了，相信对于常用的一些git操作指令已经很熟悉了，先讲一些常见的使用吧。<br>首先是了解下git的概念，工作区、暂存区、远程仓库。</p>
<p><img src="https://github.com/Tiffanysbear/accumulation/raw/master/image/git-demo.png" alt></p>
<h3 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h3><p>1、将计划改动加入到缓存区<br>增加某个文件：<code>git add &lt;filename&gt;</code><br>增加全部文件：<code>git add .</code></p>
<p>2、提交commit<br><code>git commit -m &#39;comment message&#39;</code></p>
<p>3、推送改动<br><code>git push origin master</code></p>
<p>4、分支相关操作<br>切分支：<code>git checkout -b &lt;branch-name&gt;</code><br>切回master分支：<code>git checkout master</code></p>
<p>5、合并更新<br>本地同步： <code>git pull</code><br>合并：<code>git merge &lt;branch&gt;</code><br>查看改动文件: <code>git diff &lt;source_branch&gt; &lt;target_branch&gt;</code></p>
<p>6、标签<br>创建标签：<code>git tag 1.0.0 &lt;commit_id&gt;</code> , 其中commit_id是通过 <code>git log</code> 获取的。</p>
<h3 id="问题及解决"><a href="#问题及解决" class="headerlink" title="问题及解决"></a>问题及解决</h3><p>1、从工作区撤销<br>当看到自己的改动并不是自己想要修改时，且从未加入过暂存区，使用 <code>git checkout -- &lt;filename&gt;</code>, 撤销自己的改动。</p>
<p>2、从暂存区撤销<br>如果自己已经操作过 <code>git add &lt;filename&gt;</code>，需要从暂存区撤销，使用 <code>git reset HEAD &lt;file&gt;...</code> 对文件进行撤销回工作区</p>
<p>3、出现冲突conflict<br>当执行 <code>git merge</code> 操作时，可能会出现冲突，通过去代码中将冲突部分修改之后，再进行提交即可。</p>
<a id="more"></a>

<h3 id="稍微高级的用法"><a href="#稍微高级的用法" class="headerlink" title="稍微高级的用法"></a>稍微高级的用法</h3><h4 id="git-rebase-变基"><a href="#git-rebase-变基" class="headerlink" title="git rebase 变基"></a>git rebase 变基</h4><p>1、<code>git rebase</code>和<code>git merge</code>操作都是用来进行分支合并的，可以通过git rebase将一个分支变基到master分支。</p>
<p><code>git fetch origin</code><br><code>git rebase origin/your_branch_name</code></p>
<p>如果有冲突的话，就进行冲突修改的操作：<br><code>git add -u</code><br><code>git rebase --continue</code></p>
<p>或者<br><code>git rebase --abort</code> 取消变基操作，并将分支切回git rebase 之前的状态。</p>
<p>或者<br><code>git rebase --skip</code> 忽略该提交，这样有问题的提交所引入的变化就不会被添加到历史中。</p>
<p>最后进行push操作就行。</p>
<h4 id="git-stash-保存临时修改"><a href="#git-stash-保存临时修改" class="headerlink" title="git stash 保存临时修改"></a>git stash 保存临时修改</h4><p>工作时，有时候在某个分支上还在修改，并不想<code>commit</code>，但是就必须要切换分支；这时候，git不会让你切换分支，会提示你还有尚未保存的修改；这时候，使用 <code>git stash</code> 就会将其保存到未完成的修改栈中，暂存你的工作状态。</p>
<p><code>git stash</code> 这样的话，工作目录就是干净的，就可以自由的切换分支；<br><code>git stash save &#39;describe message&#39;</code> 暂存并添加描述信息<br><code>git stash clear</code> 清除所有的stash信息<br><code>git stash list</code> 查看暂存的所有变更<br><code>git stash pop</code> 将最近一次的暂存弹出</p>
<p>如果不小心将自己的git stash的内容全部删除的话，需要采用下面的步骤进行恢复：</p>
<p>1、<code>git fsck --lost-found</code> 首先可以通过这个命令，查找删除的记录</p>
<p><img src="https://github.com/Tiffanysbear/accumulation/raw/master/image/git-2.png" alt></p>
<p>stash信息中相对的是，dangling commit相关的提交信息;</p>
<p>或者使用命令： <code>git log --graph --oneline --decorate  $( git fsck --no-reflog | awk &#39;/dangling commit/ {print $3}&#39; )</code></p>
<p><img src="https://github.com/Tiffanysbear/accumulation/raw/master/image/git-3.png" alt></p>
<p>图表化会看得更清楚些。</p>
<p>2、<code>git show &lt;id&gt;</code> 可以查看该id下面具体内容，可以看到进行改动的代码。</p>
<p>3、使用 <code>git merge &lt;id&gt;</code> 或者 <code>git stash apply &lt;id&gt;</code>  恢复删除的代码。</p>
<h4 id="或者使用另外一个办法："><a href="#或者使用另外一个办法：" class="headerlink" title="或者使用另外一个办法："></a>或者使用另外一个办法：</h4><ul>
<li>git reflog 可以查看所有分支的所有操作记录（包括已经被删除的 commit 记录和 reset 的操作);例如执行 git reset –hard HEAD~1，退回到上一个版本，用git log则是看不出来被删除的commitid，用git reflog则可以看到被删除的commitid。</li>
<li>git log -g 找到最近一次提交的commit记录,并记下commit id</li>
<li>git branch newbranch commit_id，生成一个newbranch新分支，切到newbranch分支</li>
</ul>
<h4 id="克隆某条特定远程分支"><a href="#克隆某条特定远程分支" class="headerlink" title="克隆某条特定远程分支"></a>克隆某条特定远程分支</h4><p><code>git remote add -t -f origin</code></p>
<h4 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h4><p>如果只想将远程仓库中一个特定的提交合并到自己分支中，使用 <code>git cherry-pick</code> 选择指定的 SHA 值的提交，然后将其合并到当前分支中。</p>
<h4 id="应用来自于不相关的本地仓库补丁"><a href="#应用来自于不相关的本地仓库补丁" class="headerlink" title="应用来自于不相关的本地仓库补丁"></a>应用来自于不相关的本地仓库补丁</h4><p>如果需要将另一个不相关的本地仓库的提交补丁应用到当前仓库，使用：<br><code>git --git-dir=/.git format-patch -k -1 --stdout  | git am -3 -k</code></p>
<h4 id="忽略某个文件的变更"><a href="#忽略某个文件的变更" class="headerlink" title="忽略某个文件的变更"></a>忽略某个文件的变更</h4><p>对于某些环境相关的配置文件，可能每次环境变化都不同，但是每次合并都需要修改；下面这个命令可以永久性告诉git不要管某个本地文件。</p>
<p><code>git update-index --assume-unchanged</code></p>
<h4 id="清理"><a href="#清理" class="headerlink" title="清理"></a>清理</h4><p>Git提示 “untracked working tree files” 会 “overwritten by checkout”。需要通过清理来使工作树保持整洁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clean -f     # remove untracked files</span><br><span class="line">git clean -fd    # remove untracked files/directories</span><br><span class="line">git clean -nfd   # list all files/directories that would be removed</span><br></pre></td></tr></table></figure>

<h4 id="将项目文件打成-tar-包，并且排除-git-目录"><a href="#将项目文件打成-tar-包，并且排除-git-目录" class="headerlink" title="将项目文件打成 tar 包，并且排除 .git 目录"></a>将项目文件打成 tar 包，并且排除 .git 目录</h4><p>使用tar、zip来打包项目文件时，需要剔除.git目录：</p>
<p><code>tar cJf .tar.xz / --exclude-vcs</code></p>
<h4 id="安装-git-blame-相关插件"><a href="#安装-git-blame-相关插件" class="headerlink" title="安装 git blame 相关插件"></a>安装 git blame 相关插件</h4><p>如果使用的是 VSCode 的话，可以安装 git blame 这个插件，可以找到每一行代码的作者。</p>
]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Computer Skills</tag>
      </tags>
  </entry>
  <entry>
    <title>两年工作有感</title>
    <url>/2019/08/05/%E4%B8%A4%E5%B9%B4%E5%B7%A5%E4%BD%9C%E6%9C%89%E6%84%9F/</url>
    <content><![CDATA[<blockquote>
<p>两年工作有感<br>author: <a href="https://tiffanysbear.github.io/" target="_blank" rel="noopener">@TiffanysBear</a></p>
</blockquote>
<p>换工作感受：</p>
<ul>
<li>持续学习，终身学习</li>
<li>人要多学习思考，深度思考，学会接纳</li>
<li>做事做到极致，保持高标准</li>
<li>做完了不等于做好了</li>
<li>自驱，延迟满足感</li>
<li>需要了解一些后端</li>
</ul>
<p>技术栈感受：</p>
<ul>
<li>思考的方面不同，角度不同</li>
<li>引入状态管理之后带来的思维变化</li>
<li>搭建项目工作流</li>
<li></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>实现一个hoverDelay延迟hover</title>
    <url>/2019/07/30/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAhoverDelay%E5%BB%B6%E8%BF%9Fhover/</url>
    <content><![CDATA[<blockquote>
<p>实现一个hoverDelay延迟hover<br>author: <a href="https://tiffanysbear.github.io/" target="_blank" rel="noopener">@TiffanysBear</a></p>
</blockquote>
<h3 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h3><p>经常在页面开发中，需要使用hover事件来触发相应的网络请求或页面DOM元素显示切换，需要考虑的问题就有了：</p>
<ul>
<li>hover动作非常快，如果一hover就请求，会造成多余请求的浪费，造成后端接口不必要的压力</li>
<li>如何判断这个用户hover是想做一定的操作，而不是鼠标误触</li>
<li>构造这个hover延迟的时候，怎样封装才能通用使用</li>
</ul>
<p>先来看一下效果演示：</p>
<iframe height="257" style="width: 100%;" scrolling="no" title="Vue.js | Mouseover &amp; Mouseleave" src="//codepen.io/AAA_TTT/embed/VorrpN/?height=257&theme-id=0&default-tab=result" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/AAA_TTT/pen/VorrpN/" target="_blank" rel="noopener">Vue.js | Mouseover &amp; Mouseleave</a> by AAA_TTT
  (<a href="https://codepen.io/AAA_TTT" target="_blank" rel="noopener">@AAA_TTT</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.
</iframe>

<h3 id="问题思考"><a href="#问题思考" class="headerlink" title="问题思考"></a>问题思考</h3><p>基于上述的问题，思考是如下：</p>
<ul>
<li>当用户hover停留在某一DOM元素上一定时长时，比如500ms，才认为这个用户是实际想要做某种操作，这时候在实际的进行相应的网络请求或页面DOM元素显示切换</li>
<li>如果在500ms之前就移开，就算是用户误触误滑，不做任何处理</li>
<li>构造hover通用封装时，采用jQuery的插件开发的方式，形成通用的解决方案</li>
</ul>
<a id="more"></a>

<h3 id="代码封装"><a href="#代码封装" class="headerlink" title="代码封装"></a>代码封装</h3><p>基于jQuery的插件系统，实现的hoverDelay插件方法；在每次事件之前，清空所有的计时器，重新设置延时定时器，则进行相应操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @file: 鼠标滑动延迟执行的JQUERY扩展方法</span><br><span class="line"> * @author: TiffanysBear</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">$.fn.hoverDelay = function (options) &#123;</span><br><span class="line">    var defaults = &#123;</span><br><span class="line">        hoverDuring: 200,</span><br><span class="line">        outDuring: 200,</span><br><span class="line">        hoverEvent: function () &#123;</span><br><span class="line">            $.noop();</span><br><span class="line">        &#125;,</span><br><span class="line">        outEvent: function () &#123;</span><br><span class="line">            $.noop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    var sets = $.extend(defaults, options || &#123;&#125;);</span><br><span class="line">    var hoverTimer;</span><br><span class="line">    var outTimer;</span><br><span class="line">    return $(this).each(function () &#123;</span><br><span class="line">        $(this).hover(function () &#123;</span><br><span class="line">            clearTimeout(outTimer);</span><br><span class="line">            hoverTimer = setTimeout(sets.hoverEvent, sets.hoverDuring);</span><br><span class="line">        &#125;, function () &#123;</span><br><span class="line">            clearTimeout(hoverTimer);</span><br><span class="line">            outTimer = setTimeout(sets.outEvent, sets.outDuring);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="代码使用"><a href="#代码使用" class="headerlink" title="代码使用"></a>代码使用</h3><p>因为该方法是放在jQuery的原型方法上，因此所有jQuery对象都有这个方法可以使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(this).hoverDelay(&#123;</span><br><span class="line">    hoverDuring: 500,</span><br><span class="line">    outDuring: 300,</span><br><span class="line">    hoverEvent: function () &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;,</span><br><span class="line">    outEvent: function () &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="后续思考"><a href="#后续思考" class="headerlink" title="后续思考"></a>后续思考</h3><p>类似与Vue这种类似于MVVM框架的项目应该如何做hoverDelay呢？原理也是一致的；但是在细节的处理上有些不同，通过Vue绑定的 <code>mouseover</code>、<code>mouseleave</code>对定时器进行设置和清理也能实现需求。</p>
<p>html结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&lt;div id=&quot;mouse&quot;&gt;</span><br><span class="line">  &lt;a</span><br><span class="line">    v-on:mouseover=&quot;mouseover&quot;</span><br><span class="line">    v-on:mouseleave=&quot;mouseleave&quot;&gt;</span><br><span class="line">    &#123;&#123;message&#125;&#125;</span><br><span class="line">  &lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>css样式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  </span><br><span class="line">  background: #333;</span><br><span class="line">  </span><br><span class="line">  #mouse &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    transform: translate(-50%, -50%);</span><br><span class="line">    display: block;</span><br><span class="line">    width: 280px;</span><br><span class="line">    height: 50px;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">    line-height: 50px;</span><br><span class="line">    text-align: center;</span><br><span class="line">    color: #fff;</span><br><span class="line">    background: #007db9;</span><br><span class="line"></span><br><span class="line">    a &#123;</span><br><span class="line">      display: block;</span><br><span class="line">      width: 100%;</span><br><span class="line">      height: 100%;</span><br><span class="line">      cursor: pointer;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JS代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#mouse&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &apos;Hover Me!&apos; ,</span><br><span class="line">    timer: null,</span><br><span class="line">    hoverEnterTime: 500,</span><br><span class="line">    hoverLeaveTime: 300</span><br><span class="line">  &#125;, </span><br><span class="line">  methods: &#123;</span><br><span class="line">    mouseover: function()&#123;</span><br><span class="line">      clearTimeout(this.timer);</span><br><span class="line">      this.timer = setTimeout(() =&gt; &#123;</span><br><span class="line">        this.message = &apos;Good!&apos;</span><br><span class="line">      &#125;, this.hoverEnterTime);</span><br><span class="line">    &#125;,    </span><br><span class="line">    mouseleave: function()&#123;</span><br><span class="line">      clearTimeout(this.timer);</span><br><span class="line">      this.timer = setTimeout(() =&gt; &#123;</span><br><span class="line">        this.message = &apos;Hover Me!!&apos;</span><br><span class="line">      &#125;, this.hoverEnterTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><a href="https://codepen.io/AAA_TTT/pen/BXmwVg" target="_blank" rel="noopener">代码效果和功能演示</a>：</p>
<iframe height="265" style="width: 100%;" scrolling="no" title="Vue.js | Mouseover &amp; Mouseleave" src="https://codepen.io/AAA_TTT/embed/VorrpN/?height=265&theme-id=0&default-tab=js" frameborder="no" allowtransparency="true" allowfullscreen="true">
  See the Pen <a href="https://codepen.io/AAA_TTT/pen/VorrpN/" target="_blank" rel="noopener">Vue.js | Mouseover &amp; Mouseleave</a> by AAA_TTT
  (<a href="https://codepen.io/AAA_TTT" target="_blank" rel="noopener">@AAA_TTT</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.
</iframe>









]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>问题收集和解决</tag>
      </tags>
  </entry>
  <entry>
    <title>如何知道iframe文件下载download完成</title>
    <url>/2019/07/30/%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93iframe%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BDdownload%E5%AE%8C%E6%88%90/</url>
    <content><![CDATA[<blockquote>
<p>如何知道iframe文件下载download完成<br>author: <a href="https://tiffanysbear.github.io/" target="_blank" rel="noopener">@TiffanysBear</a></p>
</blockquote>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>当使用iframe作为文件下载的载体时，如何知道文件已经下载完毕。现有的iframe的onLoad方法具有兼容性问题，在chrome、IE下无法监听onLoad事件监听文件下载完毕，因为onLoad事件本身也是对iframe中的html结构的加载进度监听。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var url = &apos;http://www.example.com/file.zip&apos;;</span><br><span class="line">var iframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line">iframe.src = url;</span><br><span class="line">iframe.style.display = &apos;none&apos;;</span><br><span class="line">iframe.onload = function() &#123;</span><br><span class="line">    console.debug(&apos;start downloading...&apos;);</span><br><span class="line">    document.body.removeAttribute(iframe);</span><br><span class="line">&#125;</span><br><span class="line">document.body.appendChild(iframe);</span><br></pre></td></tr></table></figure>

<p>当chrome、IE下时，如果HTTP文件头中包含Content-disposition: attachment；即下载文件的链接的话，不会触发这个事件onLoad事件。</p>
<p>这里说一下Content-disposition：</p>
<blockquote>
<p>Content-disposition 是 MIME 协议的扩展，MIME 协议指示 MIME 用户代理如何显示附加的文件。Content-disposition其实可以控制用户请求所得的内容存为一个文件的时候提供一个默认的文件名，文件直接在浏览器上显示或者在访问时弹出文件下载对话框。<br>Content-Disposition为属性名disposition-type是以什么方式下载，如attachment为以附件方式下载disposition-parm为默认保存时的文件名服务端向客户端游览器发送文件时，如果是浏览器支持的文件类型，一般会默认使用浏览器打开，比如txt、jpg等，会直接在浏览器中显示</p>
<p>注意事项：<br>1.当代码里面使用Content-Disposition来确保浏览器弹出下载对话框的时候。 response.addHeader(‘Content-Disposition’, ‘attachment’);一定要确保没有做过关于禁止浏览器缓存的操作。<br>代码如下:<br>response.setHeader(‘Pragma’, ‘No-cache’);<br>response.setHeader(‘Cache-Control’, ‘No-cache’);<br>response.setDateHeader(‘Expires’, 0);<br>不然会发现下载功能在opera和firefox里面好好的没问题，在IE下面就是不行</p>
</blockquote>
<a id="more"></a>

<h3 id="解决思路一：利用cookie"><a href="#解决思路一：利用cookie" class="headerlink" title="解决思路一：利用cookie"></a>解决思路一：利用cookie</h3><p>后端将文件下载进度放在cookie中，通过轮询cookie的方式，对文件下载进度进行获取，判断文件是否已经下载完毕。<br>缺陷：<br>1、需要后端配合<br>2、如果客户端禁用了cookie，则该方案完全失效；在无痕浏览模式下，读取cookie，甚至代码报错。</p>
<h3 id="解决思路二：添加header配置"><a href="#解决思路二：添加header配置" class="headerlink" title="解决思路二：添加header配置"></a>解决思路二：添加header配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 不让浏览器自动检测文件类型</span><br><span class="line">// 说明资料：http://drops.wooyun.org/tips/1166</span><br><span class="line">response.addHeader(&apos;X-Content-Type-Options&apos;, &apos;nosniff&apos;);</span><br><span class="line">// 提示浏览器不让其在frame或iframe中加载资源的文件内容</span><br><span class="line">// https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options</span><br><span class="line">response.addHeader(&apos;X-Frame-Options&apos;, &apos;deny&apos;);</span><br></pre></td></tr></table></figure>

<p>但是在chorome v58版本将header的X-Frame-Options设为deny会报错。并且下载的时候网络连接会出现失败。</p>
<h3 id="解决思路三：轮询监听readyState"><a href="#解决思路三：轮询监听readyState" class="headerlink" title="解决思路三：轮询监听readyState"></a>解决思路三：轮询监听readyState</h3><p>定时器轮询监听readyState的状态，如果是 complete 或者 interactive 说明文件加载完成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var timer = setInterval(function () &#123;</span><br><span class="line">    iframe = document.getElementById(&apos;iframedownload&apos;);</span><br><span class="line">    var iframeDoc = iframe.contentDocument || iframe.contentWindow.document;</span><br><span class="line">    // Check if loading is complete</span><br><span class="line">    if (iframeDoc.readyState == &apos;complete&apos; || iframeDoc.readyState == &apos;interactive&apos;) &#123;</span><br><span class="line">        loadingOff();</span><br><span class="line">        clearInterval(timer);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, 4000);</span><br></pre></td></tr></table></figure>

<p>该种方法比较好，因为不需要后端进行配合，且不依赖与cookie等变量带来的问题，且能实现我们的需求。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>问题收集和解决</tag>
      </tags>
  </entry>
  <entry>
    <title>触发浏览器回流的属性方法一览表</title>
    <url>/2019/07/23/%E8%A7%A6%E5%8F%91%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9B%9E%E6%B5%81%E7%9A%84%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95%E4%B8%80%E8%A7%88%E8%A1%A8/</url>
    <content><![CDATA[<blockquote>
<p>【转】触发浏览器回流的属性方法一览表<br>转载自 奇舞周刊 何文力<br><a href="https://tiffanysbear.github.io/" target="_blank" rel="noopener">@TiffanysBear</a></p>
</blockquote>
<p>下列的所有属性、方法，在读取或执行的同时，将会导致浏览器同步地计算样式和布局。这种行为又叫做回流，也是常见的性能瓶颈。</p>
<h3 id="元素类"><a href="#元素类" class="headerlink" title="元素类"></a>元素类</h3><h4 id="元素测量"><a href="#元素测量" class="headerlink" title="元素测量"></a>元素测量</h4><p><code>elem.offsetLeft, elem.offsetTop, elem.offsetWidth, elem.offsetHeight, elem.offsetParent</code><br><code>elem.clientLeft, elem.clientTop, elem.clientWidth, elem.clientHeight
elem.getClientRects(), elem.getBoundingClientRect()</code></p>
<h4 id="滚动相关"><a href="#滚动相关" class="headerlink" title="滚动相关"></a>滚动相关</h4><p><code>elem.scrollBy(), elem.scrollTo()</code><br><code>elem.scrollIntoView(), elem.scrollIntoViewIfNeeded()</code><br><code>elem.scrollWidth, elem.scrollHeight</code><br><code>elem.scrollLeft, elem.scrollTop</code> 除了读取，设置也会触发</p>
<h4 id="聚焦"><a href="#聚焦" class="headerlink" title="聚焦"></a>聚焦</h4><p><code>elem.focus()</code> 会触发两次强制布局</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><code>elem.computedRole, elem.computedName</code><br><code>elem.innerText</code><br><code>getComputedStyle</code></p>
<p><code>window.getComputedStyle()</code> 调用通常会导致样式的重新计算，并且，当满足下列条件时，会触发强制布局：</p>
<p>元素属于一颗影子树中<br>出现下列任意一个媒体查询时：<br><code>min-width, min-height, max-width, max-height, width, height</code><br><code>aspect-ratio, min-aspect-ratio, max-aspect-ratio</code><br><code>device-pixel-ratio, resolution, orientation , min-device-pixel-ratio, max-device-pixel-ratio</code></p>
<p>所获取的属性是下列之一时：</p>
<p><code>height, width</code><br><code>top, right, bottom, left</code><br><code>margin [-top, -right, -bottom, -left, 或简写形式]</code> 仅在数值是定值时<br><code>padding [-top, -right, -bottom, -left, 或简写形式]</code> 仅在数值是定值时<br><code>transform, transform-origin, perspective-origin</code><br><code>translate, rotate, scale</code><br><code>grid, grid-template, grid-template-columns, grid-template-rows</code><br><code>perspective-origin</code><br><code>window</code></p>
<p><code>window.scrollX, window.scrollY</code><br><code>window.innerHeight, window.innerWidth</code><br><code>window.getMatchedCSSRules()</code> 仅会导致样式重新计算</p>
<a id="more"></a>
<h4 id="表单"><a href="#表单" class="headerlink" title="表单:"></a>表单:</h4><p><code>inputElem.focus()</code><br><code>inputElem.select(), textareaElem.select()</code></p>
<h4 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件:"></a>鼠标事件:</h4><p><code>mouseEvt.layerX, mouseEvt.layerY, mouseEvt.offsetX, mouseEvt.offsetY
document</code></p>
<p><code>doc.scrollingElement</code> 仅会导致样式重新计算</p>
<h4 id="Range"><a href="#Range" class="headerlink" title="Range:"></a>Range:</h4><p><code>range.getClientRects(), range.getBoundingClientRect()</code></p>
<h4 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h4><p>可以参见 <a href="http://gent.ilcore.com/2011/03/how-not-to-trigger-layout-in-webkit.html" target="_blank" rel="noopener">Tony Gentilcore’s 2011 Layout Triggering List</a></p>
<h4 id="contenteditable"><a href="#contenteditable" class="headerlink" title="contenteditable"></a>contenteditable</h4><p>很多行为都会触发，包括复制粘贴图像进去</p>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p>在文档发生改变或布局、样式失效时会导致回流的消耗。通常，这是因为DOM发生了改变（类的修改，节点的增加、删除，甚至是添加一个伪类如 :focus);</p>
<p>如果需要强制布局，样式首先会被重新计算。所以强制布局会导致这两种操作的发生。它们所消耗的性能取决于当时的内容或者情况，但通常来说两者所消耗的性能都是相似的；<br>一些简单的解决办法：</p>
<ul>
<li>避免在 for 循环中强制布局以及更改DOM</li>
<li>使用开发工具分析产生影响的代码</li>
<li>批量读写DOM（使用FastDOM或者其他的虚拟DOM实现）</li>
</ul>
<p>上述数据在各个浏览器中的表现：</p>
<ul>
<li><p>上面的数据是通过阅读 Blink 源码所得，对于 Chrome, Opera 以及大多数安卓浏览器来说是可用的<br><a href="http://gent.ilcore.com/2011/03/how-not-to-trigger-layout-in-webkit.html" target="_blank" rel="noopener">Tony Gentilcore’s Layout Triggering List</a> 的文章针对遇 2011 年的 WebKit 并且与上述数据基本一致</p>
</li>
<li><p>现代 WebKit 中出现强制布局的情况是基本上一致的 <a href="https://github.com/WebKit/webkit/search?q=updateLayoutIgnorePendingStylesheets&utf8=✓">updateLayoutIgnorePendingStylesheets - GitHub search - WebKit/WebKit</a></p>
</li>
<li><p>Gecko 内核的回流请求通过 FrameNeedsReflow 进行 <a href="http://lxr.mozilla.org/mozilla-central/search?string=FrameNeedsReflow&find=&findi=.c&filter=^[^\0]*%24&hitlimit=&tree=mozilla-central" target="_blank" rel="noopener">FrameNeedsReflow - mozilla-central search</a></p>
</li>
<li><p>对于 Edge / IE 没有很好的数据支持，但是基本上都是应该一致的，因为这些返回值内容都已经由标准所限制。对于最终结果，可能由于优化方法不同而不同。</p>
</li>
</ul>
<h3 id="Chromium-源码"><a href="#Chromium-源码" class="headerlink" title="Chromium 源码"></a>Chromium 源码</h3><ul>
<li>强制布局（以及样式的重新计算）<a href="https://cs.chromium.org/search/?q=UpdateStyleAndLayoutIgnorePendingStylesheets+-f:out+-f:test&type=cs" target="_blank" rel="noopener">UpdateStyleAndLayoutIgnorePendingStylesheets - Chromium Code Search</a></li>
<li>强制样式重新计算<a href="https://cs.chromium.org/search/?q=UpdateStyleAndLayoutTreeIgnorePendingStylesheets++-f:out+-f:test&type=cs" target="_blank" rel="noopener">UpdateStyleAndLayoutTreeIgnorePendingStylesheets - Chromium Code Search</a></li>
</ul>
<h3 id="CSS-Triggers"><a href="#CSS-Triggers" class="headerlink" title="CSS Triggers"></a>CSS Triggers</h3><p>CSS Triggers 提供了一个很好的资源，里面记载了关于设置或者改变一个CSS数值时，浏览器内需要做什么操作的信息。</p>
<p>更多关于强制布局的信息</p>
<ul>
<li>Avoiding layout thrashing — Web Fundamentals</li>
<li>Fixing Layout thrashing in the real world | Matt Andrews</li>
<li>Timeline demo: Diagnosing forced synchronous layouts - Google Chrome</li>
<li>Preventing ‘layout thrashing’ | Wilson Page</li>
<li>wilsonpage/fastdom</li>
<li>Rendering: repaint, reflow/relayout, restyle / Stoyan</li>
<li>We spent a week making Trello boards load extremely fast. Here’s how we did it. - Fog Creek Blog</li>
<li>Minimizing browser reflow  |  PageSpeed Insights  |  Google Developers</li>
<li>Optimizing Web Content in UIWebViews and Websites on iOS</li>
<li>Accelerated Rendering in Chrome</li>
<li>web performance for the curious</li>
<li>Jank Free</li>
</ul>
]]></content>
      <categories>
        <category>reflow &amp; repaint</category>
      </categories>
      <tags>
        <tag>reflow</tag>
      </tags>
  </entry>
  <entry>
    <title>百度小程序Toast组件</title>
    <url>/2019/07/16/%E7%99%BE%E5%BA%A6%E5%B0%8F%E7%A8%8B%E5%BA%8FToast%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<p>百度小程序Toast组件<br>author: <a href="https://tiffanysbear.github.io/" target="_blank" rel="noopener">@TiffanysBear</a></p>
</blockquote>
<h2 id="BdToast百度小程序自定义通用组件"><a href="#BdToast百度小程序自定义通用组件" class="headerlink" title="BdToast百度小程序自定义通用组件"></a>BdToast百度小程序自定义通用组件</h2><p><a href="https://github.com/Tiffanysbear/bdToast">BdToast百度小程序自定义通用组件-github地址</a></p>
<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>手百小程序的toast仅支持在页中展示，不能自定义位置、字体大小、在单个文本中增加icon等需求；因此自定义一个全局可通用的Toast。</p>
<h2 id="效果预览"><a href="#效果预览" class="headerlink" title="效果预览"></a>效果预览</h2><p><img src="https://raw.githubusercontent.com/Tiffanysbear/bdToast/master/images/demo/1.png" alt title="GitHub,Social Coding"><br><img src="https://raw.githubusercontent.com/Tiffanysbear/bdToast/master/images/demo/2.png" alt title="GitHub,Social Coding"><br><img src="https://raw.githubusercontent.com/Tiffanysbear/bdToast/master/images/demo/3.png" alt title="GitHub,Social Coding"><br><img src="https://raw.githubusercontent.com/Tiffanysbear/bdToast/master/images/demo/4.png" alt title="GitHub,Social Coding"></p>
<a id="more"></a>

<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>代码目录位于 <code>/widget/toast</code> 下，包含3个文件</p>
<ul>
<li>toast.js 脚本代码</li>
<li>toast.css 样式文件，可以根据自己需求定制</li>
<li>toast.swan 模板结构，可以根据自己需求定制</li>
</ul>
<h3 id="使用步骤一："><a href="#使用步骤一：" class="headerlink" title="使用步骤一："></a>使用步骤一：</h3><p>将/widget/toast的三个文件，放在与page同名的widget文件夹中，如果项目没有widget文件夹，就新建一个。</p>
<p><img src="https://raw.githubusercontent.com/Tiffanysbear/bdToast/master/images/demo/5.png" alt title="GitHub,Social Coding"></p>
<h3 id="使用步骤二："><a href="#使用步骤二：" class="headerlink" title="使用步骤二："></a>使用步骤二：</h3><p>在项目的整个 <code>app.js</code> 中引入，一次引入，所有page均可以使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// app.js</span><br><span class="line">import &#123; BdToast &#125; from &apos;./widget/toast/toast.js&apos;;</span><br><span class="line"></span><br><span class="line">App(&#123;</span><br><span class="line">    BdToast, // 挂载</span><br><span class="line">    onLaunch(options) &#123;</span><br><span class="line">        // do something when launch</span><br><span class="line">    &#125;,</span><br><span class="line">    onShow(options) &#123;</span><br><span class="line">        // do something when show</span><br><span class="line">    &#125;,</span><br><span class="line">    onHide() &#123;</span><br><span class="line">        // do something when hide</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="使用步骤三："><a href="#使用步骤三：" class="headerlink" title="使用步骤三："></a>使用步骤三：</h3><p>在项目的app.css中引入 <code>toast.css</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// app.css</span><br><span class="line">@import &quot;./widget/toast/toast.css&quot;;</span><br></pre></td></tr></table></figure>

<h3 id="使用步骤四："><a href="#使用步骤四：" class="headerlink" title="使用步骤四："></a>使用步骤四：</h3><p>在需要的page页面，将模板引入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// pages/index/index.swan</span><br><span class="line">&lt;!-- toast使用 --&gt;</span><br><span class="line">&lt;import src=&quot;/widget/toast/toast.swan&quot;/&gt;</span><br><span class="line">&lt;template is=&quot;bdtoast&quot; data=&quot;&#123;&#123;bdtoast&#125;&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="使用步骤五"><a href="#使用步骤五" class="headerlink" title="使用步骤五"></a>使用步骤五</h3><p>在具体的页面进行初始化调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 初始化</span><br><span class="line">new app.BdToast();</span><br><span class="line"></span><br><span class="line">// 具体调用：</span><br><span class="line">Page(&#123;</span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line">    onLoad() &#123;</span><br><span class="line">        new app.BdToast();</span><br><span class="line">    &#125;,</span><br><span class="line">    clickShowToast(e) &#123;</span><br><span class="line">        switch (+e.target.dataset.id) &#123;</span><br><span class="line">            case 1:</span><br><span class="line">                this.bdtoast.toast(&#123;</span><br><span class="line">                    title: &apos;仅显示标题&apos;</span><br><span class="line">                &#125;);</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                this.bdtoast.toast(&#123;</span><br><span class="line">                    title: &apos;设置图片+文字&apos;,</span><br><span class="line">                    iconSrc: &apos;../../images/loading.gif&apos;</span><br><span class="line">                &#125;);</span><br><span class="line">                break;</span><br><span class="line">            case 3:</span><br><span class="line">                this.bdtoast.toast(&#123;</span><br><span class="line">                    title: &apos;设置时间&apos;,</span><br><span class="line">                    duration: 1000</span><br><span class="line">                &#125;);</span><br><span class="line">                break;</span><br><span class="line">            case 4:</span><br><span class="line">                this.bdtoast.toast(&#123;</span><br><span class="line">                    title: &apos;设置标题&apos;,</span><br><span class="line">                    subTitle: &apos;副标题&apos;</span><br><span class="line">                &#125;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>必填</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>title</td>
<td>string</td>
<td>是</td>
<td>标题</td>
</tr>
<tr>
<td>iconSrc</td>
<td>string</td>
<td>否</td>
<td>icon地址，提供icon的url，icon大小为32px * 32px</td>
</tr>
<tr>
<td>subTitle</td>
<td>string</td>
<td>否</td>
<td>副标题，同时需要title存在才会显示，否则不显示副标题</td>
</tr>
<tr>
<td>duration</td>
<td>number</td>
<td>否</td>
<td>持续时间，不填默认1500毫秒</td>
</tr>
<tr>
<td>success</td>
<td>function</td>
<td>否</td>
<td>执行成功的回调</td>
</tr>
<tr>
<td>fail</td>
<td>function</td>
<td>否</td>
<td>执行失败的回调</td>
</tr>
<tr>
<td>complete</td>
<td>function</td>
<td>否</td>
<td>完成的回调，不管有没有执行成功</td>
</tr>
</tbody></table>
<h2 id="最后说明"><a href="#最后说明" class="headerlink" title="最后说明"></a>最后说明</h2><p>例子Demo中也有关于toast的点击tap事件的绑定，因为此功能不是很常用，有兴趣的可以clone下来自行研究。另外，如果有样式结构或者样式不符合需求的话，可以自己在 <code>widget/toast</code>的源码中进行更新，直到符合自己的需求~<br>欢迎star、issue和pull request~</p>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>百度小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能JavaScript</title>
    <url>/2019/07/11/%E9%AB%98%E6%80%A7%E8%83%BDJavaScript/</url>
    <content><![CDATA[<blockquote>
<p>高性能JavaScript<br>author: <a href="https://tiffanysbear.github.io/" target="_blank" rel="noopener">@TiffanysBear</a></p>
</blockquote>
<p>从《高性能JavaScript》一书中的整理笔记：</p>
<p>1、将经常使用的对象成员、数组项、和域外变量存入局部变量</p>
<p>原因：数据存储位置对大地代码整体性能会产生重要的影响，直接变量和局部变量的访问速度快于数组和对象成员。因为局部变量位于作用域链的第一个对象中，全局变量位于作用域链的最后一环。变量在作用域链的位置越深，访问的时间就越长。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var doc = document;</span><br><span class="line">var db = doc.body;</span><br><span class="line">var odiv = doc.getElementById(&apos;div1&apos;);</span><br></pre></td></tr></table></figure>



<p>2、避免使用with表达式，因为他改变了运行期上下文的作用域链。</p>
<p>3、同理with，也要注意使用try-catch，因为catch也会改变运行期上下文的作用域链。</p>
<p>4、嵌套成员变量会造成重大的性能影响，尽量少用。</p>
<p>5、DOM操作量化问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 在循坏中更新页面，问题所在：每次循环都对DOM元素访问了两次</span></span><br><span class="line"><span class="comment">// 一次是读取document.getElementById('here').innerHTML的内容</span></span><br><span class="line"><span class="comment">// 一次是修改它。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeDOM</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">15000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">'here'</span>).innerHTML += <span class="string">'a'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">// 改变方法，使用局部变量存好改变量，在循环结束时一并修改</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeDOM</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> content =<span class="string">''</span>；</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">15000</span>; i++) &#123;</span><br><span class="line">        content += <span class="string">'a'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'here'</span>).innerHTML += content;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 关于js字符串拼接的性能优化问题</span></span><br><span class="line">    <span class="comment">// js的处理机制是：新建一个临时字符串，将新字符串赋值为 content + 'a'</span></span><br><span class="line">    <span class="comment">// 然后返回这个新字符串并同时销毁原始字符串</span></span><br><span class="line">    <span class="comment">// 导致字符串的连接效率较低的重要原因不仅在于对于新的临时变量的不断创建</span></span><br><span class="line">    <span class="comment">// 还有js的垃圾回收机制下不断在对象创建期间回收，导致的效率低下</span></span><br><span class="line">    <span class="comment">// 提高效率的办法是用数组的join函数：</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">changeDOM</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> content =[]；</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">15000</span>; i++) &#123;</span><br><span class="line">              content.push(<span class="string">'a'</span>);</span><br><span class="line">          &#125;</span><br><span class="line">         <span class="built_in">document</span>.getElementById(<span class="string">'here'</span>).innerHTML += content.join(<span class="string">''</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// 但是同时也要注意，后来的大部分浏览器都对“+”的连接字符串做了优化</span></span><br><span class="line">    <span class="comment">// 由于SpiderMonkey等引擎对字符串的“+”运算做了优化，结果使用Array.join的效率反而不如直接用"+"！</span></span><br><span class="line">    <span class="comment">// 因此建议是：在IE7以下，使用join，在新浏览器下，除了变量缓存外，不需要做别的优化</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>6、克隆已有的DOM元素，即element.cloneNode(),比起新建节点来说，即element.createElement()，会快一点，但是性能提高不是很大。</p>
<p>7、遍历数组明显快于同样大小和内容的HTML集合</p>
<p>8、 for循环时，HTML某元素集合的长度不建议直接作为循环终止条件，最好将集合的长度赋给一个变量，然后使用变量作为循环终止条件；</p>
<p>原因：当每次迭代过程访问集合的length时，它导致集合器更新，在所有的浏览器上都会产生明显的性能损失。</p>
<p>9、需要考虑实际情况的优化，根据7，可以将集合中的元素通过for循坏赋值到数组中，访问数组的数组快于集合。但是要注意对于复制的开销是否值得。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toArray</span>(<span class="params">collection</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">var</span> clen = collection.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i= <span class="number">0</span>; i &lt; clen; i++) &#123;</span><br><span class="line">        arr[i] = collection[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10、获取DOM节点，使用nextSibling方式与childNodes方式，在不同的浏览器中，这两种方法的时间基本相等。但是在IE中，nextSibling比childNodes好，IE6下，nextSibling比对手快16倍，在IE7下，快105倍。因此，在老的IE中性能严苛的使用条件下，用nextSibling较好。</p>
<p>11、querySelectorAll()可以联合查询，即querySelectorAll(‘div .warning，div .notice’),在各大浏览器中支持也挺好的，还可以过滤很多非元素节点；</p>
<p>这个网站是：<a href="http://caniuse.com/" target="_blank" rel="noopener">canIuse</a>，可以检查HTML、CSS元素在各大浏览器的兼容情况，一个很有用的网站！</p>
<p>12、重绘和重排版；</p>
<p>重绘：不需要改变元素的长度和宽度，不影响DOM的几何属性；</p>
<p>重排版：影响了几何属性，需要重新计算元素的几何属性，而且其他元素的几何属性有可能也会受影响。浏览器会在重排版过程中，重新绘制屏幕上受影响的部分。</p>
<p>获取布局信息的操作将导致刷新队列的动作，如使用：<code>offsetTop</code>、<code>offsetLeft</code>、<code>offsetWidth</code>、<code>offsetHeight</code>、<code>scrollTop</code>、<code>scrollLeft</code>、<code>scrollWidth</code>、<code>clientTop</code>、<code>clientLeft</code>、<code>clientHeight</code>、<code>geteComputedStyle()</code>(在IE中此函数成为currentStyle)；浏览器此时不得不进行渲染队列中带改变的项目，并重新排版以返回正确值。</p>
<p>解决办法：</p>
<ul>
<li><p>通过延迟访问布局信息避免重排版。</p>
</li>
<li><p>整体修改cssText的css代码，而不是分开访问，修改cssText的属性</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 访问了4次DOM，第二次开始重排列并强迫渲染队列执行</span></span><br><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>);</span><br><span class="line">el.style.borderLeft = <span class="string">'1px'</span>;</span><br><span class="line">el.style.borderRight = <span class="string">'2px'</span>;</span><br><span class="line">el.style.padding = <span class="string">'5px'</span>;</span><br><span class="line"><span class="comment">// 改进：改变合并，通过cssText实现</span></span><br><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>);</span><br><span class="line">el.cssText += <span class="string">'border-left = 1px; border-right = 2px; padding = 5px;'</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>改变css类名来实现样式改变</p>
</li>
<li><p>当对DOM元素进行多次修改时，可以通过以下的步骤减少重绘和重排版的次数：</p>
</li>
</ul>
<p>(注意：此过程引发两次重排版，第一次引发一次，第三次引发一次。如果没有此步骤的话，每次对第二步的改变都有可能带来重排版。)</p>
<p>从文档流中摘除该元素，摘除该元素的方法有：<br>a、对其应用多重改变<br>b、将元素带回文档中<br>c、使其隐藏，进行修改后在显示<br>d、使用文档片段创建子树，在将他拷贝进文档</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> doc = <span class="built_in">document</span>;</span><br><span class="line"><span class="comment">// 创建文档子树</span></span><br><span class="line"><span class="keyword">var</span> frag = doc.createDocumentFragment();</span><br><span class="line"><span class="comment">// 自定义函数，将修改内容data赋给文档片段frag，具体过程忽略</span></span><br><span class="line">appendDataToElement(frag,data);</span><br><span class="line"><span class="comment">// 注意：添加时实际添加的是文档片段的子节点群，而不是frag自己，只会引发一次重排版</span></span><br><span class="line">doc.getElementById(<span class="string">'div1'</span>).appendChild(frag);</span><br></pre></td></tr></table></figure>

<p>创建一个节点的副本，在副本上进行修改，再让复制节点覆盖原先节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个节点的副本，在副本上进行修改，再让复制节点覆盖原先节点</span></span><br><span class="line"><span class="keyword">var</span> oldNode = <span class="built_in">document</span>.getElementById(<span class="string">'old'</span>);</span><br><span class="line"><span class="keyword">var</span> clone = old.cloneNode();</span><br><span class="line">appendDataToElement(clone, data);</span><br><span class="line">oldNode.replaceChild(clone, oldNode);</span><br></pre></td></tr></table></figure>

<p>ps：推荐第二种，因为其涉及最少数量的操作和重排列。</p>
<p>14、减少对布局信息的查询次数，查询时将他赋值给局部变量参与计算。</p>
<p>例子，在元素网右下方不断平移时，在timeout中可以写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> current = myElement.offsetLeft;</span><br><span class="line">current++;</span><br><span class="line">myElement.style.left = current + <span class="string">'px'</span>;</span><br><span class="line">myElement.style.top =  current + <span class="string">'px'</span>;</span><br><span class="line"><span class="keyword">if</span> (current &gt; <span class="number">500</span>) &#123;</span><br><span class="line"><span class="comment">// stop animation</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 拒绝下面的写法，每次移动都会查询一次偏移量，导致浏览器刷新渲染队列，非常耗时</span></span><br><span class="line"></span><br><span class="line">myElement.style.left = myElement.offsetLeft + <span class="string">'px'</span>;</span><br><span class="line">myElement.style.top =  myElement.offsetLeft + <span class="string">'px'</span>;</span><br><span class="line"><span class="keyword">if</span> (myElement.offsetLeft &gt; <span class="number">500</span>) &#123;</span><br><span class="line"> <span class="comment">// stop animation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>15、大量的元素使用：hover之后，页面性能将降低，特别是IE8中。因此强烈建议，在数据量很大的表格中，减少鼠标在表上移动效果，减少高亮行的显示，使用高亮是个慢速过程CPU使用率会提高到80%-90%，尽量避免使用这种效果。</p>
<p>16、事件托管</p>
<p>讲到事件托管，首先我们来看一看冒泡机制：</p>
<p>DOM2级事件规定事件包括三个阶段： ① 事件捕获阶段 ② 处于目标阶段 ③ 事件冒泡阶段</p>
<p><img src="https://www.w3.org/TR/DOM-Level-3-Events/images/eventflow.svg" alt></p>
<p>图片引用来源：<a href="http://www.w3.org/TR/DOM-Level-3-Events/#event-flow" target="_blank" rel="noopener">http://www.w3.org/TR/DOM-Level-3-Events/#event-flow</a></p>
<p>如下图的实验结果可以知道，当我们点击了inner之后，捕获和冒泡结果如上图的规律相同；</p>
<p>因此，因为每一个元素有一个或多个事件句柄与之相连时，可能会影响性能，毕竟连接每一个句柄都是有代价的，所以我们采用事件托管技术，在一个包装元素上挂接一个句柄，用于处理子元素发生的所有事件。</p>
<p>下面我们以如下的dom结构为例：</p>
<p>假如有一个ul，下面有很多个li：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ulList"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"item1"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"item2"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"item3"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"item4"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"item5"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当某个Li被点击的时候需要触发相应的处理事件。我们通常的写法，是为每个Li都添加onClick的事件监听。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addListenersLi</span>(<span class="params">liNode</span>) </span>&#123;</span><br><span class="line">    liNode.onclick = <span class="function"><span class="keyword">function</span> <span class="title">clickHandler</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ulNode = <span class="built_in">document</span>.getElementById(<span class="string">"ulList"</span>);</span><br><span class="line">    <span class="keyword">var</span> liNodes = ulNode.getElementByTagName(<span class="string">"li"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>, l = liNodes.length; i &lt; l; i++)&#123;</span><br><span class="line">        addListeners4Li(liNodes[i]);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果li足够多，或者对于li的操作特别频繁，为每一个li绑定一个点击事件将会特别影响性能，因为在此期间，你需要访问和修改更多的DOM节点，事件的绑定过程发生在onload事件中，绑定本身也非常耗时；同时，浏览器需要保存每个句柄的记录，很占用内存。重点是有些绑定了还不一定会用着，并不是100%的按钮或链接都会被点到的哟！</p>
<p>因此，采用事件托管更为高效，当事件被抛到更上层的父节点的时候，我们通过检查事件的目标对象（target）来判断并获取事件源Li。下面的代码可以完成我们想要的效果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oul = <span class="built_in">document</span>.getElementById(<span class="string">'ulList'</span>);</span><br><span class="line">oul.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> e = e || <span class="built_in">window</span>.event;</span><br><span class="line">    <span class="keyword">var</span> target = e.target || e.srcElement;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">console</span>.log(target.nodeName);</span><br><span class="line">    <span class="keyword">if</span> (target.nodeName == <span class="string">'LI'</span>) &#123;</span><br><span class="line">        <span class="comment">// 事件真正的处理程序</span></span><br><span class="line">        alert(target.id);</span><br><span class="line">        e.preventDefault();</span><br><span class="line">        e.stopPropagation();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(target.nodeName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>高性能JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>为你的博客增加访问量统计</title>
    <url>/2019/07/10/%E4%B8%BA%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E5%A2%9E%E5%8A%A0%E8%AE%BF%E9%97%AE%E9%87%8F%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<blockquote>
<p>为你的博客增加访问量统计<br>author: TiffanysBear</p>
</blockquote>
<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>在github上搭建的博客系统，比如想知道自己网站的PV、UV即用户访问量、页面访问量</p>
<blockquote>
<p>PV: 页面访问量，单个用户连续访问N个页面，记录为N次。<br>UV: 用户访问量，单个用户IP连续访问N个页面，记录为1次。</p>
</blockquote>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>可以使用<a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="noopener">不蒜子计数器</a>，轻量级的网页计算方式。目前存在的问题是，如果网站已经运行一段时间，想初始化访问次数，目前是只能先注册登录，自行修改，但是到目前，注册登录功能一直还没有上线，只能联系Bruce，手工升级==，但是也可以通过js自己手动解决。 </p>
<h3 id="代码使用"><a href="#代码使用" class="headerlink" title="代码使用"></a>代码使用</h3><p>首页在页面中引入不蒜子计数器的js：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>然后在页面html上加上标签即可，可以根据自己的需求加上：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;span id=<span class="string">"busuanzi_container_site_pv"</span>&gt;</span><br><span class="line">    本站总访问量&lt;span id=<span class="string">"busuanzi_value_site_pv"</span>&gt;&lt;/span&gt;次</span><br><span class="line">&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;span id="busuanzi_container_page_pv"&gt;</span></span><br><span class="line"><span class="regexp">    文章点击次数:&lt;span id="busuanzi_value_page_pv"&gt;&lt;/</span>span&gt;</span><br><span class="line">&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">&lt;span id="busuanzi_container_site_uv"&gt;</span></span><br><span class="line"><span class="regexp">    本站浏览量:&lt;span id="busuanzi_value_site_uv"&gt;&lt;/</span>span&gt;</span><br><span class="line">&lt;<span class="regexp">/span&gt;</span></span><br></pre></td></tr></table></figure>

<p>现在基本的统计页面PV、UV的需求就完成了，或许你建站很久，还想加上初始值。</p>
<a id="more"></a>

<h3 id="加上初始值"><a href="#加上初始值" class="headerlink" title="加上初始值"></a>加上初始值</h3><p>如果有加上初始值的需求，那么在js文件中添加如下代码，记得下面这段js应该放在不蒜子的script代码之后：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    $(<span class="built_in">document</span>).ready(</span><br><span class="line">        <span class="comment">// 设置初始值</span></span><br><span class="line">        setInitialCount(<span class="number">100000</span>);</span><br><span class="line">    );</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setInitialCount</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> busuanziSiteOffset = <span class="built_in">parseInt</span>(num);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> ($(<span class="string">"#busuanzi_container_site_pv"</span>).css(<span class="string">"display"</span>) != <span class="string">"none"</span>) &#123;</span><br><span class="line">            <span class="comment">// 同理id也可以是busuanzi_container_page_pv</span></span><br><span class="line">            <span class="comment">// busuanzi_container_site_uv</span></span><br><span class="line">            $(<span class="string">"#busuanzi_value_site_pv"</span>).html(<span class="built_in">parseInt</span>($(<span class="string">"#busuanzi_value_site_pv"</span>).html()) + busuanziSiteOffset);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是因为不蒜子的js代码是异步加载的，所以需要在其数据返回之前，将上述的span标签先隐藏起来，直到累加数据之后在进行展示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">"//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    $(<span class="built_in">document</span>).ready(</span><br><span class="line">        <span class="built_in">window</span>.timer = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">parseInt</span>($(<span class="string">"#busuanzi_value_site_pv"</span>).html()) &#123;</span><br><span class="line">                clearInterval(<span class="built_in">window</span>.timer);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置初始值</span></span><br><span class="line">            setInitialCount(<span class="number">100000</span>);</span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line">        </span><br><span class="line">    );</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setInitialCount</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> busuanziSiteOffset = <span class="built_in">parseInt</span>(num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ($(<span class="string">"#busuanzi_container_site_pv"</span>).css(<span class="string">"display"</span>) != <span class="string">"none"</span>) &#123;</span><br><span class="line">            <span class="comment">// 同理id也可以是busuanzi_container_page_pv</span></span><br><span class="line">            <span class="comment">// busuanzi_container_site_uv</span></span><br><span class="line">            $(<span class="string">"#busuanzi_value_site_pv"</span>).html(<span class="built_in">parseInt</span>($(<span class="string">"#busuanzi_value_site_pv"</span>).html()) + busuanziSiteOffset);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Hexo配置方法"><a href="#Hexo配置方法" class="headerlink" title="Hexo配置方法"></a>Hexo配置方法</h3><p>对于 Hexo 来说，在站点或主题配置中的变量，可以在主题模版中引用得到。于是，我们可以这样做。</p>
<p>在_config.yml中进行配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">#busuanzi</span><br><span class="line">busuanzi: <span class="literal">true</span></span><br><span class="line">busuanzi_initial_value: <span class="number">100000</span></span><br></pre></td></tr></table></figure>

<p>在模板中footer.swig中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> theme.busuanzi %&#125;</span><br><span class="line">&lt;script src=<span class="string">"//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    $(<span class="built_in">document</span>).ready(</span><br><span class="line">        <span class="built_in">window</span>.timer = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">parseInt</span>($(<span class="string">"#busuanzi_value_site_pv"</span>).html()) &#123;</span><br><span class="line">                clearInterval(<span class="built_in">window</span>.timer);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 设置初始值</span></span><br><span class="line">            setInitialCount(&#123;&#123; theme.busuanzi_initial_value &#125;&#125;);</span><br><span class="line">        &#125;, <span class="number">500</span>);</span><br><span class="line">    );</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setInitialCount</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> busuanziSiteOffset = <span class="built_in">parseInt</span>(num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ($(<span class="string">"#busuanzi_container_site_pv"</span>).css(<span class="string">"display"</span>) != <span class="string">"none"</span>) &#123;</span><br><span class="line">            <span class="comment">// 同理id也可以是busuanzi_container_page_pv</span></span><br><span class="line">            <span class="comment">// busuanzi_container_site_uv</span></span><br><span class="line">            $(<span class="string">"#busuanzi_value_site_pv"</span>).html(<span class="built_in">parseInt</span>($(<span class="string">"#busuanzi_value_site_pv"</span>).html()) + busuanziSiteOffset);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure>

<p>这样就可以实现配置化地在自己博客中增加访问量统计了。</p>
]]></content>
      <categories>
        <category>Computer Skills</category>
      </categories>
      <tags>
        <tag>Computer Skills</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue源码学习和分析笔记</title>
    <url>/2019/07/04/Vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>Vue源码学习和分析笔记<br>author: @TiffanysBear</p>
</blockquote>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>前序了解</p>
<h3 id="Flow-静态类型检查工具"><a href="#Flow-静态类型检查工具" class="headerlink" title="Flow 静态类型检查工具"></a>Flow 静态类型检查工具</h3><p>类型推断：通过变量的使用上下文来推断出变量类型，然后根据这些推断来检查类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*@flow*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">split</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(<span class="string">' '</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">split(<span class="number">22</span>);</span><br></pre></td></tr></table></figure>

<p>类型注释：事先注释好我们期待的类型，Flow 会基于这些注释来判断。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*@flow*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: number, y: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="string">'Hello'</span>, <span class="number">11</span>);</span><br></pre></td></tr></table></figure>

<p><a href="https://flow.org/en/docs/types/" target="_blank" rel="noopener">点击了解更多Flow相关特性</a></p>
<a id="more"></a>

<h2 id="源码目录设计"><a href="#源码目录设计" class="headerlink" title="源码目录设计"></a>源码目录设计</h2><p>Vue.js 的源码都在 src 目录下，其目录结构如下。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">├── compiler        # 编译相关 </span><br><span class="line">├── core            # 核心代码 </span><br><span class="line">├── platforms       # 不同平台的支持</span><br><span class="line">├── server          # 服务端渲染</span><br><span class="line">├── sfc             # .vue 文件解析</span><br><span class="line">├── shared          # 共享代码</span><br></pre></td></tr></table></figure>

<h3 id="compiler"><a href="#compiler" class="headerlink" title="compiler"></a>compiler</h3><p>compiler 目录包含 Vue.js 所有编译相关的代码。它包括把模板解析成 AST 语法树，AST语法树优化，代码生成等功能。</p>
<p>编译的工作可以在构建时做（可以借助 webpack、vue-loader 等插件）；也可以在运行时做，使用包含构建功能的 Vue.js。编译是一项耗性能的工作，所以更推荐前者——离线编译。</p>
<h3 id="core"><a href="#core" class="headerlink" title="core"></a>core</h3><p>core 目录包含了 Vue.js 的核心代码，包括有内置组件、全局 API 封装，Vue 实例化、Obsever、Virtual DOM、工具函数 Util 等等。</p>
<h3 id="platform"><a href="#platform" class="headerlink" title="platform"></a>platform</h3><p>Vue.js 是一个跨平台的 MVVM 框架，它可以跑在 web 上，也可以配合 weex 跑在 native 客户端上。platform 是 Vue.js 的入口，2 个目录代表 2 个主要入口，分别打包成运行在 web 上和 weex 上的 Vue.js。</p>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>Vue.js 2.0 支持了服务端渲染，所有服务端渲染相关的逻辑都在这个目录下。注意：这部分代码是跑在服务端的 Node.js，不要和跑在浏览器端的 Vue.js 混为一谈。</p>
<p>服务端渲染主要的工作是把组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将静态标记”混合”为客户端上完全交互的应用程序。</p>
<h3 id="sfc"><a href="#sfc" class="headerlink" title="sfc"></a>sfc</h3><p>通常我们开发 Vue.js 都会借助 webpack 构建， 然后通过 .vue 单文件来编写组件。</p>
<p>这个目录下的代码逻辑会把 .vue 文件内容解析成一个 JavaScript 的对象。</p>
<h3 id="shared"><a href="#shared" class="headerlink" title="shared"></a>shared</h3><p>Vue.js 会定义一些工具方法，这里定义的工具方法都是会被浏览器端的 Vue.js 和服务端的 Vue.js 所共享的。</p>
<h2 id="Vue入口文件"><a href="#Vue入口文件" class="headerlink" title="Vue入口文件"></a>Vue入口文件</h2><p>Vue入口文件目录 vue/src/core/instance/index.js </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue/src/core/instance/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; initMixin &#125; <span class="keyword">from</span> <span class="string">'./init'</span></span><br><span class="line"><span class="keyword">import</span> &#123; stateMixin &#125; <span class="keyword">from</span> <span class="string">'./state'</span></span><br><span class="line"><span class="keyword">import</span> &#123; renderMixin &#125; <span class="keyword">from</span> <span class="string">'./render'</span></span><br><span class="line"><span class="keyword">import</span> &#123; eventsMixin &#125; <span class="keyword">from</span> <span class="string">'./events'</span></span><br><span class="line"><span class="keyword">import</span> &#123; lifecycleMixin &#125; <span class="keyword">from</span> <span class="string">'./lifecycle'</span></span><br><span class="line"><span class="keyword">import</span> &#123; warn &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    !(<span class="keyword">this</span> <span class="keyword">instanceof</span> Vue)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>._init(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initMixin(Vue)</span><br><span class="line">stateMixin(Vue)</span><br><span class="line">eventsMixin(Vue)</span><br><span class="line">lifecycleMixin(Vue)</span><br><span class="line">renderMixin(Vue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br></pre></td></tr></table></figure>

<p>采用的是ES5的写法，并不是ES6的Class写法的优点，是因为：</p>
<p>1、使用混入Mixin的方式传入Vue，为Vue的原型prototype上增加方法。class难以实现这种方法<br>2、此种方式将代码模块合理划分，将扩展分散到多个模块中去实现，使得代码文件不会过于庞大，便于维护和管理。这个编程技巧以后可以用于代码开发实现中。</p>
<p>通过Mixin增加的原型方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// vue/src/core/instance/index.js</span><br><span class="line">initMixin(Vue) // _init</span><br><span class="line">stateMixin(Vue) // $set、$delete、$watch</span><br><span class="line">eventsMixin(Vue) // $on、$once、$off、$emit</span><br><span class="line">lifecycleMixin(Vue) // _update、$forceUpdate、$destroy、</span><br><span class="line">renderMixin(Vue) // $nextTick、_render</span><br></pre></td></tr></table></figure>

<h3 id="initGlobalAPI"><a href="#initGlobalAPI" class="headerlink" title="initGlobalAPI"></a>initGlobalAPI</h3><p>在 vue/src/core/index.js 中，调用的initGlobalAPI(Vue)，是为Vue增加静态方法的，</p>
<p>在路径 vue/src/core/global-api/ 目录下的文件中，都是给Vue添加的静态方法</p>
<p>比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.use <span class="comment">// 使用plugin</span></span><br><span class="line">Vue.extend</span><br><span class="line">Vue.mixin </span><br><span class="line">Vue.component </span><br><span class="line">Vue.directive </span><br><span class="line">Vue.filter</span><br></pre></td></tr></table></figure>

<h2 id="new-Vue-做了什么"><a href="#new-Vue-做了什么" class="headerlink" title="new Vue 做了什么"></a>new Vue 做了什么</h2><p>从入口的文件看来，通过new关键字初始化，调用了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>._init(options)</span><br></pre></td></tr></table></figure>

<p>然后从Mixin增加的原型方法看，initMixin(Vue)，调用的是为Vue增加的原型方法_init</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/init.js</span></span><br><span class="line"></span><br><span class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: Object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// expose real self</span></span><br><span class="line">    vm._self = vm</span><br><span class="line">    initLifecycle(vm)</span><br><span class="line">    initEvents(vm)</span><br><span class="line">    initRender(vm)</span><br><span class="line">    callHook(vm, <span class="string">'beforeCreate'</span>)</span><br><span class="line">    initInjections(vm) <span class="comment">// resolve injections before data/props</span></span><br><span class="line">    initState(vm)</span><br><span class="line">    initProvide(vm) <span class="comment">// resolve provide after data/props</span></span><br><span class="line">    callHook(vm, <span class="string">'created'</span>)</span><br><span class="line">    </span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">      vm.$mount(vm.$options.el)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的函数名看来，new vue所做的事情，就像一个流程图一样展开了，分别是</p>
<ul>
<li>合并配置</li>
<li>初始化生命周期</li>
<li>初始化事件中心</li>
<li>初始化渲染</li>
<li>调用beforeCreate钩子函数</li>
<li>init injections and reactivity（这个阶段属性都已注入绑定，而且被$watch变成reactivity，但是$el还是没有生成，也就是DOM没有生成）</li>
<li>初始化state状态（初始化了data、props、computed、watcher）</li>
<li>调用created钩子函数。</li>
</ul>
<p>在初始化的最后，检测到如果有 el 属性，则调用 vm.$mount 方法挂载 vm，挂载的目标就是把模板渲染成最终的 DOM。</p>
<p>Vue代码初始化的主线逻辑非常分明，使得逻辑和流程非常清楚，这种编程方法值得学习。</p>
<h2 id="Vue实例挂载"><a href="#Vue实例挂载" class="headerlink" title="Vue实例挂载"></a>Vue实例挂载</h2><p>实例挂载主要是$mount方法的实现，在 <code>src/platforms/web/entry-runtime-with-compiler.js</code> &amp; <code>src/platforms/web/runtime/index.js</code> 等文件中都有对Vue.prototype.$mount的定义:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue/platforms/web/entry-runtime-with-compiler.js</span></span><br><span class="line"></span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: string | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: boolean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; query(el)</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (el === <span class="built_in">document</span>.body || el === <span class="built_in">document</span>.documentElement) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> options = <span class="keyword">this</span>.$options</span><br><span class="line">  <span class="comment">// resolve template/el and convert to render function</span></span><br><span class="line">  <span class="keyword">if</span> (!options.render) &#123;</span><br><span class="line">    <span class="keyword">let</span> template = options.template</span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (template.charAt(<span class="number">0</span>) === <span class="string">'#'</span>) &#123;</span><br><span class="line">          template = idToTemplate(template)</span><br><span class="line">          <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">          <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !template) &#123;</span><br><span class="line">            warn(</span><br><span class="line">              <span class="string">`Template element not found or is empty: <span class="subst">$&#123;options.template&#125;</span>`</span>,</span><br><span class="line">              <span class="keyword">this</span></span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.nodeType) &#123;</span><br><span class="line">        template = template.innerHTML</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">          warn(<span class="string">'invalid template option:'</span> + template, <span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</span><br><span class="line">      template = getOuterHTML(el)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        mark(<span class="string">'compile'</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;</span><br><span class="line">        outputSourceRange: process.env.NODE_ENV !== <span class="string">'production'</span>,</span><br><span class="line">        shouldDecodeNewlines,</span><br><span class="line">        shouldDecodeNewlinesForHref,</span><br><span class="line">        delimiters: options.delimiters,</span><br><span class="line">        comments: options.comments</span><br><span class="line">      &#125;, <span class="keyword">this</span>)</span><br><span class="line">      options.render = render</span><br><span class="line">      options.staticRenderFns = staticRenderFns</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        mark(<span class="string">'compile end'</span>)</span><br><span class="line">        measure(<span class="string">`vue <span class="subst">$&#123;<span class="keyword">this</span>._name&#125;</span> compile`</span>, <span class="string">'compile'</span>, <span class="string">'compile end'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mount.call(<span class="keyword">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$mount方法进来会先进行缓存，之后再进行覆盖重写，再重写的方法里面会调用之前缓存的mount方法，这种做法是因为，多个平台platform的mount方法不同，在入口处进行重写，使后续的多入口能够复用公用定义的mount方法（原先原型上的 $mount 方法在 src/platform/web/runtime/index.js 中定义）。</p>
<p>在$mount方法中，会先判断options中 el 是否存在，再判断 render （有template存在的条件下也需要有render函数），之后再是再判断template，会对template做一定的校验，最后使用 <code>compileToFunctions</code> 将template转化为<code>render</code> 和 <code>staticRenderFns</code>.</p>
<p>compileToFunctions编译过程就放在下面文章中再详细解释。</p>
<p>mountComponent方法定义在 <code>src/core/instance/lifecycle.js</code>中，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// src/core/instance/lifecycle.js</span><br><span class="line">export function mountComponent (</span><br><span class="line">  vm: Component,</span><br><span class="line">  el: ?Element,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): Component &#123;</span><br><span class="line">  vm.$el = el</span><br><span class="line">  if (!vm.$options.render) &#123;</span><br><span class="line">    vm.$options.render = createEmptyVNode</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">      /* istanbul ignore if */</span><br><span class="line">      if ((vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !== &apos;#&apos;) ||</span><br><span class="line">        vm.$options.el || el) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &apos;You are using the runtime-only build of Vue where the template &apos; +</span><br><span class="line">          &apos;compiler is not available. Either pre-compile the templates into &apos; +</span><br><span class="line">          &apos;render functions, or use the compiler-included build.&apos;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &apos;Failed to mount component: template or render function not defined.&apos;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  callHook(vm, &apos;beforeMount&apos;)</span><br><span class="line"></span><br><span class="line">  let updateComponent</span><br><span class="line">  /* istanbul ignore if */</span><br><span class="line">  if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = () =&gt; &#123;</span><br><span class="line">      const name = vm._name</span><br><span class="line">      const id = vm._uid</span><br><span class="line">      const startTag = `vue-perf-start:$&#123;id&#125;`</span><br><span class="line">      const endTag = `vue-perf-end:$&#123;id&#125;`</span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      const vnode = vm._render()</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(`vue $&#123;name&#125; render`, startTag, endTag)</span><br><span class="line"></span><br><span class="line">      mark(startTag)</span><br><span class="line">      vm._update(vnode, hydrating)</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(`vue $&#123;name&#125; patch`, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    updateComponent = () =&gt; &#123;</span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // we set this to vm._watcher inside the watcher&apos;s constructor</span><br><span class="line">  // since the watcher&apos;s initial patch may call $forceUpdate (e.g. inside child</span><br><span class="line">  // component&apos;s mounted hook), which relies on vm._watcher being already defined</span><br><span class="line">  new Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">    before () &#123;</span><br><span class="line">      if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;</span><br><span class="line">        callHook(vm, &apos;beforeUpdate&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, true /* isRenderWatcher */)</span><br><span class="line">  hydrating = false</span><br><span class="line"></span><br><span class="line">  // manually mounted instance, call mounted on self</span><br><span class="line">  // mounted is called for render-created child components in its inserted hook</span><br><span class="line">  if (vm.$vnode == null) &#123;</span><br><span class="line">    vm._isMounted = true</span><br><span class="line">    callHook(vm, &apos;mounted&apos;)</span><br><span class="line">  &#125;</span><br><span class="line">  return vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看到，mountComponent 核心就是先实例化一个<code>渲染Watcher(字段isRenderWatcher)</code>，在它的回调函数中会调用 updateComponent 方法，在此方法中调用 vm._render 方法先生成虚拟 Node，最终调用 vm._update 更新 DOM。</p>
<p>Watcher 在这里起到两个作用，一个是初始化的时候会执行回调函数，另一个是当 vm 实例中的监测的数据发生变化的时候执行回调函数，这块儿我们会在之后的章节中介绍。</p>
<p>函数最后判断为根节点的时候设置 vm._isMounted 为 true， 表示这个实例已经挂载了，同时执行 mounted 钩子函数。 这里注意 vm.$vnode 表示 Vue 实例的父虚拟 Node，所以它为 Null 则表示当前是根 Vue 的实例。</p>
<p>因此接下来分析的重点在于：<code>vm._update</code> 和 <code>m._render</code></p>
<h2 id="render"><a href="#render" class="headerlink" title="_render"></a>_render</h2><p>Vue的_render是实例的一个私有方法，定义在 <code>src/core/instance/render.js</code>文件中，返回一个虚拟节点vnode。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// src/core/instance/render.js</span><br><span class="line"></span><br><span class="line"> Vue.prototype._render = function (): VNode &#123;</span><br><span class="line">    const vm: Component = this</span><br><span class="line">    const &#123; render, _parentVnode &#125; = vm.$options</span><br><span class="line"></span><br><span class="line">    if (_parentVnode) &#123;</span><br><span class="line">      vm.$scopedSlots = normalizeScopedSlots(</span><br><span class="line">        _parentVnode.data.scopedSlots,</span><br><span class="line">        vm.$slots,</span><br><span class="line">        vm.$scopedSlots</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // set parent vnode. this allows render functions to have access</span><br><span class="line">    // to the data on the placeholder node.</span><br><span class="line">    vm.$vnode = _parentVnode</span><br><span class="line">    // render self</span><br><span class="line">    let vnode</span><br><span class="line">    try &#123;</span><br><span class="line">      // There&apos;s no need to maintain a stack because all render fns are called</span><br><span class="line">      // separately from one another. Nested component&apos;s render fns are called</span><br><span class="line">      // when parent component is patched.</span><br><span class="line">      currentRenderingInstance = vm</span><br><span class="line">      vnode = render.call(vm._renderProxy, vm.$createElement)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      handleError(e, vm, `render`)</span><br><span class="line">      // return error render result,</span><br><span class="line">      // or previous vnode to prevent render error causing blank component</span><br><span class="line">      /* istanbul ignore else */</span><br><span class="line">      if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; vm.$options.renderError) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">          handleError(e, vm, `renderError`)</span><br><span class="line">          vnode = vm._vnode</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        vnode = vm._vnode</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      currentRenderingInstance = null</span><br><span class="line">    &#125;</span><br><span class="line">    // if the returned array contains only a single node, allow it</span><br><span class="line">    if (Array.isArray(vnode) &amp;&amp; vnode.length === 1) &#123;</span><br><span class="line">      vnode = vnode[0]</span><br><span class="line">    &#125;</span><br><span class="line">    // return empty vnode in case the render function errored out</span><br><span class="line">    if (!(vnode instanceof VNode)) &#123;</span><br><span class="line">      if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; Array.isArray(vnode)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &apos;Multiple root nodes returned from render function. Render function &apos; +</span><br><span class="line">          &apos;should return a single root node.&apos;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      vnode = createEmptyVNode()</span><br><span class="line">    &#125;</span><br><span class="line">    // set parent</span><br><span class="line">    vnode.parent = _parentVnode</span><br><span class="line">    return vnode</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这段函数方法的重点在于render方法的调用，第一种是分为手写的render函数，这种并不常用，比较常用的是template模板，在之前的 mounted 方法的实现时，会将template编译为一个render函数。</p>
<p>其中vm._renderProxy是定义在<code>/src/core/instance/proxy.js</code>文件中，判断如果支持Proxy，如果不支持，返回的是vm，支持的话返回用Proxy代理的vm。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// src/core/instance/proxy.js</span><br><span class="line">initProxy = function initProxy (vm) &#123;</span><br><span class="line">  if (hasProxy) &#123;</span><br><span class="line">    // determine which proxy handler to use</span><br><span class="line">    const options = vm.$options</span><br><span class="line">    const handlers = options.render &amp;&amp; options.render._withStripped</span><br><span class="line">      ? getHandler</span><br><span class="line">      : hasHandler</span><br><span class="line">    vm._renderProxy = new Proxy(vm, handlers)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    vm._renderProxy = vm</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中vm.$createElement也就是在 <code>src/core/instance/render.js</code>文件中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// src/core/instance/render.js</span><br><span class="line"></span><br><span class="line">import &#123; createElement &#125; from &apos;../vdom/create-element&apos;</span><br><span class="line">// bind the createElement fn to this instance</span><br><span class="line">// so that we get proper render context inside it.</span><br><span class="line">// args order: tag, data, children, normalizationType, alwaysNormalize</span><br><span class="line">// internal version is used by render functions compiled from templates</span><br><span class="line">vm._c = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, false)</span><br><span class="line">// normalization is always applied for the public version, used in</span><br><span class="line">// user-written render functions.</span><br><span class="line">vm.$createElement = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, true)</span><br></pre></td></tr></table></figure>

<p>可以从注释中看出：<br>vm._c是template模板编译为render function时使用的；<br>vm.$createElement是用户手写的render function时使用；</p>
<p>这两个函数的支持的参数相同，并且内部都调用了 <code>vdom/create-element</code> 的 <code>createElement</code>方法。</p>
<h2 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h2><p>在讲_update方法之前，了解下Virtual DOM到底是什么？</p>
<p>Virtual DOM也就是虚拟DOM，是真实数据和页面DOM元素之前的缓冲；数据一变化，并不是立马更新所有视图，而是先更新虚拟DOM，再将虚拟DOM和真实DOM进行对比diff，发生变化的部分再更新到真实DOM中，未发生变化的部分，则不进行更新。</p>
<p>下面是Vue对于VNode的定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// vue/src/core/vdom/vnode.js</span><br><span class="line">export default class VNode &#123;</span><br><span class="line">  tag: string | void;</span><br><span class="line">  data: VNodeData | void;</span><br><span class="line">  children: ?Array&lt;VNode&gt;;</span><br><span class="line">  text: string | void;</span><br><span class="line">  elm: Node | void;</span><br><span class="line">  ns: string | void;</span><br><span class="line">  context: Component | void; // rendered in this component&apos;s scope</span><br><span class="line">  key: string | number | void;</span><br><span class="line">  componentOptions: VNodeComponentOptions | void;</span><br><span class="line">  componentInstance: Component | void; // component instance</span><br><span class="line">  parent: VNode | void; // component placeholder node</span><br><span class="line"></span><br><span class="line">  // strictly internal</span><br><span class="line">  raw: boolean; // contains raw HTML? (server only)</span><br><span class="line">  isStatic: boolean; // hoisted static node</span><br><span class="line">  isRootInsert: boolean; // necessary for enter transition check</span><br><span class="line">  isComment: boolean; // empty comment placeholder?</span><br><span class="line">  isCloned: boolean; // is a cloned node?</span><br><span class="line">  isOnce: boolean; // is a v-once node?</span><br><span class="line">  asyncFactory: Function | void; // async component factory function</span><br><span class="line">  asyncMeta: Object | void;</span><br><span class="line">  isAsyncPlaceholder: boolean;</span><br><span class="line">  ssrContext: Object | void;</span><br><span class="line">  fnContext: Component | void; // real context vm for functional nodes</span><br><span class="line">  fnOptions: ?ComponentOptions; // for SSR caching</span><br><span class="line">  devtoolsMeta: ?Object; // used to store functional render context for devtools</span><br><span class="line">  fnScopeId: ?string; // functional scope id support</span><br><span class="line"></span><br><span class="line">  constructor (</span><br><span class="line">    tag?: string,</span><br><span class="line">    data?: VNodeData,</span><br><span class="line">    children?: ?Array&lt;VNode&gt;,</span><br><span class="line">    text?: string,</span><br><span class="line">    elm?: Node,</span><br><span class="line">    context?: Component,</span><br><span class="line">    componentOptions?: VNodeComponentOptions,</span><br><span class="line">    asyncFactory?: Function</span><br><span class="line">  ) &#123;</span><br><span class="line">    this.tag = tag</span><br><span class="line">    this.data = data</span><br><span class="line">    this.children = children</span><br><span class="line">    this.text = text</span><br><span class="line">    this.elm = elm</span><br><span class="line">    this.ns = undefined</span><br><span class="line">    this.context = context</span><br><span class="line">    this.fnContext = undefined</span><br><span class="line">    this.fnOptions = undefined</span><br><span class="line">    this.fnScopeId = undefined</span><br><span class="line">    this.key = data &amp;&amp; data.key</span><br><span class="line">    this.componentOptions = componentOptions</span><br><span class="line">    this.componentInstance = undefined</span><br><span class="line">    this.parent = undefined</span><br><span class="line">    this.raw = false</span><br><span class="line">    this.isStatic = false</span><br><span class="line">    this.isRootInsert = true</span><br><span class="line">    this.isComment = false</span><br><span class="line">    this.isCloned = false</span><br><span class="line">    this.isOnce = false</span><br><span class="line">    this.asyncFactory = asyncFactory</span><br><span class="line">    this.asyncMeta = undefined</span><br><span class="line">    this.isAsyncPlaceholder = false</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // DEPRECATED: alias for componentInstance for backwards compat.</span><br><span class="line">  /* istanbul ignore next */</span><br><span class="line">  get child (): Component | void &#123;</span><br><span class="line">    return this.componentInstance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上 Vue.js 中 Virtual DOM 是借鉴了一个开源库 <a href="https://github.com/snabbdom/snabbdom">snabbdom</a> 的实现，如果对Virtual DOM感兴趣的话，可以参考<a href="https://github.com/Matt-Esch/virtual-dom">virtual-dom</a>，正如其介绍，</p>
<blockquote>
<p>A JavaScript DOM model supporting element creation, diff computation and patch operations for efficient re-rendering</p>
</blockquote>
<p>VNode是对真实DOM的抽象描述，主要是由几个关键属性、标签名等数据组成，并不是很复杂，主要复杂的对VNode的create、diff、patch等过程。</p>
<h2 id="createElement是怎么实现的"><a href="#createElement是怎么实现的" class="headerlink" title="createElement是怎么实现的"></a>createElement是怎么实现的</h2><h3 id="方法入口"><a href="#方法入口" class="headerlink" title="方法入口"></a>方法入口</h3><p>Vue.js通过文件 <code>src/core/vdom/create-element.js</code> 来创建VNode元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// src/core/vdom/create-element.js</span><br><span class="line"></span><br><span class="line">// wrapper function for providing a more flexible interface</span><br><span class="line">// without getting yelled at by flow</span><br><span class="line">export function createElement (</span><br><span class="line">  context: Component,</span><br><span class="line">  tag: any,</span><br><span class="line">  data: any,</span><br><span class="line">  children: any,</span><br><span class="line">  normalizationType: any,</span><br><span class="line">  alwaysNormalize: boolean</span><br><span class="line">): VNode | Array&lt;VNode&gt; &#123;</span><br><span class="line">  if (Array.isArray(data) || isPrimitive(data)) &#123;</span><br><span class="line">    normalizationType = children</span><br><span class="line">    children = data</span><br><span class="line">    data = undefined</span><br><span class="line">  &#125;</span><br><span class="line">  if (isTrue(alwaysNormalize)) &#123;</span><br><span class="line">    normalizationType = ALWAYS_NORMALIZE</span><br><span class="line">  &#125;</span><br><span class="line">  return _createElement(context, tag, data, children, normalizationType)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function _createElement (</span><br><span class="line">  context: Component,</span><br><span class="line">  tag?: string | Class&lt;Component&gt; | Function | Object,</span><br><span class="line">  data?: VNodeData,</span><br><span class="line">  children?: any,</span><br><span class="line">  normalizationType?: number</span><br><span class="line">): VNode | Array&lt;VNode&gt; &#123;</span><br><span class="line">  if (isDef(data) &amp;&amp; isDef((data: any).__ob__)) &#123;</span><br><span class="line">    process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(</span><br><span class="line">      `Avoid using observed data object as vnode data: $&#123;JSON.stringify(data)&#125;\n` +</span><br><span class="line">      &apos;Always create fresh vnode data objects in each render!&apos;,</span><br><span class="line">      context</span><br><span class="line">    )</span><br><span class="line">    return createEmptyVNode()</span><br><span class="line">  &#125;</span><br><span class="line">  // object syntax in v-bind</span><br><span class="line">  if (isDef(data) &amp;&amp; isDef(data.is)) &#123;</span><br><span class="line">    tag = data.is</span><br><span class="line">  &#125;</span><br><span class="line">  if (!tag) &#123;</span><br><span class="line">    // in case of component :is set to falsy value</span><br><span class="line">    return createEmptyVNode()</span><br><span class="line">  &#125;</span><br><span class="line">  // warn against non-primitive key</span><br><span class="line">  if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp;</span><br><span class="line">    isDef(data) &amp;&amp; isDef(data.key) &amp;&amp; !isPrimitive(data.key)</span><br><span class="line">  ) &#123;</span><br><span class="line">    if (!__WEEX__ || !(&apos;@binding&apos; in data.key)) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        &apos;Avoid using non-primitive value as key, &apos; +</span><br><span class="line">        &apos;use string/number value instead.&apos;,</span><br><span class="line">        context</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // support single function children as default scoped slot</span><br><span class="line">  if (Array.isArray(children) &amp;&amp;</span><br><span class="line">    typeof children[0] === &apos;function&apos;</span><br><span class="line">  ) &#123;</span><br><span class="line">    data = data || &#123;&#125;</span><br><span class="line">    data.scopedSlots = &#123; default: children[0] &#125;</span><br><span class="line">    children.length = 0</span><br><span class="line">  &#125;</span><br><span class="line">  if (normalizationType === ALWAYS_NORMALIZE) &#123;</span><br><span class="line">    children = normalizeChildren(children)</span><br><span class="line">  &#125; else if (normalizationType === SIMPLE_NORMALIZE) &#123;</span><br><span class="line">    children = simpleNormalizeChildren(children)</span><br><span class="line">  &#125;</span><br><span class="line">  let vnode, ns</span><br><span class="line">  if (typeof tag === &apos;string&apos;) &#123;</span><br><span class="line">    let Ctor</span><br><span class="line">    ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag)</span><br><span class="line">    if (config.isReservedTag(tag)) &#123;</span><br><span class="line">      // platform built-in elements</span><br><span class="line">      if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; isDef(data) &amp;&amp; isDef(data.nativeOn)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          `The .native modifier for v-on is only valid on components but it was used on &lt;$&#123;tag&#125;&gt;.`,</span><br><span class="line">          context</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      vnode = new VNode(</span><br><span class="line">        config.parsePlatformTagName(tag), data, children,</span><br><span class="line">        undefined, undefined, context</span><br><span class="line">      )</span><br><span class="line">    &#125; else if ((!data || !data.pre) &amp;&amp; isDef(Ctor = resolveAsset(context.$options, &apos;components&apos;, tag))) &#123;</span><br><span class="line">      // component</span><br><span class="line">      vnode = createComponent(Ctor, data, context, children, tag)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // unknown or unlisted namespaced elements</span><br><span class="line">      // check at runtime because it may get assigned a namespace when its</span><br><span class="line">      // parent normalizes children</span><br><span class="line">      vnode = new VNode(</span><br><span class="line">        tag, data, children,</span><br><span class="line">        undefined, undefined, context</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // direct component options / constructor</span><br><span class="line">    vnode = createComponent(tag, data, context, children)</span><br><span class="line">  &#125;</span><br><span class="line">  if (Array.isArray(vnode)) &#123;</span><br><span class="line">    return vnode</span><br><span class="line">  &#125; else if (isDef(vnode)) &#123;</span><br><span class="line">    if (isDef(ns)) applyNS(vnode, ns)</span><br><span class="line">    if (isDef(data)) registerDeepBindings(data)</span><br><span class="line">    return vnode</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return createEmptyVNode()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点是对于 <code>simpleNormalizeChildren</code> 和 <code>normalizeChildren</code> 的处理，基本的操作就是将树状结构的children数组打平成一维数组。</p>
<p><code>normalizeArrayChildren</code> 也就是将createElement的第三个参数，即将children不断遍历打平，不断往res里面push数据，只要是数据Array类型就不断遍历，直到是基础类型TextNode，再进行createTextVNode进行创建。</p>
<p>还有对于组件Component的创建，此处先按下不讲，下文再讲。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// The template compiler attempts to minimize the need for normalization by</span><br><span class="line">// statically analyzing the template at compile time.</span><br><span class="line">//</span><br><span class="line">// For plain HTML markup, normalization can be completely skipped because the</span><br><span class="line">// generated render function is guaranteed to return Array&lt;VNode&gt;. There are</span><br><span class="line">// two cases where extra normalization is needed:</span><br><span class="line"></span><br><span class="line">// 1. When the children contains components - because a functional component</span><br><span class="line">// may return an Array instead of a single root. In this case, just a simple</span><br><span class="line">// normalization is needed - if any child is an Array, we flatten the whole</span><br><span class="line">// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep</span><br><span class="line">// because functional components already normalize their own children.</span><br><span class="line">export function simpleNormalizeChildren (children: any) &#123;</span><br><span class="line">  for (let i = 0; i &lt; children.length; i++) &#123;</span><br><span class="line">    if (Array.isArray(children[i])) &#123;</span><br><span class="line">      return Array.prototype.concat.apply([], children)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return children</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2. When the children contains constructs that always generated nested Arrays,</span><br><span class="line">// e.g. &lt;template&gt;, &lt;slot&gt;, v-for, or when the children is provided by user</span><br><span class="line">// with hand-written render functions / JSX. In such cases a full normalization</span><br><span class="line">// is needed to cater to all possible types of children values.</span><br><span class="line">export function normalizeChildren (children: any): ?Array&lt;VNode&gt; &#123;</span><br><span class="line">  return isPrimitive(children)</span><br><span class="line">    ? [createTextVNode(children)]</span><br><span class="line">    : Array.isArray(children)</span><br><span class="line">      ? normalizeArrayChildren(children)</span><br><span class="line">      : undefined</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function isTextNode (node): boolean &#123;</span><br><span class="line">  return isDef(node) &amp;&amp; isDef(node.text) &amp;&amp; isFalse(node.isComment)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function normalizeArrayChildren (children: any, nestedIndex?: string): Array&lt;VNode&gt; &#123;</span><br><span class="line">  const res = []</span><br><span class="line">  let i, c, lastIndex, last</span><br><span class="line">  for (i = 0; i &lt; children.length; i++) &#123;</span><br><span class="line">    c = children[i]</span><br><span class="line">    if (isUndef(c) || typeof c === &apos;boolean&apos;) continue</span><br><span class="line">    lastIndex = res.length - 1</span><br><span class="line">    last = res[lastIndex]</span><br><span class="line">    //  nested</span><br><span class="line">    if (Array.isArray(c)) &#123;</span><br><span class="line">      if (c.length &gt; 0) &#123;</span><br><span class="line">        c = normalizeArrayChildren(c, `$&#123;nestedIndex || &apos;&apos;&#125;_$&#123;i&#125;`)</span><br><span class="line">        // merge adjacent text nodes</span><br><span class="line">        if (isTextNode(c[0]) &amp;&amp; isTextNode(last)) &#123;</span><br><span class="line">          res[lastIndex] = createTextVNode(last.text + (c[0]: any).text)</span><br><span class="line">          c.shift()</span><br><span class="line">        &#125;</span><br><span class="line">        res.push.apply(res, c)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (isPrimitive(c)) &#123;</span><br><span class="line">      if (isTextNode(last)) &#123;</span><br><span class="line">        // merge adjacent text nodes</span><br><span class="line">        // this is necessary for SSR hydration because text nodes are</span><br><span class="line">        // essentially merged when rendered to HTML strings</span><br><span class="line">        res[lastIndex] = createTextVNode(last.text + c)</span><br><span class="line">      &#125; else if (c !== &apos;&apos;) &#123;</span><br><span class="line">        // convert primitive to vnode</span><br><span class="line">        res.push(createTextVNode(c))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (isTextNode(c) &amp;&amp; isTextNode(last)) &#123;</span><br><span class="line">        // merge adjacent text nodes</span><br><span class="line">        res[lastIndex] = createTextVNode(last.text + c.text)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // default key for nested array children (likely generated by v-for)</span><br><span class="line">        if (isTrue(children._isVList) &amp;&amp;</span><br><span class="line">          isDef(c.tag) &amp;&amp;</span><br><span class="line">          isUndef(c.key) &amp;&amp;</span><br><span class="line">          isDef(nestedIndex)) &#123;</span><br><span class="line">          c.key = `__vlist$&#123;nestedIndex&#125;_$&#123;i&#125;__`</span><br><span class="line">        &#125;</span><br><span class="line">        res.push(c)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="update"><a href="#update" class="headerlink" title="_update"></a>_update</h2><p>_update这一步实际是VNode最终去生成真实DOM的过程。</p>
<p>对于_update方法的定义，在 <code>src/core/instance/lifecycle.js</code> 中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123;</span><br><span class="line">  const vm: Component = this</span><br><span class="line">  const prevEl = vm.$el</span><br><span class="line">  const prevVnode = vm._vnode</span><br><span class="line">  const restoreActiveInstance = setActiveInstance(vm)</span><br><span class="line">  vm._vnode = vnode</span><br><span class="line">  // Vue.prototype.__patch__ is injected in entry points</span><br><span class="line">  // based on the rendering backend used.</span><br><span class="line">  if (!prevVnode) &#123;</span><br><span class="line">    // initial render</span><br><span class="line">    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // updates</span><br><span class="line">    vm.$el = vm.__patch__(prevVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">  restoreActiveInstance()</span><br><span class="line">  // update __vue__ reference</span><br><span class="line">  if (prevEl) &#123;</span><br><span class="line">    prevEl.__vue__ = null</span><br><span class="line">  &#125;</span><br><span class="line">  if (vm.$el) &#123;</span><br><span class="line">    vm.$el.__vue__ = vm</span><br><span class="line">  &#125;</span><br><span class="line">  // if parent is an HOC, update its $el as well</span><br><span class="line">  if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123;</span><br><span class="line">    vm.$parent.$el = vm.$el</span><br><span class="line">  &#125;</span><br><span class="line">  // updated hook is called by the scheduler to ensure that children are</span><br><span class="line">  // updated in a parent&apos;s updated hook.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，主要是对<strong>patch</strong>方法的调用，分别是首次渲染和数据更新的时候会调用；这次先是分析首次调用时，数据更新的部分会在之后响应式原理的时候再进行分析。<br>_update的主要目的就是将虚拟DOM渲染生成真实的DOM元素。</p>
<p>而<strong>patch</strong>方法在不同平台的调用是不同的，在浏览器中时，是patch方法，而在非浏览器环境中，比如node后端环境时，是一个noop空函数，主要也是因为只要在浏览器环境时才会有DOM元素。<br>文件：<code>src/platforms/web/runtime/index.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; patch &#125; from &apos;./patch&apos;</span><br><span class="line"></span><br><span class="line">// install platform patch function</span><br><span class="line">Vue.prototype.__patch__ = inBrowser ? patch : noop</span><br></pre></td></tr></table></figure>

<p>最终 patch 调用的是 <code>src/core/vdom/patch.js</code> 中的 <code>createPatchFunction</code> ，其中有个采用闭包来判断环境的技巧，因为patch方法可能是会在 weex 或者 浏览器端 上调用，如果每次调用都 if else 判断一遍，浪费性能不说，还增加了冗余的判断。于是，它采用了通过闭包判断再返回函数覆盖 patch 的方法，这样环境差异就只会判断一次，进而再次执行的时候，就不会再次判断环境。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function createPatchFunction (backend) &#123;</span><br><span class="line">    // 环境判断</span><br><span class="line">    // ...</span><br><span class="line">    </span><br><span class="line">    return function patch (oldVnode, vnode, hydrating, removeOnly) &#123;</span><br><span class="line">        // ... </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，<code>createPatchFunction</code> 内部定义了一系列的辅助方法。</p>
<p>所以从例子来分析：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var app = new Vue(&#123;</span><br><span class="line">  el: &apos;#app&apos;,</span><br><span class="line">  render: function (createElement) &#123;</span><br><span class="line">    return createElement(&apos;div&apos;, &#123;</span><br><span class="line">      attrs: &#123;</span><br><span class="line">        id: &apos;app&apos;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;, this.message)</span><br><span class="line">  &#125;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &apos;Hello Vue!&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>然后我们在 vm._update 的方法里是这么调用 patch 方法的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// initial render</span><br><span class="line">vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)</span><br></pre></td></tr></table></figure>

<p>结合例子，在首次渲染时，所以在执行 patch 函数的时候，传入的 vm.$el 对应的是例子中 id 为 app 的 DOM 对象，这个也就是 <code>&lt;div id=&quot;app&quot;&gt;</code>， vm.$el 的赋值是在之前 mountComponent 函数做的，vnode 对应的是调用 render 函数的返回值，hydrating 在非服务端渲染情况下为 false，removeOnly 为 false。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function patch (oldVnode, vnode, hydrating, removeOnly) &#123;</span><br><span class="line">    if (isUndef(vnode)) &#123;</span><br><span class="line">      if (isDef(oldVnode)) invokeDestroyHook(oldVnode)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let isInitialPatch = false</span><br><span class="line">    const insertedVnodeQueue = []</span><br><span class="line"></span><br><span class="line">    if (isUndef(oldVnode)) &#123;</span><br><span class="line">      // empty mount (likely as component), create new root element</span><br><span class="line">      isInitialPatch = true</span><br><span class="line">      createElm(vnode, insertedVnodeQueue)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      const isRealElement = isDef(oldVnode.nodeType)</span><br><span class="line">      if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">        // patch existing root node</span><br><span class="line">        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        if (isRealElement) &#123;</span><br><span class="line">          // mounting to a real element</span><br><span class="line">          // check if this is server-rendered content and if we can perform</span><br><span class="line">          // a successful hydration.</span><br><span class="line">          if (oldVnode.nodeType === 1 &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) &#123;</span><br><span class="line">            oldVnode.removeAttribute(SSR_ATTR)</span><br><span class="line">            hydrating = true</span><br><span class="line">          &#125;</span><br><span class="line">          if (isTrue(hydrating)) &#123;</span><br><span class="line">            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123;</span><br><span class="line">              invokeInsertHook(vnode, insertedVnodeQueue, true)</span><br><span class="line">              return oldVnode</span><br><span class="line">            &#125; else if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">              warn(</span><br><span class="line">                &apos;The client-side rendered virtual DOM tree is not matching &apos; +</span><br><span class="line">                &apos;server-rendered content. This is likely caused by incorrect &apos; +</span><br><span class="line">                &apos;HTML markup, for example nesting block-level elements inside &apos; +</span><br><span class="line">                &apos;&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing &apos; +</span><br><span class="line">                &apos;full client-side render.&apos;</span><br><span class="line">              )</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          // either not server-rendered, or hydration failed.</span><br><span class="line">          // create an empty node and replace it</span><br><span class="line">          oldVnode = emptyNodeAt(oldVnode)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // replacing existing element</span><br><span class="line">        const oldElm = oldVnode.elm</span><br><span class="line">        const parentElm = nodeOps.parentNode(oldElm)</span><br><span class="line"></span><br><span class="line">        // create new node</span><br><span class="line">        createElm(</span><br><span class="line">          vnode,</span><br><span class="line">          insertedVnodeQueue,</span><br><span class="line">          // extremely rare edge case: do not insert if old element is in a</span><br><span class="line">          // leaving transition. Only happens when combining transition +</span><br><span class="line">          // keep-alive + HOCs. (#4590)</span><br><span class="line">          oldElm._leaveCb ? null : parentElm,</span><br><span class="line">          nodeOps.nextSibling(oldElm)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        // update parent placeholder node element, recursively</span><br><span class="line">        if (isDef(vnode.parent)) &#123;</span><br><span class="line">          let ancestor = vnode.parent</span><br><span class="line">          const patchable = isPatchable(vnode)</span><br><span class="line">          while (ancestor) &#123;</span><br><span class="line">            for (let i = 0; i &lt; cbs.destroy.length; ++i) &#123;</span><br><span class="line">              cbs.destroy[i](ancestor)</span><br><span class="line">            &#125;</span><br><span class="line">            ancestor.elm = vnode.elm</span><br><span class="line">            if (patchable) &#123;</span><br><span class="line">              for (let i = 0; i &lt; cbs.create.length; ++i) &#123;</span><br><span class="line">                cbs.create[i](emptyNode, ancestor)</span><br><span class="line">              &#125;</span><br><span class="line">              // #6513</span><br><span class="line">              // invoke insert hooks that may have been merged by create hooks.</span><br><span class="line">              // e.g. for directives that uses the &quot;inserted&quot; hook.</span><br><span class="line">              const insert = ancestor.data.hook.insert</span><br><span class="line">              if (insert.merged) &#123;</span><br><span class="line">                // start at index 1 to avoid re-invoking component mounted hook</span><br><span class="line">                for (let i = 1; i &lt; insert.fns.length; i++) &#123;</span><br><span class="line">                  insert.fns[i]()</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              registerRef(ancestor)</span><br><span class="line">            &#125;</span><br><span class="line">            ancestor = ancestor.parent</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // destroy old node</span><br><span class="line">        if (isDef(parentElm)) &#123;</span><br><span class="line">          removeVnodes([oldVnode], 0, 0)</span><br><span class="line">        &#125; else if (isDef(oldVnode.tag)) &#123;</span><br><span class="line">          invokeDestroyHook(oldVnode)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)</span><br><span class="line">    return vnode.elm</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>由于我们传入的 oldVnode 实际上是一个 DOM container，所以 isRealElement 为 true，接下来又通过 emptyNodeAt 方法把 oldVnode 转换成 VNode 对象，然后再调用 createElm 方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createElm (</span><br><span class="line">  vnode,</span><br><span class="line">  insertedVnodeQueue,</span><br><span class="line">  parentElm,</span><br><span class="line">  refElm,</span><br><span class="line">  nested,</span><br><span class="line">  ownerArray,</span><br><span class="line">  index</span><br><span class="line">) &#123;</span><br><span class="line">  if (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) &#123;</span><br><span class="line">    // This vnode was used in a previous render!</span><br><span class="line">    // now it&apos;s used as a new node, overwriting its elm would cause</span><br><span class="line">    // potential patch errors down the road when it&apos;s used as an insertion</span><br><span class="line">    // reference node. Instead, we clone the node on-demand before creating</span><br><span class="line">    // associated DOM element for it.</span><br><span class="line">    vnode = ownerArray[index] = cloneVNode(vnode)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vnode.isRootInsert = !nested // for transition enter check</span><br><span class="line">  if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const data = vnode.data</span><br><span class="line">  const children = vnode.children</span><br><span class="line">  const tag = vnode.tag</span><br><span class="line">  if (isDef(tag)) &#123;</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">      if (data &amp;&amp; data.pre) &#123;</span><br><span class="line">        creatingElmInVPre++</span><br><span class="line">      &#125;</span><br><span class="line">      if (isUnknownElement(vnode, creatingElmInVPre)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          &apos;Unknown custom element: &lt;&apos; + tag + &apos;&gt; - did you &apos; +</span><br><span class="line">          &apos;register the component correctly? For recursive components, &apos; +</span><br><span class="line">          &apos;make sure to provide the &quot;name&quot; option.&apos;,</span><br><span class="line">          vnode.context</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vnode.elm = vnode.ns</span><br><span class="line">      ? nodeOps.createElementNS(vnode.ns, tag)</span><br><span class="line">      : nodeOps.createElement(tag, vnode)</span><br><span class="line">    setScope(vnode)</span><br><span class="line"></span><br><span class="line">    /* istanbul ignore if */</span><br><span class="line">    if (__WEEX__) &#123;</span><br><span class="line">      // in Weex, the default insertion order is parent-first.</span><br><span class="line">      // List items can be optimized to use children-first insertion</span><br><span class="line">      // with append=&quot;tree&quot;.</span><br><span class="line">      const appendAsTree = isDef(data) &amp;&amp; isTrue(data.appendAsTree)</span><br><span class="line">      if (!appendAsTree) &#123;</span><br><span class="line">        if (isDef(data)) &#123;</span><br><span class="line">          invokeCreateHooks(vnode, insertedVnodeQueue)</span><br><span class="line">        &#125;</span><br><span class="line">        insert(parentElm, vnode.elm, refElm)</span><br><span class="line">      &#125;</span><br><span class="line">      createChildren(vnode, children, insertedVnodeQueue)</span><br><span class="line">      if (appendAsTree) &#123;</span><br><span class="line">        if (isDef(data)) &#123;</span><br><span class="line">          invokeCreateHooks(vnode, insertedVnodeQueue)</span><br><span class="line">        &#125;</span><br><span class="line">        insert(parentElm, vnode.elm, refElm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      createChildren(vnode, children, insertedVnodeQueue)</span><br><span class="line">      if (isDef(data)) &#123;</span><br><span class="line">        invokeCreateHooks(vnode, insertedVnodeQueue)</span><br><span class="line">      &#125;</span><br><span class="line">      insert(parentElm, vnode.elm, refElm)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; data &amp;&amp; data.pre) &#123;</span><br><span class="line">      creatingElmInVPre--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (isTrue(vnode.isComment)) &#123;</span><br><span class="line">    vnode.elm = nodeOps.createComment(vnode.text)</span><br><span class="line">    insert(parentElm, vnode.elm, refElm)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    vnode.elm = nodeOps.createTextNode(vnode.text)</span><br><span class="line">    insert(parentElm, vnode.elm, refElm)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>createElm</code> 的作用是通过虚拟节点创建真实的 DOM 并插入到它的父节点中。createComponent 方法目的是尝试创建子组件，接下来判断 vnode 是否包含 tag，如果包含，先简单对 tag 的合法性在非生产环境下做校验，看是否是一个合法标签；然后再去调用平台 DOM 的操作去创建一个占位符元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vnode.elm = vnode.ns</span><br><span class="line">  ? nodeOps.createElementNS(vnode.ns, tag)</span><br><span class="line">  : nodeOps.createElement(tag, vnode)</span><br></pre></td></tr></table></figure>

<p>接下来是通过 <code>createChildren</code> 创建子元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createChildren (vnode, children, insertedVnodeQueue) &#123;</span><br><span class="line">    if (Array.isArray(children)) &#123;</span><br><span class="line">      if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">        checkDuplicateKeys(children)</span><br><span class="line">      &#125;</span><br><span class="line">      for (let i = 0; i &lt; children.length; ++i) &#123;</span><br><span class="line">        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (isPrimitive(vnode.text)) &#123;</span><br><span class="line">      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>createChildren 的逻辑很简单，实际上是遍历子虚拟节点，递归调用 createElm，这是一种常用的深度优先的遍历算法，这里要注意的一点是在遍历过程中会把 vnode.elm 作为父容器的 DOM 节点占位符传入。<br>最后调用 <code>insert</code> 方法把 DOM 插入到父节点中，因为是递归调用，子元素会优先调用 <code>insert</code>，所以整个 vnode 树节点的插入顺序是先子后父。来看一下 insert 方法，它的定义在 <code>src/core/vdom/patch.js</code> 上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert(parentElm, vnode.elm, refElm)</span><br><span class="line"></span><br><span class="line">function insert (parent, elm, ref) &#123;</span><br><span class="line">  if (isDef(parent)) &#123;</span><br><span class="line">    if (isDef(ref)) &#123;</span><br><span class="line">      if (ref.parentNode === parent) &#123;</span><br><span class="line">        nodeOps.insertBefore(parent, elm, ref)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      nodeOps.appendChild(parent, elm)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>insert</code> 逻辑很简单，调用一些 nodeOps 把子节点插入到父节点中，这些辅助方法定义在 <code>src/platforms/web/runtime/node-ops.js</code> 中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function insertBefore (parentNode: Node, newNode: Node, referenceNode: Node) &#123;</span><br><span class="line">  parentNode.insertBefore(newNode, referenceNode)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function appendChild (node: Node, child: Node) &#123;</span><br><span class="line">  node.appendChild(child)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是调用原生 DOM 的 API 进行 DOM 操作。<br>在 <code>createElm 过程中，如果 vnode 节点不包含 tag，则它有可能是一个注释或者纯文本节点，可以直接插入到父元素中。在我们这个例子中，最内层就是一个文本 vnode，它的 text 值取的就是之前的</code>this.message` 的值 Hello Vue!。</p>
<p>再回到 <code>patch</code> 方法，首次渲染我们调用了 <code>createElm</code> 方法，这里传入的 parentElm 是 <code>oldVnode.elm</code> 的父元素，在我们的例子是 id 为 <code>#app</code> div 的父元素，也就是 Body；实际上整个过程就是递归创建了一个完整的 DOM 树并插入到 Body 上。</p>
<p>最后，我们根据之前递归 <code>createElm</code> 生成的 <code>vnode</code> 插入顺序队列，执行相关的 <code>insert</code> 钩子函数。</p>
<p>这里只是分析了最简单的场景，在实际的项目中，会比这些复杂的很多。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue源码</tag>
      </tags>
  </entry>
  <entry>
    <title>React学习记录</title>
    <url>/2019/06/18/React%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<blockquote>
<p>React学习记录<br>学习基础React基本API，深化react的细节，学会思考和提问。<br>author: @TiffanyBear</p>
</blockquote>
<h3 id="content"><a href="#content" class="headerlink" title="content"></a>content</h3><p>1、React DOM 在渲染所有输入内容之前，默认会进行转义。它可以确保在你的应用中，永远不会注入那些并非自己明确编写的内容。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS（cross-site-scripting, 跨站脚本）攻击。</p>
<p>2、JSX 表示对象<br>Babel 会把 JSX 转译成一个名为 React.createElement() 函数调用。react元素</p>
<a id="more"></a>

<p>3、使用String字符串化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt; My JavaScript variable is &#123;String(myVariable)&#125;. &lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>4、“纯函数”，因为该函数不会尝试更改入参，且多次调用下相同的入参始终返回相同的结果。</p>
<p>5、React 非常灵活，但它也有一个严格的规则：<br><font color="red">所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。</font></p>
<p>问题：需要严格保护props的原因是什么？</p>
<p>6、尽管 this.props 和 this.state 是 React 本身设置的，且都拥有特殊的含义，但是其实你可以向 class 中随意添加不参与数据流（比如计时器 ID）的额外字段。</p>
<p>7、State 的更新可能是异步的。出于性能考虑，React 可能会把多个 setState() 调用合并成一个调用。<br>因为 this.props 和 this.state 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。</p>
<p>例如，此代码可能会无法更新计数器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  counter: <span class="keyword">this</span>.state.counter + <span class="keyword">this</span>.props.increment,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>要解决这个问题，可以让 setState() 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">state, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  counter: state.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<p>8、数据是向下流动的</p>
<p>9、事件处理</p>
<ul>
<li>React 事件的命名采用小驼峰式（camelCase），而不是纯小写。</li>
<li>使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;activateLasers&#125;&gt;</span><br><span class="line">  Activate Lasers</span><br><span class="line">&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 React 中另一个不同点是你不能通过返回 false 的方式阻止默认行为。你必须显式的使用 preventDefault；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ActionLink</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'The link was clicked.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;a href=<span class="string">"#"</span> onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">      Click me</span><br><span class="line">    &lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>10、JSX 回调函数中的 this，在 JavaScript 中，class 的方法默认不会绑定 this。如果你忘记绑定 this.handleClick 并把它传入了 onClick，当你调用这个函数的时候 this 的值为 undefined。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为了在回调中使用 `this`，这个绑定是必不可少的</span></span><br><span class="line"><span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// or 在模板中</span></span><br><span class="line">&lt;button onClick=&#123;<span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>)&#125;&gt;</span><br><span class="line">    Click me</span><br><span class="line">&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>

<p>11、阻止组件渲染<br>可以让 render 方法直接返回 null，而不进行任何渲染。在组件的 render 方法中返回 null 并不会影响组件的生命周期。依旧会按照生命周期执行相应的函数方法。</p>
<p>12、key值：</p>
<ul>
<li>帮助 React 识别哪些元素改变了，比如被添加或删除，不建议使用索引来用作 key 值，如果列表项目的顺序可能会变化。正确的key 应该在数组的上下文中被指定。一个好的经验法则是：在 map() 方法中的元素需要设置 key 属性。</li>
<li>数组元素中使用的 key 在其兄弟节点之间应该是独一无二的。然而，它们不需要是全局唯一的。当我们生成两个不同的数组时，我们可以使用相同的 key 值。</li>
<li>key 会传递信息给 React ，但不会传递给你的组件。如果你的组件中需要使用 key 属性的值，请用其他属性名显式传递这个值</li>
</ul>
<p>13、状态提升<br>通常，多个组件需要反映相同的变化数据，这时我们建议将共享状态提升到最近的共同父组件中去。</p>
<p>14、React ref<br>引用</p>
<p>15、错误边界<br>部分 UI 的 JavaScript 错误不应该导致整个应用崩溃，为了解决这个问题，React 16 引入了一个新的概念 —— 错误边界。</p>
<p>错误边界是一种 React 组件，这种组件可以捕获并打印发生在其子组件树任何位置的 JavaScript 错误，并且，它会渲染出备用 UI，而不是渲染那些崩溃了的子组件树。错误边界在渲染期间、生命周期方法和整个组件树的构造函数中捕获错误。</p>
<p>注意<br>错误边界无法捕获以下场景中产生的错误：</p>
<ul>
<li>事件处理（了解更多）</li>
<li>异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数）</li>
<li>服务端渲染</li>
<li>它自身抛出来的错误（并非它的子组件）</li>
<li>如果一个 class 组件中定义了 static getDerivedStateFromError() 或 componentDidCatch() 这两个生命周期方法中的任意一个（或两个）时，那么它就变成一个错误边界。当抛出错误后，请使用 static getDerivedStateFromError() 渲染备用 UI ，使用 componentDidCatch() 打印错误信息。</li>
</ul>
<p><a href="https://zh-hans.reactjs.org/docs/error-boundaries.html" target="_blank" rel="noopener">例子Demo</a></p>
<h3 id="思考问题："><a href="#思考问题：" class="headerlink" title="思考问题："></a>思考问题：</h3><p>1、需要严格保护props的原因是什么？</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>1和new Number(1)有什么区别</title>
    <url>/2019/06/06/1%E5%92%8Cnew%20Number(1)%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<blockquote>
<p>1和new Number(1)有什么区别<br>author: @Tiffanysbear </p>
</blockquote>
<p>总结，两者的区别就是原始类型和包装对象的区别。</p>
<h3 id="什么是包装对象"><a href="#什么是包装对象" class="headerlink" title="什么是包装对象"></a>什么是包装对象</h3><p>对象Number、String、Boolean分别对应数字、字符串、布尔值，可以通过这三个对象把原始类型的值变成（包装成）对象:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var v1 = new Number(123);</span><br><span class="line">var v2 = new String(&apos;abc&apos;);</span><br><span class="line">var v3 = new Boolean(true);</span><br></pre></td></tr></table></figure>

<p>我们来看下实际的v1、v2、v3是什么呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typeof v1;// &quot;object&quot;</span><br><span class="line">typeof v2;// &quot;object&quot;</span><br><span class="line">typeof v3;// &quot;object&quot;</span><br><span class="line"></span><br><span class="line">v1 === 123; // false</span><br><span class="line">v1 == 123; // true</span><br></pre></td></tr></table></figure>

<p>可以理解的是，v1此时是对象，===比较的是内存地址，因此跟数字Number 123不相等；可是为什么v1 == 123得到的值会是true呢？</p>
<a id="more"></a>

<p>那这就是包装对象在使用时的问题了。再来理解一下什么是原始类型。</p>
<h3 id="什么是原始类型"><a href="#什么是原始类型" class="headerlink" title="什么是原始类型"></a>什么是原始类型</h3><p>比如123这类就是原始类型，原始类型并不是一个对象，因此并没有对象具有的一些属性和方法；但是为什么能调用(123).toFixed()这些方法呢？</p>
<p>原因就是这些方法都是像包装对象”借用”来的，toFixed方法是在Number对象原型上的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(123).toFixed === Number.prototype.toFixed // true</span><br><span class="line">&quot;123&quot;.indexOf === String.prototype.indexOf // true</span><br></pre></td></tr></table></figure>

<h3 id="JS求值"><a href="#JS求值" class="headerlink" title="JS求值"></a>JS求值</h3><p>JS在求值运算时，总是会求出原始资料的值，而不是用对象。如下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a = new Number(122);</span><br><span class="line">var b = a + 33; // 155</span><br><span class="line">typeof b; // number</span><br></pre></td></tr></table></figure>

<p>但是要注意 <code>new Boolean</code> 的用法，只有当 new Boolean 的参数值为 null 或者 undefined 时，求值转换的原始资料的值才是false，其他情况都是true；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!!(new Boolean(false)) // true</span><br></pre></td></tr></table></figure>

<p>所以尽量不要使用 new Boolean 这个包装对象进行赋值，否则会产生一些误会。</p>
<h3 id="运算时调用-valueOf-和-toString-的优先级"><a href="#运算时调用-valueOf-和-toString-的优先级" class="headerlink" title="运算时调用 valueOf 和 toString 的优先级"></a>运算时调用 valueOf 和 toString 的优先级</h3><p>先说下结论：</p>
<blockquote>
<p>1、进行对象转换时（alert(e2)）,优先调用 toString 方法，如没有重写 toString 将调用 valueOf 方法，如果两方法都不没有重写，但按 Object 的 toString 输出。<br>2、进行强转字符串类型时将优先调用 toString 方法，强转为数字时优先调用 valueOf。<br>3、在有运算操作符的情况下，valueOf的优先级高于toString。</p>
</blockquote>
<p>以下是三个例子</p>
<p>第一个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let e2 = &#123;</span><br><span class="line">    n : 2,</span><br><span class="line">    toString : function ()&#123;</span><br><span class="line">        console.log(&apos;this is toString&apos;)</span><br><span class="line">        return this.n</span><br><span class="line">    &#125;,</span><br><span class="line">    valueOf : function()&#123;</span><br><span class="line">        console.log(&apos;this is valueOf&apos;)</span><br><span class="line">        return this.n*2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(e2) //  2  this is toString</span><br><span class="line">alert(+e2)  // 4 this is valueOf</span><br><span class="line">alert(&apos;&apos;+e2) // 4 this is valueOf</span><br><span class="line">alert(String(e2)) // 2 this is toString</span><br><span class="line">alert(Number(e2)) // 4 this is valueOf</span><br><span class="line">alert(e2 == &apos;4&apos;) // true  this is valueOf</span><br><span class="line">alert(e2 === 4) //false ===操作符不进行隐式转换</span><br></pre></td></tr></table></figure>

<p>第二个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let e3 = &#123;</span><br><span class="line">    n : 2,</span><br><span class="line">    toString : function ()&#123;</span><br><span class="line">        console.log(&apos;this is toString&apos;)</span><br><span class="line">        return this.n</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(e3) //  2  this is toString</span><br><span class="line">alert(+e3)  // 2 this is toString</span><br><span class="line">alert(&apos;&apos;+e3) // 2 this is toString</span><br><span class="line">alert(String(e3)) // 2 this is toString</span><br><span class="line">alert(Number(e3)) // 2 this is toString</span><br><span class="line">alert(e3 == &apos;2&apos;) // true  this is toString</span><br><span class="line">alert(e3 === 2) //false  ===操作符不进行隐式转换</span><br></pre></td></tr></table></figure>

<p>第三个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.prototype.toString = null; </span><br><span class="line">let e4 = &#123;</span><br><span class="line">    n : 2,</span><br><span class="line">    valueOf : function()&#123;</span><br><span class="line">        console.log(&apos;this is valueOf&apos;)</span><br><span class="line">        return this.n*2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(e4) //  4 this is valueOf</span><br><span class="line">alert(+e4)  // 4 this is valueOf</span><br><span class="line">alert(&apos;&apos;+e4) // 4 this is valueOf</span><br><span class="line">alert(String(e4)) // 4 this is valueOf</span><br><span class="line">alert(Number(e4)) // 4 this is valueOf</span><br><span class="line">alert(e4 == &apos;4&apos;) // true  this is valueOf</span><br><span class="line">alert(e4 === 4) //false  ===操作符不进行隐式转换</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>包装对象</tag>
      </tags>
  </entry>
  <entry>
    <title>函数柯里化</title>
    <url>/2019/05/27/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
    <content><![CDATA[<blockquote>
<p>转载自 <a href="https://github.com/yygmind/blog/issues/37">https://github.com/yygmind/blog/issues/37</a><br>author: <a href="https://yygmind.github.io/" target="_blank" rel="noopener">@yygmind</a></p>
</blockquote>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>上一节介绍了高阶函数的定义，并结合实例说明了使用高阶函数和不使用高阶函数的情况。后面几部分将结合实际应用场景介绍高阶函数的应用，本节先来聊聊函数柯里化，通过介绍其定义、比较常见的三种柯里化应用、并在最后实现一个通用的 currying 函数，带你认识完整的函数柯里化。</p>
<p>有什么想法或者意见都可以在评论区留言，下图是本文的思维导图<br><img src="https://camo.githubusercontent.com/b524d57967a0825e8329e8f562b654c77de764dd/68747470733a2f2f7773342e73696e61696d672e636e2f6c617267652f303036744e63373967793167333774326a6d6a76686a333272303067636e32782e6a7067" alt></p>
<h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>函数柯里化又叫部分求值，维基百科中对柯里化 (Currying) 的定义为：</p>
<p>在数学和计算机科学中，柯里化是一种将使用多个参数的函数转换成一系列使用一个参数的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p>
<p>用大白话来说就是只传递给函数一部分参数来调用它，让它返回一个新函数去处理剩下的参数。使用一个简单的例子来介绍下，最常用的就是 add 函数了。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 木易杨</span><br><span class="line">const add = (...args) =&gt; args.reduce((a, b) =&gt; a + b);</span><br><span class="line"></span><br><span class="line">// 传入多个参数，执行 add 函数</span><br><span class="line">add(1, 2) // 3</span><br><span class="line"></span><br><span class="line">// 假设我们实现了一个 currying 函数，支持一次传入一个参数</span><br><span class="line">let sum = currying(add);</span><br><span class="line">// 封装第一个参数，方便重用</span><br><span class="line">let addCurryOne = sum(1);</span><br><span class="line">addCurryOne(2) // 3</span><br><span class="line">addCurryOne(3) // 4</span><br></pre></td></tr></table></figure>

<h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><h3 id="1、延迟计算"><a href="#1、延迟计算" class="headerlink" title="1、延迟计算"></a>1、延迟计算</h3><p>我们看下面的部分求和例子，很好的说明了延迟计算这个情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 木易杨</span><br><span class="line">const add = (...args) =&gt; args.reduce((a, b) =&gt; a + b);</span><br><span class="line"></span><br><span class="line">// 简化写法</span><br><span class="line">function currying(func) &#123;</span><br><span class="line">    const args = [];</span><br><span class="line">    return function result(...rest) &#123;</span><br><span class="line">        if (rest.length === 0) &#123;</span><br><span class="line">          return func(...args);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          args.push(...rest);</span><br><span class="line">        	return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const sum = currying(add);</span><br><span class="line"></span><br><span class="line">sum(1,2)(3); // 未真正求值</span><br><span class="line">sum(4); 		 // 未真正求值</span><br><span class="line">sum(); 			 // 输出 10</span><br></pre></td></tr></table></figure>

<p>上面的代码理解起来很容易，就是「用闭包把传入参数保存起来，当传入参数的数量足够执行函数时，就开始执行函数」。上面的 currying 函数是一种简化写法，判断传入的参数长度是否为 0，若为 0 执行函数，否则收集参数。</p>
<p>另一种常见的应用是 bind 函数，我们看下 bind 的使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 木易杨</span><br><span class="line">let obj = &#123;</span><br><span class="line">  name: &apos;muyiy&apos;</span><br><span class="line">&#125;</span><br><span class="line">const fun = function () &#123;</span><br><span class="line">  console.log(this.name);</span><br><span class="line">&#125;.bind(obj);</span><br><span class="line"></span><br><span class="line">fun(); // muyiy</span><br></pre></td></tr></table></figure>

<p>这里 bind 用来改变函数执行时候的上下文，但是函数本身并不执行，所以本质上是延迟计算，这一点和 call / apply 直接执行有所不同。</p>
<p>我们看下 bind 模拟实现，其本身就是一种柯里化，我们在最后的实现部分会发现，bind 的模拟实现和柯理化函数的实现，其核心代码都是一致的。</p>
<p>以下实现方案是简化版实现，完整版实现过程和代码解读请看我之前写的一篇文章，【进阶3-4期】深度解析bind原理、使用场景及模拟实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 木易杨</span><br><span class="line">// 简化实现，完整版实现中的第 2 步</span><br><span class="line">Function.prototype.bind = function (context) &#123;</span><br><span class="line">    var self = this;</span><br><span class="line">    // 第 1 个参数是指定的 this，截取保存第 1 个之后的参数</span><br><span class="line">		// arr.slice(begin); 即 [begin, end]</span><br><span class="line">    var args = Array.prototype.slice.call(arguments, 1); </span><br><span class="line"></span><br><span class="line">    return function () &#123;</span><br><span class="line">        // 此时的 arguments 是指 bind 返回的函数调用时接收的参数</span><br><span class="line">        // 即 return function 的参数，和上面那个不同</span><br><span class="line">      	// 类数组转成数组</span><br><span class="line">        var bindArgs = Array.prototype.slice.call(arguments);</span><br><span class="line">      	// 执行函数</span><br><span class="line">        return self.apply( context, args.concat(bindArgs) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、动态创建函数"><a href="#2、动态创建函数" class="headerlink" title="2、动态创建函数"></a>2、动态创建函数</h3><p>有一种典型的应用情景是这样的，每次调用函数都需要进行一次判断，但其实第一次判断计算之后，后续调用并不需要再次判断，这种情况下就非常适合使用柯里化方案来处理。即第一次判断之后，动态创建一个新函数用于处理后续传入的参数，并返回这个新函数。当然也可以使用惰性函数来处理，本例最后一个方案会有所介绍。</p>
<p>我们看下面的这个例子，在 DOM 中添加事件时需要兼容现代浏览器和 IE 浏览器（IE &lt; 9），方法就是对浏览器环境进行判断，看浏览器是否支持，简化写法如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 简化写法</span><br><span class="line">function addEvent (type, el, fn, capture = false) &#123;</span><br><span class="line">    if (window.addEventListener) &#123;</span><br><span class="line">        el.addEventListener(type, fn, capture);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(window.attachEvent)&#123;</span><br><span class="line">        el.attachEvent(&apos;on&apos; + type, fn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">但是这种写法有一个问题，就是每次添加事件都会调用做一次判断，那么有没有什么办法只判断一次呢，可以利用闭包和立即调用函数表达式（IIFE）来处理。</span><br><span class="line"></span><br><span class="line">const addEvent = (function()&#123;</span><br><span class="line">    if (window.addEventListener) &#123;</span><br><span class="line">        return function (type, el, fn, capture) &#123;</span><br><span class="line">            el.addEventListener(type, fn, capture);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(window.attachEvent)&#123;</span><br><span class="line">        return function (type, el, fn) &#123;</span><br><span class="line">            el.attachEvent(&apos;on&apos; + type, fn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>上面这种实现方案就是一种典型的柯里化应用，在第一次的 if…else if… 判断之后完成部分计算，动态创建新的函数用于处理后续传入的参数，这样做的好处就是之后调用就不需要再次计算了。</p>
<p>当然可以使用惰性函数来实现这一功能，原理很简单，就是重写函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function addEvent (type, el, fn, capture = false) &#123;</span><br><span class="line">  	// 重写函数</span><br><span class="line">    if (window.addEventListener) &#123;</span><br><span class="line">        addEvent = function (type, el, fn, capture) &#123;</span><br><span class="line">            el.addEventListener(type, fn, capture);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(window.attachEvent)&#123;</span><br><span class="line">        addEvent = function (type, el, fn) &#123;</span><br><span class="line">            el.attachEvent(&apos;on&apos; + type, fn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  	// 执行函数，有循环爆栈风险</span><br><span class="line">  	addEvent(type, el, fn, capture); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一次调用 addEvent 函数后，会进行一次环境判断，在这之后 addEvent 函数被重写，所以下次调用时就不会再次判断环境，可以说很完美了。</p>
<p>3、参数复用<br>我们知道调用 toString() 可以获取每个对象的类型，但是不同对象的 toString() 有不同的实现，所以需要通过 Object.prototype.toString() 来获取 Object 上的实现，同时以 call() / apply() 的形式来调用，并传递要检查的对象作为第一个参数，例如下面这个例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function isArray(obj) &#123; </span><br><span class="line">    return Object.prototype.toString.call(obj) === &apos;[object Array]&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function isNumber(obj) &#123;</span><br><span class="line">    return Object.prototype.toString.call(obj) === &apos;[object Number]&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function isString(obj) &#123;</span><br><span class="line">    return Object.prototype.toString.call(obj) === &apos;[object String]&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Test</span><br><span class="line">isArray([1, 2, 3]); // true</span><br><span class="line">isNumber(123); // true</span><br><span class="line">isString(&apos;123&apos;); // true</span><br></pre></td></tr></table></figure>

<p>但是上面方案有一个问题，那就是每种类型都需要定义一个方法，这里我们可以使用 bind 来扩展，优点是可以直接使用改造后的 toStr。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const toStr = Function.prototype.call.bind(Object.prototype.toString);</span><br><span class="line"></span><br><span class="line">// 改造前</span><br><span class="line">[1, 2, 3].toString(); // &quot;1,2,3&quot;</span><br><span class="line">&apos;123&apos;.toString(); // &quot;123&quot;</span><br><span class="line">123.toString(); // SyntaxError: Invalid or unexpected token</span><br><span class="line">Object(123).toString(); // &quot;123&quot;</span><br><span class="line"></span><br><span class="line">// 改造后</span><br><span class="line">toStr([1, 2, 3]); 	// &quot;[object Array]&quot;</span><br><span class="line">toStr(&apos;123&apos;); 		// &quot;[object String]&quot;</span><br><span class="line">toStr(123); 		// &quot;[object Number]&quot;</span><br><span class="line">toStr(Object(123)); // &quot;[object Number]&quot;</span><br></pre></td></tr></table></figure>

<p>上面例子首先使用 Function.prototype.call 函数指定一个 this 值，然后 .bind 返回一个新的函数，始终将 Object.prototype.toString 设置为传入参数，其实等价于 Object.prototype.toString.call() 。</p>
<p>实现 currying 函数<br>我们可以理解所谓的柯里化函数，就是封装「一系列的处理步骤」，通过闭包将参数集中起来计算，最后再把需要处理的参数传进去。那如何实现 currying 函数呢？</p>
<p>实现原理就是「用闭包把传入参数保存起来，当传入参数的数量足够执行函数时，就开始执行函数」。上面延迟计算部分已经实现了一个简化版的 currying 函数。</p>
<p>下面我们来实现一个更加健壮的的 currying 函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 木易杨</span><br><span class="line">function currying(fn, length) &#123;</span><br><span class="line">  length = length || fn.length; 	// 注释 1</span><br><span class="line">  return function (...args) &#123;			// 注释 2</span><br><span class="line">    return args.length &gt;= length	// 注释 3</span><br><span class="line">    	? fn.apply(this, args)			// 注释 4</span><br><span class="line">      : currying(fn.bind(this, ...args), length - args.length) // 注释 5</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Test</span><br><span class="line">const fn = currying(function(a, b, c) &#123;</span><br><span class="line">    console.log([a, b, c]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fn(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">fn(&quot;a&quot;, &quot;b&quot;)(&quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">fn(&quot;a&quot;)(&quot;b&quot;)(&quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">fn(&quot;a&quot;)(&quot;b&quot;, &quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure>

<p>注释 1：第一次调用获取函数 fn 参数的长度，后续调用获取 fn 剩余参数的长度</p>
<p>注释 2：currying 包裹之后返回一个新函数，接收参数为 …args</p>
<p>注释 3：新函数接收的参数长度是否大于等于 fn 剩余参数需要接收的长度</p>
<p>注释 4：满足要求，执行 fn 函数，传入新函数的参数</p>
<p>注释 5：不满足要求，递归 currying 函数，新的 fn 为 bind 返回的新函数（bind 绑定了 …args 参数，未执行），新的 length 为 fn 剩余参数的长度</p>
<p>上面使用的是 ES5 和 ES6 的混合语法，那我不想使用 call/apply/bind 这些方法呢，自然是可以的，看下面的 ES6 极简写法，更加简洁也更加易懂。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 参考自 segmentfault 的@大笑平 </span><br><span class="line">const currying = fn =&gt;</span><br><span class="line">    judge = (...args) =&gt;</span><br><span class="line">        args.length &gt;= fn.length</span><br><span class="line">            ? fn(...args)</span><br><span class="line">            : (...arg) =&gt; judge(...args, ...arg)</span><br><span class="line"></span><br><span class="line">// Test</span><br><span class="line">const fn = currying(function(a, b, c) &#123;</span><br><span class="line">    console.log([a, b, c]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fn(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">fn(&quot;a&quot;, &quot;b&quot;)(&quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">fn(&quot;a&quot;)(&quot;b&quot;)(&quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="line">fn(&quot;a&quot;)(&quot;b&quot;, &quot;c&quot;) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure>

<p>如果你还无法理解，看完下面例子你就更加容易理解了，要求实现一个 add 方法，需要满足如下预期。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">add(1, 2, 3) // 6</span><br><span class="line">add(1, 2)(3) // 6</span><br><span class="line">add(1)(2)(3) // 6</span><br><span class="line">add(1)(2, 3) // 6</span><br></pre></td></tr></table></figure>

<p>我们可以看到，计算结果就是所有参数的和，如果我们分两次调用时 add(1)(2)，可以写出如下代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(a) &#123;</span><br><span class="line">  return function(b) &#123;</span><br><span class="line">  	return a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(1)(2) // 3</span><br></pre></td></tr></table></figure>

<p>add 方法第一次调用后返回一个新函数，通过闭包保存之前的参数，第二次调用时满足参数长度要求然后执行函数。</p>
<p>如果分三次调用时 add(1)(2)(3)，可以写出如下代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(a) &#123;</span><br><span class="line">  return function(b) &#123;</span><br><span class="line">    return function (c) &#123;</span><br><span class="line">    	return a + b + c;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(add(1)(2)(3)); // 6</span><br></pre></td></tr></table></figure>

<p>前面两次调用每次返回一个新函数，第三次调用后满足参数长度要求然后执行函数。</p>
<p>这时候我们再来看 currying 实现函数，其实就是判断当前参数长度够不够，参数够了就立马执行，不够就返回一个新函数，这个新函数并不执行，并且通过 bind 或者闭包保存之前传入的参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 注释同上</span><br><span class="line">function currying(fn, length) &#123;</span><br><span class="line">  length = length || fn.length; 	</span><br><span class="line">  return function (...args) &#123;			</span><br><span class="line">    return args.length &gt;= length	</span><br><span class="line">    	? fn.apply(this, args)			</span><br><span class="line">      : currying(fn.bind(this, ...args), length - args.length) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展：函数参数 length<br>函数 currying 的实现中，使用了 fn.length 来表示函数参数的个数，那 fn.length 表示函数的所有参数个数吗？并不是。</p>
<p>函数的 length 属性获取的是形参的个数，但是形参的数量不包括剩余参数个数，而且仅包括第一个具有默认值之前的参数个数，看下面的例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">((a, b, c) =&gt; &#123;&#125;).length; </span><br><span class="line">// 3</span><br><span class="line"></span><br><span class="line">((a, b, c = 3) =&gt; &#123;&#125;).length; </span><br><span class="line">// 2 </span><br><span class="line"></span><br><span class="line">((a, b = 2, c) =&gt; &#123;&#125;).length; </span><br><span class="line">// 1 </span><br><span class="line"></span><br><span class="line">((a = 1, b, c) =&gt; &#123;&#125;).length; </span><br><span class="line">// 0 </span><br><span class="line"></span><br><span class="line">((...args) =&gt; &#123;&#125;).length; </span><br><span class="line">// 0</span><br><span class="line"></span><br><span class="line">const fn = (...args) =&gt; &#123;</span><br><span class="line">  console.log(args.length);</span><br><span class="line">&#125; </span><br><span class="line">fn(1, 2, 3)</span><br><span class="line">// 3</span><br></pre></td></tr></table></figure>

<p>所以在柯里化的场景中，不建议使用 ES6 的函数参数默认值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const fn = currying((a = 1, b, c) =&gt; &#123;</span><br><span class="line">  console.log([a, b, c]); </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">fn();</span><br><span class="line">// [1, undefined, undefined]</span><br><span class="line"></span><br><span class="line">fn()(2)(3); </span><br><span class="line">// Uncaught TypeError: fn(...) is not a function</span><br></pre></td></tr></table></figure>

<p>我们期望函数 fn 输出 [1, 2, 3]，但是实际上调用柯里化函数时 ((a = 1, b, c) =&gt; {}).length === 0，所以调用 fn() 时就已经执行并输出了 [1, undefined, undefined]，而不是理想中的返回闭包函数，所以后续调用 fn()(2)(3) 将会报错。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们通过定义认识了什么是柯里化函数，并且介绍了三种实际的应用场景：延迟计算、动态创建函数、参数复用，然后实现了强大的通用化 currying 函数，不过更像是柯里化 (currying) 和偏函数 (partial application) 的综合应用，并且在最后介绍了函数的 length，算是意外之喜。</p>
<h5 id="定义：柯里化是一种将使用多个参数的函数转换成一系列使用一个参数的函数，并且返回接受余下的参数而且返回结果的新函数的技术"><a href="#定义：柯里化是一种将使用多个参数的函数转换成一系列使用一个参数的函数，并且返回接受余下的参数而且返回结果的新函数的技术" class="headerlink" title="定义：柯里化是一种将使用多个参数的函数转换成一系列使用一个参数的函数，并且返回接受余下的参数而且返回结果的新函数的技术"></a>定义：柯里化是一种将使用多个参数的函数转换成一系列使用一个参数的函数，并且返回接受余下的参数而且返回结果的新函数的技术</h5><h5 id="实际应用-1"><a href="#实际应用-1" class="headerlink" title="实际应用"></a>实际应用</h5><ul>
<li>延迟计算：部分求和、bind 函数</li>
<li>动态创建函数：添加监听 addEvent、惰性函数</li>
<li>参数复用：Function.prototype.call.bind(Object.prototype.toString)</li>
</ul>
<h5 id="实现-currying-函数：用闭包把传入参数保存起来，当传入参数的数量足够执行函数时，就开始执行函数"><a href="#实现-currying-函数：用闭包把传入参数保存起来，当传入参数的数量足够执行函数时，就开始执行函数" class="headerlink" title="实现 currying 函数：用闭包把传入参数保存起来，当传入参数的数量足够执行函数时，就开始执行函数"></a>实现 currying 函数：用闭包把传入参数保存起来，当传入参数的数量足够执行函数时，就开始执行函数</h5><h5 id="函数参数-length：获取的是形参的个数，但是形参的数量不包括剩余参数个数，而且仅包括第一个具有默认值之前的参数个数"><a href="#函数参数-length：获取的是形参的个数，但是形参的数量不包括剩余参数个数，而且仅包括第一个具有默认值之前的参数个数" class="headerlink" title="函数参数 length：获取的是形参的个数，但是形参的数量不包括剩余参数个数，而且仅包括第一个具有默认值之前的参数个数"></a>函数参数 length：获取的是形参的个数，但是形参的数量不包括剩余参数个数，而且仅包括第一个具有默认值之前的参数个数</h5>]]></content>
      <categories>
        <category>函数柯里化</category>
      </categories>
      <tags>
        <tag>函数柯里化</tag>
      </tags>
  </entry>
  <entry>
    <title>探究Hybrid-APP技术原理</title>
    <url>/2019/05/24/%E6%8E%A2%E7%A9%B6Hybrid-APP%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>探究Hybrid-APP技术原理<br>author: <a href="https://tiffanysbear.github.io/" target="_blank" rel="noopener">@TiffanysBear</a></p>
</blockquote>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>随着Web技术的发展和移动互联网的发展，Hybrid技术已经成为一种前端开发的主流技术方案。那什么是Hybrid App呢？</p>
<blockquote>
<p>Hybrid App（混合模式移动应用）是指介于web-app、native-app这两者之间的app，兼具” Native App良好用户交互体验的优势 “和” Web App跨平台开发的优势 “。</p>
</blockquote>
<p>总的来说，就是既具有APP的体验和性能，又具有Web灵活的开发模式和跨平台开发能力。</p>
<a id="more"></a>

<h2 id="现有的技术方案"><a href="#现有的技术方案" class="headerlink" title="现有的技术方案"></a>现有的技术方案</h2><p>1、H5 + JSBridge，通过JSBridge完成H5和Native的通信，赋予H5一定的端能力。是一种基于WebView UI的解决方案。</p>
<p>2、React-Native，进一步通过JSbridge将js解析为虚拟DOM传递到Native，并使用原生进行渲染。</p>
<p>3、小程序解决方案，采用双线程的渲染机制，将渲染层WebView和逻辑层JavaScriptCore形成独立的模块，通过Native进行通信（setData），逻辑层的网络请求也会由Native进行转发。在UI方面，采用的是WebView和原生相结合的方式。</p>
<h2 id="技术原理"><a href="#技术原理" class="headerlink" title="技术原理"></a>技术原理</h2><p>本文将从jsbridge的原理、实现、双向通信、接入方式和H5的嵌入方式进行详细阐述。</p>
<h3 id="jsbridge的原理"><a href="#jsbridge的原理" class="headerlink" title="jsbridge的原理"></a>jsbridge的原理</h3><p>客户端能对WebView中请求进行拦截，都有相应的API：</p>
<p>Android:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Android: shouldoverrideurlloading </span></span><br><span class="line">public boolean shouldOverrideUrlLoading(WebView view, <span class="built_in">String</span> url)&#123;</span><br><span class="line">	<span class="comment">//读取到url后自行进行分析处理</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//如果返回false，则WebView处理链接url，如果返回true，代表WebView根据程序来执行url</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IOS:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IOS: shouldStartLoadWithRequest </span></span><br><span class="line">- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType &#123;</span><br><span class="line">    NSURL *url = [request URL];</span><br><span class="line">     </span><br><span class="line">    NSString *requestString = [[request URL] absoluteString];</span><br><span class="line">    <span class="comment">//获取url scheme后自行进行处理</span></span><br></pre></td></tr></table></figure>

<p>因此，在页面中可以通过iframe加载src的方式触发相应的捕获函数，在捕获函数中可以对url中的参数进行解析；此外，Android还可以通过重写OnJSPrompt方法，对调用Prompt进行拦截，同样能实现通信的目的。</p>
<p>示例：<br>调起ios端：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iosInvoke</span>(<span class="params">scheme</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> elem = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">    <span class="keyword">var</span> body = <span class="built_in">document</span>.body || <span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>];</span><br><span class="line">    elem.style.display = <span class="string">'none'</span>;</span><br><span class="line">    elem.src = scheme;</span><br><span class="line">    body.appendChild(elem);</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        body.removeChild(elem);</span><br><span class="line">        elem = <span class="literal">null</span>;</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调起android端：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">androidInvoke</span>(<span class="params">scheme</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> androidJsBridge = <span class="built_in">window</span>.Bdbox_android_jsbridge;</span><br><span class="line">    <span class="keyword">if</span> (androidJsBridge &amp;&amp; androidJsBridge.dispatch) &#123;</span><br><span class="line">        androidJsBridge.dispatch(scheme);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> re = <span class="built_in">window</span>.prompt(<span class="string">'BdboxApp:'</span> + <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">            obj: <span class="string">'Bdbox_android_jsbridge'</span>,</span><br><span class="line">            func: <span class="string">'dispatch'</span>,</span><br><span class="line">            args: [scheme]</span><br><span class="line">        &#125;));</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="协议制定URL-Scheme"><a href="#协议制定URL-Scheme" class="headerlink" title="协议制定URL Scheme"></a>协议制定URL Scheme</h3><p>URL Scheme是什么</p>
<blockquote>
<p>由于苹果的app都是在沙盒中，相互是不能访问数据的。但是苹果还是给出了一个可以在app之间跳转的方法：URL Scheme。简单的说，URL Scheme就是一个可以让app相互之间可以跳转的协议。每个app的URL Scheme都是不一样的，如果存在一样的URL Scheme，那么系统就会响应先安装那个app的URL Scheme，因为后安装的app的URL Scheme被覆盖掉了，是不能被调用的。</p>
</blockquote>
<p>设置URL Scheme</p>
<blockquote>
<p>xxxapp://communication?args=xx</p>
</blockquote>
<h3 id="如何进行双向通信"><a href="#如何进行双向通信" class="headerlink" title="如何进行双向通信"></a>如何进行双向通信</h3><p>双向通信主要是H5和Native的双向通信过程以及参数传递、回调执行。</p>
<h4 id="H5通知Native："><a href="#H5通知Native：" class="headerlink" title="H5通知Native："></a>H5通知Native：</h4><p>H5通知Native的方式主要有：</p>
<ul>
<li>调用prompt/console/alert，调用时进行参数传递，端进行拦截重写</li>
<li>URL Scheme跳转拦截，将参数放在请求URL上，详细的文章介绍 <a href="https://www.jianshu.com/p/eed01a661186" target="_blank" rel="noopener">URL Scheme</a></li>
<li>API挂载，通过Navtive获取js执行环境，将相应的api挂载在js上，供h5调用</li>
</ul>
<h4 id="Native通知H5："><a href="#Native通知H5：" class="headerlink" title="Native通知H5："></a>Native通知H5：</h4><ul>
<li>回调机制，在向Native传递信息时，将回调函数也传递，Native在调用完成后，使用js执行环境执行回调函数</li>
</ul>
<h3 id="接入方式"><a href="#接入方式" class="headerlink" title="接入方式"></a>接入方式</h3><ul>
<li>jsbridge的接入，端方面的jsbridge和h5方面的jsbridge</li>
</ul>
<h3 id="嵌入方式"><a href="#嵌入方式" class="headerlink" title="嵌入方式"></a>嵌入方式</h3><p>h5的嵌入方式:</p>
<ul>
<li>直接代码，直接将H5代码css、html、js放入端目录下，以file协议的方式访问，优点是访问快速，缺点是迭代不方便。</li>
<li>线上地址，以http协议访问，使用webview打开url形式，相较于代码嵌入的方式来说，速度比较慢，依赖网络传输速度；优点是迭代快速</li>
</ul>
]]></content>
      <categories>
        <category>Hybrid-APP</category>
      </categories>
      <tags>
        <tag>Hybrid-APP技术</tag>
      </tags>
  </entry>
  <entry>
    <title>getBoundingClientRect使用指南</title>
    <url>/2019/05/22/getBoundingClientRect%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<blockquote>
<p>getBoundingClientRect使用指南<br>author: @TiffanysBear</p>
</blockquote>
<p>主要介绍getBoundingClientRect的基本属性，以及具体的使用场景和一些需要注意的问题。</p>
<h3 id="getBoundingClientRect"><a href="#getBoundingClientRect" class="headerlink" title="getBoundingClientRect"></a>getBoundingClientRect</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Element.getBoundingClientRect()</span><br></pre></td></tr></table></figure>

<p>含义：<br>方法返回元素的大小及其相对于视口的位置。</p>
<p>值：<br>返回值是一个 DOMRect 对象，这个对象是由该元素的 getClientRects() 方法返回的一组矩形的集合, 即：是与该元素相关的CSS 边框集合。</p>
<a id="more"></a>

<p>属性值：</p>
<ul>
<li>top: 元素上边距离页面上边的距离</li>
<li>left: 元素右边距离页面左边的距离</li>
<li>right: 元素右边距离页面左边的距离</li>
<li>bottom: 元素下边距离页面上边的距离</li>
<li>width: 元素宽度</li>
<li>height: 元素高度</li>
</ul>
<p><img src="https://github.com/Tiffanysbear/accumulation/raw/master/image/gbcr.png" alt="图片一"></p>
<p>注意：<br>如果所有的元素边框都是空边框，那么这个矩形给该元素返回的 width、height 值为0，left、top值为第一个css盒子（按内容顺序）的top-left值。</p>
<p>当计算边界矩形时，会考虑视口区域（或其他可滚动元素）内的滚动操作，也就是说，当滚动位置发生了改变，top和left属性值就会随之立即发生变化（因此，它们的值是相对于视口的，而不是绝对的）。如果你需要获得相对于整个网页左上角定位的属性值，那么只要给top、left属性值加上当前的滚动位置（通过window.scrollX和window.scrollY），这样就可以获取与当前的滚动位置无关的值。</p>
<p><img src="https://github.com/Tiffanysbear/accumulation/raw/master/image/gbcr-2.png" alt="图片二"></p>
<p>如图所示：<br>当页面的元素在浏览器的左上角时，得到的top和left值为负值，right和bottom值为正值。</p>
<h3 id="应用场景一"><a href="#应用场景一" class="headerlink" title="应用场景一"></a>应用场景一</h3><h4 id="1、获取dom元素相对于网页左上角定位的距离"><a href="#1、获取dom元素相对于网页左上角定位的距离" class="headerlink" title="1、获取dom元素相对于网页左上角定位的距离"></a>1、获取dom元素相对于网页左上角定位的距离</h4><p>以前的写法是通过offsetParent找到元素到定位父级元素，直至递归到顶级元素body或html。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取dom元素相对于网页左上角定位的距离</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">offset</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> top = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 获取元素的位置还有getBoundingClientRect的方法</span></span><br><span class="line">    <span class="comment">// 从网上得知offset的兼容较差而且设置translate3D的y轴值给元素定位了y轴的距离后</span></span><br><span class="line">    <span class="comment">//会出现offsetTop为0</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        top += el.offsetTop;</span><br><span class="line">        left += el.offsetLeft;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(el = el.offsetParent);<span class="comment">// 存在兼容性问题，需要兼容</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        top: top,</span><br><span class="line">        left: left</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> odiv = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'markdown-body'</span>);</span><br><span class="line">offset(a[<span class="number">0</span>]); <span class="comment">// &#123;top: 271, left: 136&#125;</span></span><br></pre></td></tr></table></figure>

<p>现在根据getBoundingClientRect这个api，可以写成这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> positionX = <span class="keyword">this</span>.getBoundingClientRect().left + <span class="built_in">document</span>.documentElement.scrollLeft;</span><br><span class="line"><span class="keyword">var</span> positionY = <span class="keyword">this</span>.getBoundingClientRect().top + <span class="built_in">document</span>.documentElement.scrollLeft;</span><br></pre></td></tr></table></figure>

<h3 id="应用场景二"><a href="#应用场景二" class="headerlink" title="应用场景二"></a>应用场景二</h3><h4 id="2、判断元素是否在可视区域内"><a href="#2、判断元素是否在可视区域内" class="headerlink" title="2、判断元素是否在可视区域内"></a>2、判断元素是否在可视区域内</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isElView</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> top = el.getBoundingClientRect().top; <span class="comment">// 元素顶端到可见区域顶端的距离</span></span><br><span class="line">    <span class="keyword">var</span> bottom = el.getBoundingClientRect().bottom; <span class="comment">// 元素底部端到可见区域顶端的距离</span></span><br><span class="line">    <span class="keyword">var</span> se = <span class="built_in">document</span>.documentElement.clientHeight; <span class="comment">// 浏览器可见区域高度。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (top &lt; se &amp;&amp; bottom &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (top &gt;= se || bottom &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 不可见</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>这个属性频繁计算会引发页面的重绘，可能会对页面的性能造成影响。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>getBoundingClientRect</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6-Proxy</title>
    <url>/2019/05/22/ES6-Proxy/</url>
    <content><![CDATA[<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><h3 id="1、使用proxy扩展构造函数"><a href="#1、使用proxy扩展构造函数" class="headerlink" title="1、使用proxy扩展构造函数"></a>1、使用proxy扩展构造函数</h3><blockquote>
<p>Proxy参数说明：<br>target：<br>用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。<br>handler：<br>一个对象，其属性是当执行一个操作时定义代理的行为的函数。</p>
</blockquote>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">sup,base</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(</span><br><span class="line">    base.prototype,<span class="string">"constructor"</span></span><br><span class="line">  );</span><br><span class="line">  base.prototype = <span class="built_in">Object</span>.create(sup.prototype);</span><br><span class="line">  <span class="keyword">var</span> handler = &#123;</span><br><span class="line">    construct: <span class="function"><span class="keyword">function</span>(<span class="params">target, args</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(base.prototype);</span><br><span class="line">      <span class="keyword">this</span>.apply(target,obj,args);<span class="comment">// 13行、14行</span></span><br><span class="line">      <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;,</span><br><span class="line">    apply: <span class="function"><span class="keyword">function</span>(<span class="params">target, that, args</span>) </span>&#123;</span><br><span class="line">      sup.apply(that,args);</span><br><span class="line">      base.apply(that,args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(base,handler);</span><br><span class="line">  descriptor.value = proxy;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(base.prototype, <span class="string">"constructor"</span>, descriptor);</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Boy = extend(Person, <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Boy.prototype.sex = <span class="string">"M"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Peter = <span class="keyword">new</span> Boy(<span class="string">"Peter"</span>, <span class="number">13</span>); <span class="comment">// new时开始执行handler的constructor</span></span><br><span class="line"><span class="built_in">console</span>.log(Peter.sex);  <span class="comment">// "M"</span></span><br><span class="line"><span class="built_in">console</span>.log(Peter.name); <span class="comment">// "Peter"</span></span><br><span class="line"><span class="built_in">console</span>.log(Peter.age);  <span class="comment">// 13</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。<br>apply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。</p>
</blockquote>
<p>因此，根据proxy的特性，可以实现拦截器的功能，其中，proxy支持的拦截操作一共有13种，如下2所示。</p>
<h3 id="支持的操作"><a href="#支持的操作" class="headerlink" title="支持的操作"></a>支持的操作</h3><h4 id="Proxy支持的拦截操作有以下13种"><a href="#Proxy支持的拦截操作有以下13种" class="headerlink" title="Proxy支持的拦截操作有以下13种"></a>Proxy支持的拦截操作有以下13种</h4><blockquote>
<ul>
<li>get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。</li>
<li>set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。</li>
<li>has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。</li>
<li>deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。</li>
<li>ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。</li>
<li>getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。</li>
<li>defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey,<br>propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。</li>
<li>preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。</li>
<li>getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。</li>
<li>isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。</li>
<li>setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li>
<li>apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object,<br>…args)、proxy.apply(…)。</li>
<li>construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。</li>
</ul>
</blockquote>
<p>具体的拦截方法的详细使用，<a href="http://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="noopener">点击查看13种拦截方法详解</a>。</p>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript编写高质量的68个有效方法</title>
    <url>/2019/05/21/JavaScript%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%8468%E4%B8%AA%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>Effective JavaScript编写高质量的68个有效方法<br>author：@Tiffanysbear<br>description: 读书笔记</p>
</blockquote>
<h3 id="第一条：了解你使用的javascript"><a href="#第一条：了解你使用的javascript" class="headerlink" title="第一条：了解你使用的javascript"></a>第一条：了解你使用的javascript</h3><ol>
<li>严格模式<code>use strict</code></li>
</ol>
<ul>
<li>不允许重定义arguments变量</li>
<li>只有在脚本或函数的顶部才生效</li>
<li>不要将进行严格模式检查的代码和非严格模式的代码进行打包压缩</li>
<li>可通过立即调用函数隔离严格与非严格区域，单独隔离作用域</li>
<li>编写库时，开启严格检查，兼容性更强</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">	"use strict"</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="comment">// code</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="第二条：理解js浮点数"><a href="#第二条：理解js浮点数" class="headerlink" title="第二条：理解js浮点数"></a>第二条：理解js浮点数</h3><ol>
<li>位运算会将数字转换为32位大端的2的补码表示的整数，8表示为0000 0000 0000 0000 0000 0000 0000 1000，可通过(8).toString(2) // ‘1000’，指定基数进行转换</li>
<li>0.1 + 0.2 不等于0.3</li>
<li>整数运算，计算只适用于$$(-2)^{53} - 2^{53}$$</li>
</ol>
<h3 id="第三条：隐式转换"><a href="#第三条：隐式转换" class="headerlink" title="第三条：隐式转换"></a>第三条：隐式转换</h3><ol>
<li><p>3 + true // 4</p>
</li>
<li><p>“2” + 3 // “23”</p>
</li>
<li><p>2 + “3” // “23”</p>
</li>
<li><p>1 + “2” + 3 // “123”</p>
</li>
<li><p>“17” * 3 // 51</p>
</li>
<li><p>x === NaN // false</p>
</li>
<li><p>对象的隐式转换，会调用自身的toString()转换为字符串或者valueOf()方法转换为数字，问题就在于调用这两个方法的优先级。具有vauleOf方法的对象应该实现toString方法，返回一个valueOf方法产生的数字字符串表示。</p>
<ul>
<li>存在toString方法，就调用toString方法</li>
<li>存在valueOf方法，就调用valueOf方法</li>
<li>同时存在toString、valueOf方法，优先调用valueOf方法</li>
</ul>
</li>
</ol>
<ol start="8">
<li>真值转换，js中有7个假值：false、0、-0、””、NaN、null、undefined</li>
<li>检测一个值是否是未定义的值，应该使用typeof或者与undefined进行比较，而不是直接if(!x)</li>
</ol>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Effective JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>九宫格布局</title>
    <url>/2019/05/21/%E4%B9%9D%E5%AE%AB%E6%A0%BC%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<blockquote>
<p>九宫格布局<br>author: @TiffanysBear</p>
</blockquote>
<h3 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h3><p>高考活动页面需要在一个页面容器中，实现一个两行三列宽度自适应缩放，且图片等比例缩放，随着浏览器宽度进行自适应缩放的布局。<br>中间的图片需要自适应，随着页面宽度的变化，三等分缩放，图片等比例缩放。<a href="https://tiku.baidu.com/topic/gaokao2019/zhenti" target="_blank" rel="noopener">页面地址</a></p>
<a id="more"></a>

<p><img src="https://github.com/Tiffanysbear/accumulation/raw/master/image/jing-1.png" alt="GitHub" title="GitHub,Social Coding"><br><img src="https://github.com/Tiffanysbear/accumulation/raw/master/image/jing-2.png" alt="GitHub" title="GitHub,Social Coding"></p>
<h3 id="解决办法一：flex布局-padding-bottom"><a href="#解决办法一：flex布局-padding-bottom" class="headerlink" title="解决办法一：flex布局 + padding-bottom"></a>解决办法一：flex布局 + padding-bottom</h3><p>解决思路：</p>
<ol>
<li>使用flex弹性布局，使子元素成为容器成员</li>
<li>父元素使用flex-wrap: wrap;将flex 元素 被打断到多个行中</li>
</ol>
<blockquote>
<p><strong>CSS flex-wrap</strong> 指定 flex 元素单行显示还是多行显示 。如果允许换行，这个属性允许你控制行的堆叠方向。取值如下：<br><strong>nowrap</strong><br>flex 的元素被摆放到到一行，这可能导致溢出 flex 容器。 cross-start  会根据 flex-direction 的值 相当于 start 或 before。<br><strong>wrap</strong><br>flex 元素 被打断到多个行中。cross-start 会根据 flex-direction 的值选择等于start 或before。cross-end 为确定的 cross-start 的另一端。<br><strong>wrap-reverse</strong><br>和 wrap 的行为一样，但是 cross-start 和 cross-end 互换。</p>
</blockquote>
<p>3、巧妙使用padding-bottom，为子元素设置高度</p>
<blockquote>
<p><strong>padding-bottom</strong> 属性设置元素的下内边距（底部空白），因为padding-bottom计算的基准值是以父元素的宽度来进行的。<br>该属性设置元素下内边距的宽度。行内非替换元素上设置的下内边距不会影响行高计算，因此，如果一个元素既有内边距又有背景，从视觉上看可能延伸到其他行，有可能还会与其他内容重叠。不允许指定负内边距值。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>length</td>
<td>规定以具体单位计的固定的下内边距值，比如像素、厘米等。默认值是 0px。</td>
</tr>
<tr>
<td>%</td>
<td>定义基于父元素宽度的百分比下内边距</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应该从父元素继承下内边距</td>
</tr>
</tbody></table>
</blockquote>
<p>html结构如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"wrap"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"item"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"item"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"item"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"item"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"item"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"item"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"item"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"item"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"item"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p>css结构如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.wrap &#123;</span><br><span class="line">    width: <span class="number">100</span>%;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-wrap: wrap;</span><br><span class="line">&#125;</span><br><span class="line">.item &#123;</span><br><span class="line">    width: <span class="number">33.3</span>%;</span><br><span class="line">    padding-bottom: <span class="number">33.3</span>%;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加上一些可以区分的背景和线框之后如图：</p>
<p><img src="https://github.com/Tiffanysbear/accumulation/raw/master/image/jing-3.png" alt="GitHub" title="GitHub,Social Coding"><br><img src="https://github.com/Tiffanysbear/accumulation/raw/master/image/jing-4.png" alt="GitHub" title="GitHub,Social Coding"></p>
<p>随着页面的缩放，始终未三等份。</p>
<h3 id="解决办法二：使用网格grid布局"><a href="#解决办法二：使用网格grid布局" class="headerlink" title="解决办法二：使用网格grid布局"></a>解决办法二：使用网格grid布局</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.father &#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    padding-bottom: 100%;</span><br><span class="line">    display: grid;</span><br><span class="line">    grid-template-rows: repeat(3, 33.3%);</span><br><span class="line">    grid-template-columns: repeat(3, 33.3%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解决办法三：使用table-cell布局"><a href="#解决办法三：使用table-cell布局" class="headerlink" title="解决办法三：使用table-cell布局"></a>解决办法三：使用table-cell布局</h3><p>div结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;father&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;table-row&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    </span><br><span class="line">   &lt;div class=&quot;table-row&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;table-row&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>css样式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.father &#123;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    display: table;</span><br><span class="line">    background: pink;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">.item &#123;</span><br><span class="line">    display: table-cell;</span><br><span class="line">&#125;</span><br><span class="line">.table-row &#123;</span><br><span class="line">    display: table-row;</span><br><span class="line">    width: 300px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解决办法四：使用table表格布局"><a href="#解决办法四：使用table表格布局" class="headerlink" title="解决办法四：使用table表格布局"></a>解决办法四：使用table表格布局</h3>]]></content>
      <categories>
        <category>HTML &amp;&amp; CSS</category>
      </categories>
      <tags>
        <tag>自适应布局</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令学习</title>
    <url>/2019/05/21/Linux%E5%91%BD%E4%BB%A4%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<blockquote>
<p>每天学习一个命令<br>author: @Tiffanysbear </p>
</blockquote>
<p>1、mkdir：新建文件夹</p>
<p>2、mv：移动或者重命名文件，用来为文件或目录改名、或将文件或目录移入其它位置。</p>
<pre><code>- mv source dest</code></pre><a id="more"></a>

<p>3、tar: <a href="https://www.runoob.com/linux/linux-comm-tar.html" target="_blank" rel="noopener">tar命令</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-A或--catenate：新增文件到以存在的备份文件；</span><br><span class="line">-B：设置区块大小；</span><br><span class="line">-c或--create：建立新的备份文件；</span><br><span class="line">-C &lt;目录&gt;：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。</span><br><span class="line">-d：记录文件的差别；</span><br><span class="line">-x或--extract或--get：从备份文件中还原文件；</span><br><span class="line">-t或--list：列出备份文件的内容；</span><br><span class="line">-z或--gzip或--ungzip：通过gzip指令处理备份文件；</span><br><span class="line">-Z或--compress或--uncompress：通过compress指令处理备份文件；</span><br><span class="line">-f&lt;备份文件&gt;或--file=&lt;备份文件&gt;：指定备份文件；</span><br><span class="line">-v或--verbose：显示指令执行过程；</span><br><span class="line">-r：添加文件到已经压缩的文件；</span><br><span class="line">-u：添加改变了和现有的文件到已经存在的压缩文件；</span><br><span class="line">-j：支持bzip2解压文件；</span><br><span class="line">-v：显示操作过程；</span><br><span class="line">-l：文件系统边界设置；</span><br><span class="line">-k：保留原有文件不覆盖；</span><br><span class="line">-m：保留文件不被覆盖；</span><br><span class="line">-w：确认压缩文件的正确性；</span><br><span class="line">-p或--same-permissions：用原来的文件权限还原文件；</span><br><span class="line">-P或--absolute-names：文件名使用绝对名称，不移除文件名称前的“/”号；</span><br><span class="line">-N &lt;日期格式&gt; 或 --newer=&lt;日期时间&gt;：只将较指定日期更新的文件保存到备份文件里；</span><br><span class="line">--exclude=&lt;范本样式&gt;：排除符合范本样式的文件。</span><br></pre></td></tr></table></figure>

<p>常用的tar命令有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01-.tar格式</span><br><span class="line">解包：[＊＊＊＊＊＊＊]$ tar xvf FileName.tar</span><br><span class="line">打包：[＊＊＊＊＊＊＊]$ tar cvf FileName.tar DirName（注：tar是打包，不是压缩！）</span><br><span class="line"></span><br><span class="line">02-.gz格式</span><br><span class="line">解压1：[＊＊＊＊＊＊＊]$ gunzip FileName.gz</span><br><span class="line">解压2：[＊＊＊＊＊＊＊]$ gzip -d FileName.gz</span><br><span class="line">压 缩：[＊＊＊＊＊＊＊]$ gzip FileName</span><br><span class="line"></span><br><span class="line">03-.tar.gz格式</span><br><span class="line">解压：[＊＊＊＊＊＊＊]$ tar zxvf FileName.tar.gz</span><br><span class="line">压缩：[＊＊＊＊＊＊＊]$ tar zcvf FileName.tar.gz DirName</span><br><span class="line"></span><br><span class="line">04-.bz2格式</span><br><span class="line">解压1：[＊＊＊＊＊＊＊]$ bzip2 -d FileName.bz2</span><br><span class="line">解压2：[＊＊＊＊＊＊＊]$ bunzip2 FileName.bz2</span><br><span class="line">压 缩： [＊＊＊＊＊＊＊]$ bzip2 -z FileName</span><br><span class="line"></span><br><span class="line">05-.tar.bz2格式</span><br><span class="line">解压：[＊＊＊＊＊＊＊]$ tar jxvf FileName.tar.bz2</span><br><span class="line">压缩：[＊＊＊＊＊＊＊]$ tar jcvf FileName.tar.bz2 DirName</span><br><span class="line"></span><br><span class="line">06-.bz格式</span><br><span class="line">解压1：[＊＊＊＊＊＊＊]$ bzip2 -d FileName.bz</span><br><span class="line">解压2：[＊＊＊＊＊＊＊]$ bunzip2 FileName.bz</span><br><span class="line"></span><br><span class="line">07-.tar.bz格式</span><br><span class="line">解压：[＊＊＊＊＊＊＊]$ tar jxvf FileName.tar.bz</span><br><span class="line"></span><br><span class="line">08-.Z格式</span><br><span class="line">解压：[＊＊＊＊＊＊＊]$ uncompress FileName.Z</span><br><span class="line">压缩：[＊＊＊＊＊＊＊]$ compress FileName</span><br><span class="line"></span><br><span class="line">09-.tar.Z格式</span><br><span class="line">解压：[＊＊＊＊＊＊＊]$ tar Zxvf FileName.tar.Z</span><br><span class="line">压缩：[＊＊＊＊＊＊＊]$ tar Zcvf FileName.tar.Z DirName</span><br><span class="line"></span><br><span class="line">10-.tgz格式</span><br><span class="line">解压：[＊＊＊＊＊＊＊]$ tar zxvf FileName.tgz</span><br><span class="line"></span><br><span class="line">11-.tar.tgz格式</span><br><span class="line">解压：[＊＊＊＊＊＊＊]$ tar zxvf FileName.tar.tgz</span><br><span class="line">压缩：[＊＊＊＊＊＊＊]$ tar zcvf FileName.tar.tgz FileName</span><br><span class="line"></span><br><span class="line">12-.zip格式</span><br><span class="line">解压：[＊＊＊＊＊＊＊]$ unzip FileName.zip</span><br><span class="line">压缩：[＊＊＊＊＊＊＊]$ zip FileName.zip DirName</span><br><span class="line"></span><br><span class="line">13-.lha格式</span><br><span class="line">解压：[＊＊＊＊＊＊＊]$ lha -e FileName.lha</span><br><span class="line">压缩：[＊＊＊＊＊＊＊]$ lha -a FileName.lha FileName</span><br><span class="line"></span><br><span class="line">14-.rar格式</span><br><span class="line">解压：[＊＊＊＊＊＊＊]$ rar a FileName.rar</span><br><span class="line">压缩：[＊＊＊＊＊＊＊]$ rar e FileName.rar</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端吸顶fixbar解决方案</title>
    <url>/2019/05/21/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%90%B8%E9%A1%B6fixbar%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><blockquote>
<p>经常会有这样的需求，当页面滚动到某一个位置时，需要某个页面元素固定在屏幕顶部，并且有时需要连续滚动吸顶。在PC端主要的实现是通过 CSS 的 position: fixed 属性，但是在移动端，尤其是在安卓端，存在诸多的兼容性问题。 </p>
</blockquote>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>position：fixed给移动端带来的问题： </p>
<ul>
<li>IOS8在页面滚动时，吸顶不连续；页面滑动时，不见吸顶，页面滚动停止后，吸顶缓慢出现</li>
<li>滚动到顶部之后，会出现两个一样的吸顶, 过一会才恢复正常。</li>
<li>footer底部输入框 focus 状态，footer 底部输入框被居中，而不是吸附在软键盘上部。</li>
<li>iPhone 4s&amp;5 / iOS 6&amp;7 / Safari 下，页面底部footer输入框失去焦点时，header定位出错。当页面有滚动动作时，header定位恢复正常。</li>
<li>iPhone 4 / iOS 5 / Safari下，当页面发生跳转，再退回时，fixed区域消失，当内容获得焦点时，fixed区域才显示。</li>
<li>安卓低版本／自带浏览器，不支持fixed属性，iOS4 也是不支持 fixed 的。</li>
<li>三星i9100(S2) / 自带浏览器，在滚屏过程中，fixed定位异常，touchend之后恢复正常。</li>
<li>部分低版本Android对支持不好，video poster属性设置的封面图会遮挡fixed元素。</li>
<li>QQ、UC浏览器滚动页面时footer定位错误，会往上偏移，是由于地址栏收起的缘故。</li>
<li><font color="red">*remind：不要在 fixed 元素中使用 input / textarea 元素。</font></li>
</ul>
<a id="more"></a>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>分别处理各个问题：</p>
<h3 id="IOS"><a href="#IOS" class="headerlink" title="IOS"></a>IOS</h3><p>在IOS端，使用 position： sticky  这个属性，使用类似于 position: relative 和  position: absolute 的结合体。在目标区域在屏幕中可见时，它的行为就像position:relative; 而当页面滚动超出目标区域时，它的表现就像position:fixed，它会固定在目标位置。</p>
<p> 使用时，需要加上私有前缀</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">position: -webkit-sticky;</span><br><span class="line">position: -moz-sticky;</span><br><span class="line">position: -ms-sticky;</span><br><span class="line">position: sticky;</span><br></pre></td></tr></table></figure>


<p>对于 position：sticky 的使用，需要注意很多的细节，sticky满足以下条件才能生效：</p>
<p>1、具有sticky属性的元素，其父级高度必须大于sticky元素的高度。</p>
<p>2、sticky元素的底部，不能和父级底部重叠。（这条不好表述，文后详细说明）</p>
<p>3、sticky元素的父级不能含有overflow:hidden 和 overflow:auto 属性</p>
<p>4、必须具有top，或 bottom 属性。</p>
<p>同时要注意，sticky元素仅在他父级容器内有效，超出容器范围则不再生效了。</p>
<h3 id="安卓"><a href="#安卓" class="headerlink" title="安卓"></a>安卓</h3><p>滚动距离超过某位置时，js动态设置样式；为了防止惯性滚动引起的fix不及时的情况，在 touchstart、 touchmove 、 touchend 事件都进行监听。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意处理遮罩层的位置</span></span><br><span class="line">   <span class="keyword">var</span> scrollHandler = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (topLength &lt; me.getScrollTop()) &#123;</span><br><span class="line">           target.css(<span class="string">'position'</span>, <span class="string">'fixed'</span>);</span><br><span class="line">           me.replaceEle.show();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           target.css(<span class="string">'position'</span>, <span class="string">'relative'</span>);</span><br><span class="line">           me.replaceEle.hide();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="comment">// 安卓情况下，防止惯性滚动引起的fix不及时的情况</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="regexp">/(Android)/i</span>.test(navigator.userAgent)) &#123;</span><br><span class="line"></span><br><span class="line">       $(<span class="built_in">window</span>).on(<span class="string">'scroll'</span>, scrollHandler);</span><br><span class="line"></span><br><span class="line">       $(<span class="built_in">document</span>.body).on(<span class="string">'touchstart'</span>, scrollHandler);</span><br><span class="line">       $(<span class="built_in">document</span>.body).on(<span class="string">'touchmove'</span>, scrollHandler);</span><br><span class="line">       $(<span class="built_in">document</span>.body).on(<span class="string">'touchend'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">           scrollHandler();</span><br><span class="line">           setTimeout(scrollHandler, <span class="number">1000</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="不支持sticky"><a href="#不支持sticky" class="headerlink" title="不支持sticky"></a>不支持sticky</h3><p>如果浏览器不支持position:sticky，那么就使用js动态的在节点在fixed定位于static定位中切换，但是需要对切换过程做一些优化。</p>
<p>1、使用函数节流防抖减少dom操作频繁粗发，但是保证在规定时间内必须执行一次。</p>
<p>2、使用window.requestAnimationFrame 方法在下一帧前触发浏览器的强制同步布局，是对dom的操作能及时渲染到页面上。</p>
<p>3、减少对dom的读写操作，或者把dom操作把读、写操作分开，可以减少渲染次数。</p>
<hr>
<p>参照 <a href="https://segmentfault.com/a/1190000008004300" target="_blank" rel="noopener">原文代码</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">	(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	    <span class="function"><span class="keyword">function</span> <span class="title">Sticky</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	        <span class="keyword">this</span>.init.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	     * 滚动fixed组件初始化</span></span><br><span class="line"><span class="comment">	     * @param &#123;object&#125;         setting                allocate传进来的参数</span></span><br><span class="line"><span class="comment">	     * @param &#123;object&#125;         setting.stickyNode     需要设置position:sticky的节点，通常是最外层</span></span><br><span class="line"><span class="comment">	     * @param &#123;object&#125;         setting.fixedNode      当滚动一定距离时需要fixed在顶部的节点</span></span><br><span class="line"><span class="comment">	     * @param &#123;int&#125;            setting.top            fixed之后距离顶部的top值</span></span><br><span class="line"><span class="comment">	     * @param &#123;int&#125;            setting.zIndex         fixed之后的z-index值</span></span><br><span class="line"><span class="comment">	     * @param &#123;string&#125;         setting.fixedClazz     fixed时给fixedNode添加的类</span></span><br><span class="line"><span class="comment">	     * @param &#123;function&#125;     setting.runInScrollFn  滚动期间额外执行的函数</span></span><br><span class="line"><span class="comment">	     * @return &#123;void&#125;  </span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">	    Sticky.setting = &#123;</span><br><span class="line">	        stickyNode: <span class="literal">null</span>,</span><br><span class="line">	        fixedNode: <span class="literal">null</span>,</span><br><span class="line">	        top: <span class="number">0</span>,</span><br><span class="line">	        zIndex: <span class="number">100</span>,</span><br><span class="line">	        fixedClazz: <span class="string">''</span>,</span><br><span class="line">	        runInScrollFn: <span class="literal">null</span></span><br><span class="line">	    &#125;;</span><br><span class="line">	    <span class="keyword">var</span> sPro = Sticky.prototype;</span><br><span class="line">	    <span class="keyword">var</span> g = <span class="built_in">window</span>;</span><br><span class="line">	</span><br><span class="line">	    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	     * 初始化</span></span><br><span class="line"><span class="comment">	     * @param  &#123;object&#125; options 设置</span></span><br><span class="line"><span class="comment">	     * @return &#123;void&#125;         </span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">	    sPro.init = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">	        <span class="keyword">this</span>.setting = $.extend(&#123;&#125;, Sticky.setting, options, <span class="literal">true</span>);</span><br><span class="line">	        <span class="keyword">if</span> (options.fixedNode) &#123;</span><br><span class="line">	            <span class="keyword">this</span>.fixedNode = options.fixedNode[<span class="number">0</span>] || options.fixedNode;</span><br><span class="line">	            <span class="keyword">this</span>.stickyNode = options.stickyNode[<span class="number">0</span>] || options.stickyNode;</span><br><span class="line">	            <span class="keyword">this</span>.cssStickySupport = <span class="keyword">this</span>.checkStickySupport();</span><br><span class="line">	            <span class="keyword">this</span>.stickyNodeHeight = <span class="keyword">this</span>.stickyNode.clientHeight;</span><br><span class="line">	            <span class="keyword">this</span>.fixedClazz = options.fixedClazz;</span><br><span class="line">	            <span class="keyword">this</span>.top = <span class="built_in">parseInt</span>(options.top, <span class="number">10</span>) || <span class="number">0</span>;</span><br><span class="line">	            <span class="keyword">this</span>.zIndex = <span class="built_in">parseInt</span>(options.zIndex) || <span class="number">1</span>;</span><br><span class="line">	            <span class="keyword">this</span>.setStickyCss();</span><br><span class="line">	            <span class="keyword">this</span>.isfixed = <span class="literal">false</span>;</span><br><span class="line">	            <span class="comment">// 把改变定位的操作添加到节流函数与window.requestAnimationFrame方法中，确保一定事件内必须执行一次</span></span><br><span class="line">	            <span class="keyword">this</span>.onscrollCb = <span class="keyword">this</span>.throttle(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	                <span class="keyword">this</span>.nextFrame(<span class="keyword">this</span>.sticky.bind(<span class="keyword">this</span>));</span><br><span class="line">	            &#125;.bind(<span class="keyword">this</span>), <span class="number">50</span>, <span class="number">100</span>);</span><br><span class="line">	            <span class="keyword">this</span>.initCss = <span class="keyword">this</span>.getInitCss();</span><br><span class="line">	            <span class="keyword">this</span>.fixedCss = <span class="keyword">this</span>.getFixedCss();</span><br><span class="line">	            <span class="keyword">this</span>.addEvent();</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;;</span><br><span class="line">	</span><br><span class="line">	    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	     * 获取原始css样式</span></span><br><span class="line"><span class="comment">	     * @return &#123;string&#125; 定位的样式</span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">	    sPro.getInitCss = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	        <span class="keyword">if</span> (!!<span class="keyword">this</span>.fixedNode) &#123;</span><br><span class="line">	            <span class="keyword">return</span> <span class="string">"position:"</span> + <span class="keyword">this</span>.fixedNode.style.position + <span class="string">";top:"</span> + <span class="keyword">this</span>.fixedNode.style.top + <span class="string">"px;z-index:"</span> + <span class="keyword">this</span>.fixedNode.style.zIndex + <span class="string">";"</span>;</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">	    &#125;;</span><br><span class="line">	</span><br><span class="line">	    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	     * 生成fixed时的css样式</span></span><br><span class="line"><span class="comment">	     * @return &#123;void&#125;</span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">	    sPro.getFixedCss = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	        <span class="keyword">return</span> <span class="string">"position:fixed;top:"</span> + <span class="keyword">this</span>.top + <span class="string">"px;z-index:"</span> + <span class="keyword">this</span>.zIndex + <span class="string">";"</span>;</span><br><span class="line">	    &#125;;</span><br><span class="line">	</span><br><span class="line">	    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	     * 给fixedNode设置fixed定位样式</span></span><br><span class="line"><span class="comment">	     * @param &#123;string&#125; style fixed定位的样式字符串</span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">	    sPro.setFixedCss = <span class="function"><span class="keyword">function</span>(<span class="params">style</span>) </span>&#123;</span><br><span class="line">	        <span class="keyword">if</span>(!<span class="keyword">this</span>.cssStickySupport)&#123;</span><br><span class="line">	            <span class="keyword">if</span> (!!<span class="keyword">this</span>.fixedNode)&#123;</span><br><span class="line">	                <span class="keyword">this</span>.fixedNode.style.cssText = style;</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;;</span><br><span class="line">	</span><br><span class="line">	    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	     * 检查浏览器是否支持positon: sticky定位</span></span><br><span class="line"><span class="comment">	     * @return &#123;boolean&#125; true 支持 false 不支持</span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">	    sPro.checkStickySupport = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	        <span class="keyword">var</span> div= <span class="literal">null</span>;</span><br><span class="line">	        <span class="keyword">if</span>(g.CSS &amp;&amp; g.CSS.supports)&#123;</span><br><span class="line">	            <span class="keyword">return</span> g.CSS.supports(<span class="string">"(position: sticky) or (position: -webkit-sticky)"</span>);</span><br><span class="line">	        &#125;</span><br><span class="line">	        div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">	        div.style.position = <span class="string">"sticky"</span>;</span><br><span class="line">	        <span class="keyword">if</span>(<span class="string">"sticky"</span> === div.style.position)&#123;</span><br><span class="line">	            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	        &#125;</span><br><span class="line">	        div.style.position = <span class="string">"-webkit-sticky"</span>;</span><br><span class="line">	        <span class="keyword">if</span>(<span class="string">"-webkit-sticky"</span> === div.style.position)&#123;</span><br><span class="line">	            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	        &#125;</span><br><span class="line">	        div = <span class="literal">null</span>;</span><br><span class="line">	        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	    &#125;;</span><br><span class="line">	</span><br><span class="line">	    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	     * 给sticyNode设置position: sticky定位</span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">	    sPro.setStickyCss = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	        <span class="keyword">if</span>(<span class="keyword">this</span>.cssStickySupport)&#123;</span><br><span class="line">	            <span class="keyword">this</span>.stickyNode.style.cssText = <span class="string">"position:-webkit-sticky;position:sticky;top:"</span> + <span class="keyword">this</span>.top + <span class="string">"px;z-index:"</span> + <span class="keyword">this</span>.zIndex + <span class="string">";"</span>;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;;</span><br><span class="line">	</span><br><span class="line">	    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	     * 监听window的滚动事件</span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">	    sPro.addEvent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	        $(g).on(<span class="string">'scroll'</span>, <span class="keyword">this</span>.onscrollCb.bind(<span class="keyword">this</span>));</span><br><span class="line">	    &#125;;</span><br><span class="line">	</span><br><span class="line">	    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	     * 让函数在规定时间内必须执行一次</span></span><br><span class="line"><span class="comment">	     * @param &#123;Function&#125; fn     定时执行的函数</span></span><br><span class="line"><span class="comment">	     * @param &#123;int&#125;      delay  延迟多少毫秒执行</span></span><br><span class="line"><span class="comment">	     * @param &#123;[type]&#125;   mustRunDelay 多少毫秒内必须执行一次</span></span><br><span class="line"><span class="comment">	     * @return &#123;[type]&#125;      [description]</span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">	    sPro.throttle = <span class="function"><span class="keyword">function</span>(<span class="params">fn, delay, mustRunDelay</span>)</span>&#123;</span><br><span class="line">	        <span class="keyword">var</span> timer = <span class="literal">null</span>;</span><br><span class="line">	        <span class="keyword">var</span> lastTime;</span><br><span class="line">	        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	            <span class="keyword">var</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">	            <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">	            g.clearTimeout(timer);</span><br><span class="line">	            <span class="keyword">if</span>(!lastTime)&#123;</span><br><span class="line">	                lastTime = now;</span><br><span class="line">	            &#125;</span><br><span class="line">	            <span class="keyword">if</span>(now - lastTime &gt; mustRunDelay)&#123;</span><br><span class="line">	                fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">	                lastTime = now;</span><br><span class="line">	            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	                g.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	                    fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">	                &#125;.bind(<span class="keyword">this</span>), delay);</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;.bind(<span class="keyword">this</span>);</span><br><span class="line">	    &#125;;</span><br><span class="line">	</span><br><span class="line">	    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	     * window.requestAnimationFrame的兼容性写法，保证在100/6ms执行一次</span></span><br><span class="line"><span class="comment">	     * @param  &#123;Function&#125; fn 100/16ms需要执行的函数</span></span><br><span class="line"><span class="comment">	     * @return &#123;void&#125;      </span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">	    sPro.nextFrame = (<span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">	        <span class="keyword">var</span> prefix = [<span class="string">"ms"</span>, <span class="string">"moz"</span>, <span class="string">"webkit"</span>, <span class="string">"o"</span>];</span><br><span class="line">	        <span class="keyword">var</span> handle = &#123;&#125;;</span><br><span class="line">	        handle.requestAnimationFrame = <span class="built_in">window</span>.requestAnimationFrame;</span><br><span class="line">	        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; prefix.length &amp;&amp; !handle.requestAnimationFrame; ++i)&#123;</span><br><span class="line">	            handle.requestAnimationFrame = <span class="built_in">window</span>[prefix[i] + <span class="string">"RequestAnimationFrame"</span>];</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="keyword">if</span>(!handle.requestAnimationFrame)&#123;</span><br><span class="line">	            handle.requestAnimationFrame = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">	                <span class="keyword">var</span> raf = <span class="built_in">window</span>.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	                    fn();</span><br><span class="line">	                &#125;, <span class="number">16</span>);</span><br><span class="line">	                <span class="keyword">return</span> raf;</span><br><span class="line">	            &#125;;</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">	            handle.requestAnimationFrame.apply(g, <span class="built_in">arguments</span>);</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;)();</span><br><span class="line">	</span><br><span class="line">	    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	     * 判断stickyNode的当前位置设置fixed|static|sticky定位</span></span><br><span class="line"><span class="comment">	     * @return &#123;void&#125;</span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">	    sPro.sticky = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	        <span class="keyword">this</span>.setting.runInScrollFn &amp;&amp; <span class="keyword">this</span>.setting.runInScrollFn();</span><br><span class="line">	        <span class="keyword">var</span> stickyNodeBox = <span class="keyword">this</span>.stickyNode.getBoundingClientRect();</span><br><span class="line">	        <span class="keyword">if</span>(stickyNodeBox.top &lt;= <span class="keyword">this</span>.top &amp;&amp; !<span class="keyword">this</span>.isfixed)&#123;</span><br><span class="line">	            <span class="keyword">this</span>.setFixedCss(<span class="keyword">this</span>.fixedCss);</span><br><span class="line">	            <span class="keyword">this</span>.fixedClazz &amp;&amp; $(<span class="keyword">this</span>.fixedNode).addClass(<span class="keyword">this</span>.fixedClazz);</span><br><span class="line">	            <span class="keyword">this</span>.isfixed = <span class="literal">true</span>;</span><br><span class="line">	            $(<span class="keyword">this</span>).trigger(<span class="string">'onsticky'</span>, <span class="literal">true</span>);</span><br><span class="line">	        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(stickyNodeBox.top &gt; <span class="keyword">this</span>.top &amp;&amp; <span class="keyword">this</span>.isfixed) &#123;</span><br><span class="line">	            <span class="keyword">this</span>.setFixedCss(<span class="keyword">this</span>.initCss.replace(<span class="regexp">/position:[^;]*/</span>, <span class="string">"position:static"</span>));</span><br><span class="line">	            g.setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	                <span class="keyword">this</span>.setFixedCss(<span class="keyword">this</span>.initCss)</span><br><span class="line">	            &#125;.bind(<span class="keyword">this</span>), <span class="number">30</span>);</span><br><span class="line">	            <span class="keyword">this</span>.fixedClazz &amp;&amp; $(<span class="keyword">this</span>.fixedNode).removeClass(<span class="keyword">this</span>.fixedClazz);</span><br><span class="line">	            <span class="keyword">this</span>.isfixed = <span class="literal">false</span>;</span><br><span class="line">	            $(<span class="keyword">this</span>).trigger(<span class="string">'onsticky'</span>, <span class="literal">true</span>);</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;;</span><br><span class="line">	</span><br><span class="line">	    $.initSticky = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">	        <span class="keyword">return</span> <span class="keyword">new</span> Sticky(options);</span><br><span class="line">    	&#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>html 结构：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"m-nav"</span>&gt;</span></span><br><span class="line">  		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"nav-fixed fixed"</span> <span class="attr">id</span>=<span class="string">"j-nav"</span> <span class="attr">style</span>=<span class="string">"position: fixed; top: 0px; z-index: 100;"</span>&gt;</span></span><br><span class="line">      	<span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"f-cb"</span>&gt;</span></span><br><span class="line">         	<span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"active"</span> <span class="attr">anchor-id</span>=<span class="string">"j-understand"</span>&gt;</span>了解儿童编程<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            		<span class="tag">&lt;<span class="name">li</span> <span class="attr">anchor-id</span>=<span class="string">"j-join"</span>&gt;</span>参与公益直播课<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">li</span> <span class="attr">anchor-id</span>=<span class="string">"j-upload"</span>&gt;</span>上传编程作品<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 结构：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.g-page-box</span> <span class="selector-class">.m-nav</span> &#123;</span><br><span class="line"> 	<span class="attribute">height</span>: <span class="number">1.33333rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.g-page-box</span> <span class="selector-class">.m-nav</span> <span class="selector-class">.nav-fixed</span> &#123;</span><br><span class="line">	 <span class="attribute">height</span>: .<span class="number">86667rem</span>;</span><br><span class="line">	 <span class="attribute">padding</span>: .<span class="number">22667rem</span> .<span class="number">50667rem</span>;</span><br><span class="line">	 <span class="attribute">background-color</span>: <span class="number">#1aadbb</span>;</span><br><span class="line">	 <span class="attribute">position</span>: relative;</span><br><span class="line">	 <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(0, 0, 0);</span><br><span class="line">	 <span class="attribute">-webkit-transform</span>: <span class="built_in">translate3d</span>(0, 0, 0);</span><br><span class="line">	 <span class="attribute">transition</span>: height <span class="number">4s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.fixed</span> &#123;</span><br><span class="line">	<span class="attribute">position</span>: fixed;</span><br><span class="line">	<span class="attribute">top</span>: <span class="number">0px</span>;</span><br><span class="line">	<span class="attribute">z-index</span>: <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>移动端吸顶fixbar</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端问题收集和解决</title>
    <url>/2019/05/21/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%97%AE%E9%A2%98%E6%94%B6%E9%9B%86%E5%92%8C%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote>
<p>对开发移动端时遇到的问题进行收集、记录和总结，对于已经有解决方案，附上解决方案。</p>
</blockquote>
<h2 id="tap击穿问题"><a href="#tap击穿问题" class="headerlink" title="tap击穿问题"></a>tap击穿问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>绑定tap方法的dom元素，触发该方法时，该dom元素下方同一位置的dom元素会触发click事件或者有浏览器认为可以被点击交互的dom元素（input的focus事件），称为tap击穿现象。</p>
<h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p>1、click事件在移动端会有300ms的延迟，因为需要检测双击事件。<a href="https://www.telerik.com/blogs/what-exactly-is.....-the-300ms-click-delay" target="_blank" rel="noopener">移动端300ms延迟原因</a></p>
<p>2、zepto的tap事件是绑定在document.body上的，tap事件执行（冒泡之后）之前，click事件已经被”执行”，只是被延迟了而已，所以在tap事件用preventDefault也没用 </p>
<a id="more"></a>

<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>1、上下元素使用同样的事件，同样适用tap或者click事件</p>
<p>2、使用fastclick库，会把click的300ms延迟干掉</p>
<p>3、自己封装tap事件，使用touchstart、touchend、touchmove事件，e.preventEvent()将事件阻止</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//封装一个tap事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tap</span>(<span class="params">ele, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 手机端和移动端不同处理</span></span><br><span class="line">    <span class="keyword">if</span> (isMobile()) &#123;</span><br><span class="line">        $(ele).on(<span class="string">'tuochstart'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">            event.preventDefault();</span><br><span class="line">            tag = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 如果移动了，则不计入tap事件</span></span><br><span class="line">        &#125;).on(<span class="string">'touchmove'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            tag = <span class="number">1</span>;</span><br><span class="line">        &#125;).on(<span class="string">'touchend'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (tag == <span class="number">0</span>) &#123;</span><br><span class="line">                callback(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $(ele).on(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">            callback(event);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="position-fixed-input输入框问题"><a href="#position-fixed-input输入框问题" class="headerlink" title="position: fixed + input输入框问题"></a>position: fixed + input输入框问题</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>IOS下，当input输入框获取焦点focus，弹起虚拟键盘之后，页面上position: fixed的元素的位置会错乱。</p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>1、当input元素focus时，改成position: absolute，blur的时候再将定位改为 position: fixed</p>
<p>2、使用iscroll库</p>
<p>3、使用div内滚动</p>
<h2 id="消除-transition-闪屏"><a href="#消除-transition-闪屏" class="headerlink" title="消除 transition 闪屏"></a>消除 transition 闪屏</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-transform-style</span>: <span class="selector-tag">preserve-3d</span>;</span><br><span class="line"><span class="comment">/*设置内嵌的元素在 3D 空间如何呈现：保留 3D*/</span></span><br><span class="line"><span class="selector-tag">-webkit-backface-visibility</span>: <span class="selector-tag">hidden</span>;</span><br><span class="line"><span class="comment">/*（设置进行转换的元素的背面在面对用户时是否可见：隐藏）*/</span></span><br></pre></td></tr></table></figure>

<h2 id="IOS字体大小重置"><a href="#IOS字体大小重置" class="headerlink" title="IOS字体大小重置"></a>IOS字体大小重置</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>iOS 与 OS X 端字体的优化(横竖屏会出现字体加粗不一致等) iOS 浏览器横屏时会重置字体大小，设置 text-size-adjust 为 none 可以解决 iOS 上的问题，但桌面版 Safari 的字体缩放功能会失效，因此最佳方案是将 text-size-adjust 为 100% 。</p>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-text-size-adjust</span>: 100%;</span><br><span class="line"><span class="selector-tag">-ms-text-size-adjust</span>: 100%;</span><br><span class="line"><span class="selector-tag">text-size-adjust</span>: 100%;</span><br></pre></td></tr></table></figure>

<h2 id="一些有用的属性"><a href="#一些有用的属性" class="headerlink" title="一些有用的属性"></a>一些有用的属性</h2><h3 id="不让-Android-手机识别邮箱"><a href="#不让-Android-手机识别邮箱" class="headerlink" title="不让 Android 手机识别邮箱"></a>不让 Android 手机识别邮箱</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;meta content="email=no" name="format-detection" /&gt;</span><br></pre></td></tr></table></figure>

<h3 id="禁止-iOS-识别长串数字为电话"><a href="#禁止-iOS-识别长串数字为电话" class="headerlink" title="禁止 iOS 识别长串数字为电话"></a>禁止 iOS 识别长串数字为电话</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;meta content="telephone=no" name="format-detection" /&gt;</span><br></pre></td></tr></table></figure>

<h3 id="禁止-iOS-弹出各种操作窗口"><a href="#禁止-iOS-弹出各种操作窗口" class="headerlink" title="禁止 iOS 弹出各种操作窗口"></a>禁止 iOS 弹出各种操作窗口</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-touch-callout</span><span class="selector-pseudo">:none</span></span><br></pre></td></tr></table></figure>

<h3 id="禁止用户选中文字"><a href="#禁止用户选中文字" class="headerlink" title="禁止用户选中文字"></a>禁止用户选中文字</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-user-select</span><span class="selector-pseudo">:none</span></span><br></pre></td></tr></table></figure>

<h2 id="translate"><a href="#translate" class="headerlink" title="translate"></a>translate</h2><p>动画效果中，使用translate比使用定位性能高，且性能更好。</p>
<h2 id="使用setTimeout"><a href="#使用setTimeout" class="headerlink" title="使用setTimeout"></a>使用setTimeout</h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>使用下述的语句，会使得code立即执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//.….code</span></span><br><span class="line">&#125;,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>原理：<a href="http://www.cnblogs.com/silin6/p/4333999.html" target="_blank" rel="noopener">JavaScript下的setTimeout(fn,0)意味着什么？</a></p>
<h2 id="Safari浏览器input输入框"><a href="#Safari浏览器input输入框" class="headerlink" title="Safari浏览器input输入框"></a>Safari浏览器input输入框</h2><h3 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h3><p>在safari下，input输入框，点击时会有一个默认的小人出现，点击后会自动补充联系人的信息</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>只有将其隐藏</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">::-webkit-contacts-auto-fill-button</span> &#123;</span><br><span class="line">  <span class="attribute">visibility</span>: hidden;</span><br><span class="line">  <span class="attribute">display</span>: none <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">pointer-events</span>: none;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="移动端input文字输入-文字输入限制"><a href="#移动端input文字输入-文字输入限制" class="headerlink" title="移动端input文字输入-文字输入限制"></a>移动端input文字输入-文字输入限制</h2><h3 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h3><p>当用户进行中文输入时，input 事件会截断非直接输入，什么是非直接输入呢，在我们输入汉字的时候，比如说「开心」，中间过程中会输入拼音，每次输入一个字母都会触发 input 事件，然而在没有点选候选字或者点击「选定」按钮前，都属于非直接输入。</p>
<h3 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h3><p>此时，input事件需要结合compositionstart和compositionend 这两个事件。<br><br><br>compositionstart: 开始非直接输入开始时触发<br><br><br>compositionend：非直接输入结束时触发。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inputLock = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">do</span>(<span class="params">inputElement</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> regex = <span class="regexp">/[^1-9a-zA-Z]/g</span>;</span><br><span class="line">    inputElement.value = inputElement.value.replace(regex, <span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inputElement.addEventListener(<span class="string">'compositionstart'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  inputLock = <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inputElement.addEventListener(<span class="string">'compositionend'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  inputLock = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">do</span>(event.target);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">inputElement.addEventListener(<span class="string">'input'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!inputLock) &#123;</span><br><span class="line">    <span class="keyword">do</span>(event.target);</span><br><span class="line">    event.returnValue = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="移动端input文字输入-emoji表情输入"><a href="#移动端input文字输入-emoji表情输入" class="headerlink" title="移动端input文字输入-emoji表情输入"></a>移动端input文字输入-emoji表情输入</h2><h3 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h3><p>当输入emoji表情的时候，js中判断emoji表情的长度是不一致的，不同表情的length也不同，跟unicode编码有关。</p>
<h3 id="解决办法-2"><a href="#解决办法-2" class="headerlink" title="解决办法"></a>解决办法</h3><p>限制字数，当超过字数限制的时候，把前16个字截断显示出来。</p>
<h2 id="textarea置底展示问题"><a href="#textarea置底展示问题" class="headerlink" title="textarea置底展示问题"></a>textarea置底展示问题</h2><h3 id="问题描述-7"><a href="#问题描述-7" class="headerlink" title="问题描述"></a>问题描述</h3><p>ios中的输入唤起键盘后，整个页面会被键盘压缩，也就是说页面的高度变小，并且所有的fixed全部变为了absolute。键盘会将页面顶上去。那么如果希望可以将输入框和键盘完全贴合，我们可以使用div模拟一个假的输入框，使用定位将真正的输入框隐藏掉，当点击假的输入框的时候，将真正的输入框定位到键盘上方，并且手动获取输入框焦点。<br><br></p>
<h3 id="解决办法-3"><a href="#解决办法-3" class="headerlink" title="解决办法"></a>解决办法</h3><p>在实现过程中需要注意下面几个问题：<br><br><br>1、真正的输入框的位置计算：<br><br><br>首先记录无键盘时的window.innerHeight，当键盘弹出后再获取当前的window.innerHeight，两者的差值即为键盘的高度，那么定位真输入框自然就很容易了<br><br><br>2、在ios下手动获取焦点不可以用click事件，需要使用tap事件才可以手动触发</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#fake-input'</span>).on($.os.ios?<span class="string">'tap'</span> : <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    initHeight = <span class="built_in">window</span>.innerHeight;</span><br><span class="line">    $(<span class="string">'#input'</span>).focus();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>3、当键盘收起的时候我们需要将真输入框再次隐藏掉，除了使用失去焦点（blur）方法，还有什么方法可以判断键盘是否收起呢？<br><br><br>这里可以使用setInterval监听，当当前window.innerHeight和整屏高度相等的时候判断为键盘收起。<br><br><br>注意：键盘弹起需要一点时间，所以计算当前屏幕高度也需要使用setInterval<br><br><br>4、因为textarea中的文字不能置底显示，当输入超过一行textarea需要自动调整高度，因此将scrollHeight赋值给textarea的height。当删除文字的时候需要height也有变化，因此每次input都先将height置0，然后再赋值。<br><br></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'#textarea'</span>).css(<span class="string">'height'</span>, <span class="number">0</span>);</span><br><span class="line">$(<span class="string">'#textarea'</span>).css(<span class="string">'height'</span>, $(<span class="string">'#textarea'</span>)[<span class="number">0</span>].scrollHeight);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Mobile H5</category>
      </categories>
      <tags>
        <tag>问题收集和解决</tag>
      </tags>
  </entry>
  <entry>
    <title>问题小记</title>
    <url>/2019/05/21/%E9%97%AE%E9%A2%98%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>问题知识小记&amp;备忘<br>author: @Tiffanysbear </p>
</blockquote>
<h2 id="event-target-和-event-currentTarget-的区别"><a href="#event-target-和-event-currentTarget-的区别" class="headerlink" title="event.target 和 event.currentTarget 的区别"></a>event.target 和 event.currentTarget 的区别</h2><p><a href="http://www.calledt.com/target-and-currenttarget/" target="_blank" rel="noopener">event.target 和 event.currentTarget 的区别</a></p>
<p>冒泡和捕获： 当addEventListener的第三个参数为true的时候，代表是在捕获阶段绑定；当第三个参数为false或者为空的时候，代表在冒泡阶段绑定</p>
<p>结论：event.target指向引起触发事件的元素，而event.currentTarget则是事件绑定的元素，只有被点击的那个目标元素的event.target才会等于event.currentTarget。</p>
<h2 id="line-heiht"><a href="#line-heiht" class="headerlink" title="line-heiht"></a>line-heiht</h2><p>line-height有5个值</p>
<ol>
<li><p>normal<br>　　浏览器默认属性值为纯数值1.2（不同浏览器或有差异）
　　</p>
</li>
<li><p>inherit<br>　　继承父元素的值，默认值
　　</p>
</li>
<li><p>百分比值<br>　　如果一个元素的font-size是16像素 那么如果设置150%的行高 最后的实际行高会是16像素*150% = 24像素 并且其子孙元素会继承这个像素值</p>
</li>
<li><p>长度值<br>　　一个元素如果设置了长度值为line-height 那么这个长度值就会被继承</p>
</li>
<li><p>纯数值<br>　　一个元素如果设置了纯数值为line-height，那么这个纯数值会被继承。例如一个元素行高为1.5 其font-size为16像素 那么它的实际行高为16 * 1.5 = 24像素 而它的子元素font-size为12像素 那么它的实际行高为12*1.5 = 18像素</p>
</li>
</ol>
<a id="more"></a>

<p>注意事项：     </p>
<ul>
<li>所有浏览器都支持line-height，但ie不支持 line-height 的 inherit 值</li>
<li>line-height 不允许设置负值 </li>
<li>未设高度的空div中的文字之所以有高度，是因为line-height。在inline box模型中，有个line boxes，line-boxes是根据文案、图片等这些资源生成的一个高度框，自身不产生高度。line-boxes的默认高度为字体高度的110% </li>
<li>使用height会使标签haslayout，而使用line-height则不会。</li>
</ul>
<h2 id="IE8问题"><a href="#IE8问题" class="headerlink" title="IE8问题"></a>IE8问题</h2><ul>
<li>在背景上放置链接，是不可点击的，通过设置层级z-index也不行。hack方法：为链接设置position: relative 或者 设置background: #fff，在将背景设置透明<figure class="highlight plain"><figcaption><span>0; filter: alpha(opacity</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 移动端</span><br><span class="line">* active伪类在PC端的作用为鼠标点击到放开时给元素添加样式用，呈现目标被点击的激活状态。需要在按钮元素或body/html上绑定一个touchstart事件才能激活:active状态。</span><br><span class="line">&lt;br&gt;``` document.body.addEventListener(&apos;touchstart&apos;, function ()&#123;&#125;); //...空函数即可</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="居中问题"><a href="#居中问题" class="headerlink" title="居中问题"></a>居中问题</h2><ul>
<li>多行高度不定文字居中，padding-top和padding-bottom设置相同即可</li>
<li>单行文本的垂直居中，line-height = height</li>
<li>多行文本的高度固定居中, display:table和display:table-cell的使用方法，前者必须设置在父元素上，后者必须设置在子元素上。vertical-align 用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。</li>
</ul>
<h2 id="px、em和rem的区别"><a href="#px、em和rem的区别" class="headerlink" title="px、em和rem的区别"></a>px、em和rem的区别</h2><p>px: 像素px是相对于显示器屏幕分辨率而言的(引自CSS2.0手册)</p>
<p>em: 相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。(引自CSS2.0手册)</p>
<p>任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合: 1em=16px。那么12px=0.75em,10px=0.625em。为了简化font-size的换算，需要在css中的body选择器中声明Font-size=62.5%，这就使em值变为 16px*62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。</p>
<ul>
<li>em的值不固定，会继承父级元素的字体大小</li>
<li>避免字体大小被重复计算，也就是1.2 * 1.2= 1.44的现象</li>
</ul>
<p>rem：始终是基于根元素 <html> ，是目前比较好的解决方法。</html></p>
<h2 id="去除inline-block元素之间的空隙"><a href="#去除inline-block元素之间的空隙" class="headerlink" title="去除inline-block元素之间的空隙"></a>去除inline-block元素之间的空隙</h2><p>造成空隙的原因：因为元素之间有空格或者换行<br>解决办法</p>
<ul>
<li>除掉空白符; 但缺点是代码风格和结构都不美观</li>
<li>font-size：0; 空白符也是字符，设置字体大小为0是可以实现除去字符的。缺点是需要为子元素依次设置字体大小，低版本chrome不支持设置font-size：0; 需要加上 -webkit-text-size-adjust：none 私有属性来支持设置。</li>
<li>word-spacing/letter-spacing: 使用负值，设置的负值是和字体大小有关系，但是如果设置过大的话，会造成重叠</li>
</ul>
<h2 id="postCss"><a href="#postCss" class="headerlink" title="postCss"></a>postCss</h2><p>详细解释：<a href="https://www.ibm.com/developerworks/cn/web/1604-postcss-css/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/web/1604-postcss-css/index.html</a><br><a href="https://www.ibm.com/developerworks/cn/web/1604-postcss-css/index.html" target="_blank" rel="noopener">点击链接</a></p>
<h2 id="node端获取用户ip"><a href="#node端获取用户ip" class="headerlink" title="node端获取用户ip"></a>node端获取用户ip</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getClientIp</span>(<span class="params">req</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> req.headers[<span class="string">'x-forwarded-for'</span>]</span><br><span class="line">        || req.connection.remoteAddress</span><br><span class="line">        || req.socket.remoteAddress</span><br><span class="line">        || req.connection.socket.remoteAddress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="禁止chrome安全策略"><a href="#禁止chrome安全策略" class="headerlink" title="禁止chrome安全策略"></a>禁止chrome安全策略</h2><p>mac电脑禁止chrome安全策略，允许支持后端接口跨域，在Applications 目录下，执行<figure class="highlight plain"><figcaption><span>-a "Google Chrome" --args --disable-web-security  --user-data-dir ```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 屏幕尺寸限制 meta</span><br><span class="line">通常利用媒体查询做相关的样式展示</span><br></pre></td></tr></table></figure></p>
<p>@media screen and (max-width: 359px) {<br>    display: none;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### viewport</span><br><span class="line">借助 &lt;meta&gt;元素的 viewport来帮助我们设置视口、缩放等，从而让移动端得到更好的展示效果</span><br></pre></td></tr></table></figure>

<meta name="viewport" content="width=device-width; initial-scale=1; maximum-scale=1;minimum-scale=1; user-scalable=no;">
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### setRem函数</span><br></pre></td></tr></table></figure>

<p>// setRem函数<br>(function () {<br>    var win=window, html=document.documentElement;<br>    function setRem() {<br>        var width = html.getBoundingClientRect().width;<br>        var rem = width / 10;<br>        win.rem = rem;<br>        html.style.fontSize = rem + ‘px’;<br>    }<br>    setRem();<br>    window.setRem = setRem;<br>})();</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 上传input</span><br><span class="line">1、解决input[type=file]打开时慢、卡顿问题</span><br></pre></td></tr></table></figure>

<input type="file" accpet="image/*">

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">因为Chrome的safeBrowsing功能会在上传或者保存时检查文件，国内访问google速度比较慢，SafeBrowsing就会让Chrome挂起一段时间，直到文件检查结束或者超时。</span><br><span class="line">所以可以使用：</span><br></pre></td></tr></table></figure>

<p>accept=”image/png, image/jpeg, image/gif”</p>
<pre><code>
因为这些MIME类型在SafeBrowsing的白名单里面，不需要检查。


2、打开页面，自动调起```&lt;input type=&quot;file&quot;&gt;```文件选择的解决办法

* 在页面打开时，执行js方法并手动trigger触发input的click事件，还有视频video自动播放，会因为浏览器的安全策略而被禁止，解决办法是，需要用户手动点击进行触发，因此可以尽量收敛产品逻辑，将页面的行为（打开新页或者自动播放视频等逻辑）放在一个页面中处理，比如，点击了播放视频按钮之后，看似是新开了页面，但是将页面逻辑控制一个页面，并不做跳页面处理，而只是将页面逻辑拿过来使用即可。
















</code></pre>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>问题收集和解决</tag>
      </tags>
  </entry>
  <entry>
    <title>页面埋点和统计</title>
    <url>/2019/05/21/%E9%A1%B5%E9%9D%A2%E5%9F%8B%E7%82%B9%E5%92%8C%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<blockquote>
<p>页面埋点和统计<br>author: @TiffanysBear</p>
</blockquote>
<h3 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h3><p>前端页面的展示和点击经常需要统计数据，所以在前端页面中就需要记录用户点击、浏览等的数据，通过请求的方式，上传到服务器，服务器再通过计算，统计出数据。还有些需求是需要用户操作页面，滑动到某一位置时，再进行打点统计。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>通过对图片的加载，将需要上报的参数通过image的src进行请求，绑定图片onload事件，发出请求。</p>
<a id="more"></a>

<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>打点上报代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * wapfelog</span><br><span class="line"> *</span><br><span class="line"> * @class</span><br><span class="line"> */</span><br><span class="line">function WapFelog() &#123;</span><br><span class="line">&#125;</span><br><span class="line">var wapfelogMap = this.wapfelogMap = &#123;&#125;;</span><br><span class="line">WapFelog.prototype = &#123;</span><br><span class="line">    constructor: WapFelog,</span><br><span class="line">    log: function (src) &#123;</span><br><span class="line">        var t = new Image();</span><br><span class="line">        var n = &apos;wap_log_&apos; + Math.floor(Math.random() * 2147483648).toString(36);</span><br><span class="line">        wapfelogMap[n] = t;</span><br><span class="line">        t.onload = t.onerror = t.onabort = function () &#123;</span><br><span class="line">            // 清空事件，因为播放gif的话会多次触发onload事件</span><br><span class="line">            t.onload = t.onerror = t.onabort = null;</span><br><span class="line">            wapfelogMap[n] = null;</span><br><span class="line">            // 将t置为null，防止形成闭包，造成内存泄漏</span><br><span class="line">            t = null;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.src = src;</span><br><span class="line">    &#125;,</span><br><span class="line">    send: function (type, options, bid, actId) &#123;</span><br><span class="line">        var me = this;</span><br><span class="line">        actId = actId || 100000;</span><br><span class="line">        var now = new Date().getTime();</span><br><span class="line">        var ctjUrl = [];</span><br><span class="line">        // 上报统计的域名</span><br><span class="line">        var domain = &apos;https://xxx.baidu.com&apos;;</span><br><span class="line">        options = options || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        ctjUrl = ctjUrl.concat([</span><br><span class="line">            &apos;isSync=&apos; + isSync,</span><br><span class="line">            &apos;url=&apos; + encodeURIComponent(location.href),</span><br><span class="line">            &apos;t=&apos; + now,</span><br><span class="line">            &apos;refer=&apos; + (document.referrer ? encodeURIComponent(document.referrer) : &apos;&apos;)</span><br><span class="line">        ]);</span><br><span class="line">        if (options) &#123;</span><br><span class="line">            for (var i in options) &#123;</span><br><span class="line">                if (!options.hasOwnProperty(i)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                ctjUrl.push(i + &apos;=&apos; + encodeURIComponent(options[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        this.log(ctjUrl.join(&apos;&amp;&apos;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">this.wapfelog = new WapFelog();</span><br></pre></td></tr></table></figure>

<p>滑动到某一位置进行打点，监听onScroll事件，元素滑动到可视区域内时，再进行打点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function onScroll(e) &#123;</span><br><span class="line">    $.each(config.elView, function (k, v) &#123;</span><br><span class="line">        var $el = $(k);</span><br><span class="line">        $el.each(function () &#123;</span><br><span class="line">            var el = this;</span><br><span class="line">            if (!el || !el.getBoundingClientRect) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            // 元素顶端到可见区域顶端的距离</span><br><span class="line">            var top = el.getBoundingClientRect().top;</span><br><span class="line">            // 元素底部端到可见区域顶端的距离</span><br><span class="line">            var bottom = el.getBoundingClientRect().bottom; </span><br><span class="line">            // 浏览器可见区域高度。</span><br><span class="line">            var se = document.documentElement.clientHeight; </span><br><span class="line">            var viewed = $(el).data(&apos;viewed&apos;);</span><br><span class="line">            var viewLogged = $(el).data(&apos;viewLogged&apos;);</span><br><span class="line">            // once参数控制打点一次or重复浏览重复打点</span><br><span class="line">            if (v.once &amp;&amp; viewLogged) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (top &lt; se &amp;&amp; bottom &gt; 0) &#123;</span><br><span class="line">                if (viewed) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                $(el).data(&#123;</span><br><span class="line">                    viewed: true,</span><br><span class="line">                    viewLogged: true</span><br><span class="line">                &#125;);</span><br><span class="line">                var index = $.isFunction(v.index) ? v.index.apply(el, arguments) : v.index;</span><br><span class="line">                var param = $.isFunction(v.param) ? v.param.apply(el, arguments) : v.param;</span><br><span class="line">                var cfg = $.extend(true, &#123;&#125;, param, &#123;</span><br><span class="line">                    index: index</span><br><span class="line">                &#125;);</span><br><span class="line">                wapfelog.send(&apos;pv&apos;, cfg, 1, v.actId);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (top &gt;= se || bottom &lt;= 0) &#123;</span><br><span class="line">                $(el).data(&#123;</span><br><span class="line">                    viewed: false</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">$(document).on(&apos;scroll.log&apos;, onScroll).trigger(&apos;scroll&apos;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>页面埋点和统计</tag>
      </tags>
  </entry>
  <entry>
    <title>js判断一个对象Object是否为空对象</title>
    <url>/2019/05/21/js%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1Object%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<blockquote>
<p> js判断空对象的方法<br> 判断一个js对象是否是空对象isEmptyObject<br> author: @TiffanysBear</p>
</blockquote>
<h3 id="方法一：使用for…in遍历"><a href="#方法一：使用for…in遍历" class="headerlink" title="方法一：使用for…in遍历"></a>方法一：使用for…in遍历</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isEmptyObject = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> <span class="keyword">this</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 尽量不要使用object.prototype直接进行修改</span></span><br><span class="line"><span class="comment">// 否则会为继承时生成的对象新增不必要的可枚举属性</span></span><br><span class="line"><span class="comment">// 同时可被for-in枚举到</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>.prototype, <span class="string">'isEmptyObject'</span>, &#123;</span><br><span class="line">	writable: <span class="literal">false</span>,</span><br><span class="line">	configurable: <span class="literal">false</span>,</span><br><span class="line">	enumerable: <span class="literal">false</span>,</span><br><span class="line">	value: isEmptyObject</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="方法二：使用JSON-stringify方法"><a href="#方法二：使用JSON-stringify方法" class="headerlink" title="方法二：使用JSON.stringify方法"></a>方法二：使用JSON.stringify方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isEmptyObject = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(obj) === <span class="string">'&#123;&#125;'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>.prototype, <span class="string">'isEmptyObject'</span>, &#123;</span><br><span class="line">	writable: <span class="literal">false</span>,</span><br><span class="line">	configurable: <span class="literal">false</span>,</span><br><span class="line">	enumerable: <span class="literal">false</span>,</span><br><span class="line">	value: isEmptyObject</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="方法三：使用ES6的Object-keys"><a href="#方法三：使用ES6的Object-keys" class="headerlink" title="方法三：使用ES6的Object.keys"></a>方法三：使用ES6的Object.keys</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isEmptyObject = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Object</span>.keys(a).length === <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>.prototype, <span class="string">'isEmptyObject'</span>, &#123;</span><br><span class="line">	writable: <span class="literal">false</span>,</span><br><span class="line">	configurable: <span class="literal">false</span>,</span><br><span class="line">	enumerable: <span class="literal">false</span>,</span><br><span class="line">	value: isEmptyObject</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果不支持Object.keys，采用如下的polyfill：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Object</span>.keys) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.keys = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hasOwnProperty = <span class="built_in">Object</span>.prototype.hasOwnProperty,</span><br><span class="line">        hasDontEnumBug = !(&#123;<span class="attr">toString</span>: <span class="literal">null</span>&#125;).propertyIsEnumerable(<span class="string">'toString'</span>),</span><br><span class="line">        dontEnums = [</span><br><span class="line">          <span class="string">'toString'</span>,</span><br><span class="line">          <span class="string">'toLocaleString'</span>,</span><br><span class="line">          <span class="string">'valueOf'</span>,</span><br><span class="line">          <span class="string">'hasOwnProperty'</span>,</span><br><span class="line">          <span class="string">'isPrototypeOf'</span>,</span><br><span class="line">          <span class="string">'propertyIsEnumerable'</span>,</span><br><span class="line">          <span class="string">'constructor'</span></span><br><span class="line">        ],</span><br><span class="line">        dontEnumsLength = dontEnums.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> obj !== <span class="string">'function'</span> || obj === <span class="literal">null</span>) &#123;</span><br><span class="line">	      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Object.keys called on non-object'</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> result = [];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasOwnProperty.call(obj, prop)) result.push(prop);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (hasDontEnumBug) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; dontEnumsLength; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (hasOwnProperty.call(obj, dontEnums[i])) result.push(dontEnums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js判断空对象的方法</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端1px解决方案</title>
    <url>/2019/05/21/%E7%A7%BB%E5%8A%A8%E7%AB%AF1px%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<blockquote>
<p>移动端1px的实现<br>author: @TiffanysBear</p>
</blockquote>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在移动端，css中的1px并等于移动设备的1px，因为手机屏幕有不同的像素密度。window中的devicePixelRatio就是反应css中像素与真实像素的比例，也就是设备物理像素和设备独立像素的比例，也就是 devicePixelRatio = 物理像素 / 独立像素。所以造成了通过css设置1px，在移动端屏幕上会变粗。</p>
<h3 id="解决方案一：使用伪类缩放"><a href="#解决方案一：使用伪类缩放" class="headerlink" title="解决方案一：使用伪类缩放"></a>解决方案一：使用伪类缩放</h3><p>使用伪类缩放需要主要的是：<br></p>
<ol>
<li>设置全边框的时候，box-sizing要设置为border-box，否则伪元素上下左右各会多1px</li>
<li>需要将父元素设置为relative</li>
<li>注意 transform 的起点，上边距要用左上角，下边距用左下角</li>
</ol>
<a id="more"></a>

<p>0.5px下边框</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 下边框 */</span></span><br><span class="line"><span class="selector-class">.one-px-border2</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(.5);</span><br><span class="line">    <span class="attribute">transform-origin</span>: left bottom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>0.5px上边框</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/* 上边框 */</span></span><br><span class="line"><span class="selector-class">.one-px-border1</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(.5);</span><br><span class="line">    <span class="attribute">transform-origin</span>: left top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>0.5px全边框</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.one-px-border3</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">transform-origin</span>: left bottom;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(.5);</span><br><span class="line">    <span class="comment">/* box-sizing要设置为border-box，否则伪元素上下左右各会多1px */</span></span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="comment">/* 设置圆角border等 */</span></span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解决方案二：使用-webkit-min-device-pixel-ratio"><a href="#解决方案二：使用-webkit-min-device-pixel-ratio" class="headerlink" title="解决方案二：使用 -webkit-min-device-pixel-ratio"></a>解决方案二：使用 -webkit-min-device-pixel-ratio</h3><blockquote>
<p>The -webkit-device-pixel-ratio CSS media query. Use this to specify the screen densities for which this style sheet is to be used. The corresponding value should be either “0.75”, “1”, or “1.5”, to indicate that the styles are for devices with low density, medium density, or high density screens, respectively. For example: The hdpi.css stylesheet is only used for devices with a screen pixel ration of 1.5, which is the high density pixel ratio.</p>
</blockquote>
<p>使用less对常用的1px进行封装：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 高清屏 1px</span></span><br><span class="line">@lignt-gray-color: #e7e7e7;</span><br><span class="line"><span class="comment">// 设置圆角（如果圆角大于0，则添加圆角的代码）</span></span><br><span class="line">.border-radius(@borderRadius) when (unit(@borderRadius) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    border-radius: @borderRadius;</span><br><span class="line">    @media (-webkit-min-device-pixel-ratio: <span class="number">2</span>) &#123;</span><br><span class="line">        &amp;:before &#123;</span><br><span class="line">            border-radius: unit(unit(@borderRadius) * <span class="number">2</span>, px);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @media (-webkit-min-device-pixel-ratio: <span class="number">2.5</span>) &#123;</span><br><span class="line">        &amp;:before &#123;</span><br><span class="line">            border-radius: unit(unit(@borderRadius) * <span class="number">2.5</span>, px);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @media (-webkit-min-device-pixel-ratio: <span class="number">2.75</span>) &#123;</span><br><span class="line">        &amp;:before &#123;</span><br><span class="line">            border-radius: unit(unit(@borderRadius) * <span class="number">2.75</span>, px);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @media (-webkit-min-device-pixel-ratio: <span class="number">3</span>) &#123;</span><br><span class="line">        &amp;:before &#123;</span><br><span class="line">            border-radius: unit(unit(@borderRadius) * <span class="number">3</span>, px);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// border函数</span></span><br><span class="line">.border(</span><br><span class="line">    @borderWidth: <span class="number">1</span>px; </span><br><span class="line">    @borderStyle: solid; </span><br><span class="line">    @borderColor: @lignt-gray-color; </span><br><span class="line">    @borderRadius: <span class="number">0</span>) &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    &amp;:before &#123;</span><br><span class="line">        content: <span class="string">''</span>;</span><br><span class="line">        position: absolute;</span><br><span class="line">        width: <span class="number">98</span>%;</span><br><span class="line">        height: <span class="number">98</span>%;</span><br><span class="line">        top: <span class="number">0</span>;</span><br><span class="line">        left: <span class="number">0</span>;</span><br><span class="line">        transform-origin: left top;</span><br><span class="line">        -webkit-transform-origin: left top;</span><br><span class="line">        box-sizing: border-box;</span><br><span class="line">        pointer-events: none;</span><br><span class="line">    &#125;</span><br><span class="line">    @media (-webkit-min-device-pixel-ratio: <span class="number">2</span>) &#123;</span><br><span class="line">        &amp;:before &#123;</span><br><span class="line">            width: <span class="number">198</span>%;</span><br><span class="line">            height: <span class="number">198</span>%;</span><br><span class="line">            -webkit-transform: scale(<span class="number">.5</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @media (-webkit-min-device-pixel-ratio: <span class="number">2.5</span>) &#123;</span><br><span class="line">        &amp;:before &#123;</span><br><span class="line">            width: <span class="number">248</span>%;</span><br><span class="line">            height: <span class="number">248</span>%;</span><br><span class="line">            -webkit-transform: scale(<span class="number">.4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @media (-webkit-min-device-pixel-ratio: <span class="number">2.75</span>) &#123;</span><br><span class="line">        &amp;:before &#123;</span><br><span class="line">            width: <span class="number">273</span>%;</span><br><span class="line">            height: <span class="number">273</span>%;</span><br><span class="line">            -webkit-transform: scale(<span class="number">1</span> / <span class="number">2.75</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @media (-webkit-min-device-pixel-ratio: <span class="number">3</span>) &#123;</span><br><span class="line">        &amp;:before &#123;</span><br><span class="line">            width: <span class="number">298</span>%;</span><br><span class="line">            height: <span class="number">298</span>%;</span><br><span class="line">            transform: scale(<span class="number">1</span> / <span class="number">3</span>);</span><br><span class="line">            -webkit-transform: scale(<span class="number">1</span> / <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .border-radius(@borderRadius);</span><br><span class="line">    &amp;:before &#123;</span><br><span class="line">        border-width: @borderWidth;</span><br><span class="line">        border-style: @borderStyle;</span><br><span class="line">        border-color: @borderColor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全边框函数及规则</span></span><br><span class="line">.border-all(</span><br><span class="line">	@borderWidth: <span class="number">1</span>px; </span><br><span class="line">	@borderStyle: solid; </span><br><span class="line">	@borderColor: @lignt-gray-color; </span><br><span class="line">	@borderRadius: <span class="number">0</span>) &#123;</span><br><span class="line">    .border(@borderWidth; @borderStyle; @borderColor; @borderRadius);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上边框函数及规则</span></span><br><span class="line">.border-top(</span><br><span class="line">	@borderWidth: <span class="number">1</span>px; </span><br><span class="line">	@borderStyle: solid; </span><br><span class="line">	@borderColor: @lignt-gray-color; </span><br><span class="line">	@borderRadius: <span class="number">0</span>) &#123;</span><br><span class="line">    .border(@borderWidth <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>; @borderStyle; @borderColor; @borderRadius);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右边框函数及规则</span></span><br><span class="line">.border-right(</span><br><span class="line">	@borderWidth: <span class="number">1</span>px; </span><br><span class="line">	@borderStyle: solid;</span><br><span class="line">	@borderColor: @lignt-gray-color; </span><br><span class="line">	@borderRadius: <span class="number">0</span>) &#123;</span><br><span class="line">    .border(<span class="number">0</span> @borderWidth <span class="number">0</span> <span class="number">0</span>; @borderStyle; @borderColor; @borderRadius);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下边框函数及规则</span></span><br><span class="line">.border-bottom(</span><br><span class="line">	@borderWidth: <span class="number">1</span>px; </span><br><span class="line">	@borderStyle: solid; </span><br><span class="line">	@borderColor: @lignt-gray-color; </span><br><span class="line">	@borderRadius: <span class="number">0</span>) &#123;</span><br><span class="line">    .border(<span class="number">0</span> <span class="number">0</span> @borderWidth <span class="number">0</span>; @borderStyle; @borderColor; @borderRadius);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左边框函数及规则</span></span><br><span class="line">.border-left(</span><br><span class="line">	@borderWidth: <span class="number">1</span>px; </span><br><span class="line">	@borderStyle: solid; </span><br><span class="line">	@borderColor: @lignt-gray-color; </span><br><span class="line">	@borderRadius: <span class="number">0</span>) &#123;</span><br><span class="line">    .border(<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> @borderWidth; @borderStyle; @borderColor; @borderRadius);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上-右边框函数及规则</span></span><br><span class="line">.border-tr(</span><br><span class="line">	@borderWidth: <span class="number">1</span>px; </span><br><span class="line">	@borderStyle: solid; </span><br><span class="line">	@borderColor: @lignt-gray-color; </span><br><span class="line">	@borderRadius: <span class="number">0</span>) &#123;</span><br><span class="line">    .border(@borderWidth @borderWidth <span class="number">0</span> <span class="number">0</span>; @borderStyle; @borderColor; @borderRadius);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上-下边框函数及规则</span></span><br><span class="line">.border-tb(</span><br><span class="line">	@borderWidth: <span class="number">1</span>px; </span><br><span class="line">	@borderStyle: solid; </span><br><span class="line">	@borderColor: @lignt-gray-color; </span><br><span class="line">	@borderRadius: <span class="number">0</span>) &#123;</span><br><span class="line">    .border(@borderWidth <span class="number">0</span>; @borderStyle; @borderColor; @borderRadius);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上-左边框函数及规则</span></span><br><span class="line">.border-tl(</span><br><span class="line">	@borderWidth: <span class="number">1</span>px; </span><br><span class="line">	@borderStyle: solid; </span><br><span class="line">	@borderColor: @lignt-gray-color; </span><br><span class="line">	@borderRadius: <span class="number">0</span>) &#123;</span><br><span class="line">    .border(@borderWidth <span class="number">0</span> <span class="number">0</span> @borderWidth; @borderStyle; @borderColor; @borderRadius);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右-下边框函数及规则</span></span><br><span class="line">.border-rb(</span><br><span class="line">	@borderWidth: <span class="number">1</span>px; </span><br><span class="line">	@borderStyle: solid; </span><br><span class="line">	@borderColor: @lignt-gray-color; </span><br><span class="line">	@borderRadius: <span class="number">0</span>) &#123;</span><br><span class="line">    .border(<span class="number">0</span> @borderWidth @borderWidth <span class="number">0</span>; @borderStyle; @borderColor; @borderRadius);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右-左边框函数及规则a</span></span><br><span class="line">.border-rl(</span><br><span class="line">	@borderWidth: <span class="number">1</span>px; </span><br><span class="line">	@borderStyle: solid;</span><br><span class="line">	@borderColor: @lignt-gray-color; </span><br><span class="line">	@borderRadius: <span class="number">0</span>) &#123;</span><br><span class="line">    .border(<span class="number">0</span> @borderWidth; @borderStyle; @borderColor; @borderRadius);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下-左边框函数及规则</span></span><br><span class="line">.border-bl(</span><br><span class="line">	@borderWidth: <span class="number">1</span>px; </span><br><span class="line">	@borderStyle: solid; </span><br><span class="line">	@borderColor: @lignt-gray-color; </span><br><span class="line">	@borderRadius: <span class="number">0</span>) &#123;</span><br><span class="line">    .border(<span class="number">0</span> <span class="number">0</span> @borderWidth @borderWidth; @borderStyle; @borderColor; @borderRadius);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用时：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.one-px-border &#123;</span><br><span class="line">	// 使用less函数.border</span><br><span class="line">	.border(1px, solid, red);</span><br><span class="line">	// 使用less函数.border-radius</span><br><span class="line">	.border-radius(20px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解决方案三：使用图片"><a href="#解决方案三：使用图片" class="headerlink" title="解决方案三：使用图片"></a>解决方案三：使用图片</h3><p>切图，使用图片结合border-image进行css样式设置</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.border-bottom-1px &#123;</span><br><span class="line">	border-width: 0 0 1px 0;</span><br><span class="line">	border-image: url(linenew.png) 0 0 2 0 stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：不够灵活，换颜色需要换图片</p>
<h3 id="解决方案四：使用box-shadow模拟"><a href="#解决方案四：使用box-shadow模拟" class="headerlink" title="解决方案四：使用box-shadow模拟"></a>解决方案四：使用box-shadow模拟</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box-shadow-1px</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: inset <span class="number">0px</span> -<span class="number">1px</span> <span class="number">1px</span> -<span class="number">1px</span> red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>移动端1px的实现</tag>
      </tags>
  </entry>
  <entry>
    <title>百度小程序之间的页面通信.md</title>
    <url>/2019/05/15/%E7%99%BE%E5%BA%A6%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E9%97%B4%E7%9A%84%E9%A1%B5%E9%9D%A2%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<blockquote>
<p>百度小程序之间的页面通信<br>author: @TiffanysBear</p>
</blockquote>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>主要是针对小程序开发中页面之间进行通信的问题，在涉及支付的场景中，用户从页面支付入口进行跳转进行支付之后，回到原来页面，在原来的页面需要进行相应的状态刷新，比如用户身份状态、支付状态、文档或商品情况。</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>在使用百度小程序的 swan.navigateBack 进行回跳页面时，API中的方法参数不支持携带参数，只支持number参数。</p>
<p>所以就涉及了几个单独页面之间的通信问题。如下主要列出了几个方法，供参考。</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>必填</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>delta</td>
<td>Number</td>
<td>否</td>
<td>1</td>
<td>返回的页面数，如果 delta 大于现有页面数，则返回到首页1。</td>
</tr>
<tr>
<td>success</td>
<td>function</td>
<td>否</td>
<td>-</td>
<td>接口调用成功的回调函数</td>
</tr>
<tr>
<td>fail</td>
<td>function</td>
<td>否</td>
<td>-</td>
<td>接口调用失败的回调函数</td>
</tr>
<tr>
<td>complete</td>
<td>function</td>
<td>否</td>
<td>-</td>
<td>接口调用结束的回调函数（调用成功、失败都会执行）</td>
</tr>
</tbody></table>
<a id="more"></a>

<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>主要有以下三种方法，实现各page之间通信。</p>
<h3 id="解决方法一：利用app-js，设置公共变量"><a href="#解决方法一：利用app-js，设置公共变量" class="headerlink" title="解决方法一：利用app.js，设置公共变量"></a>解决方法一：利用app.js，设置公共变量</h3><p>利用app.js的公共特性，将变量挂在APP上。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.js 启动文件</span></span><br><span class="line">App(&#123;</span><br><span class="line">    globalData: &#123;</span><br><span class="line">        isLogin: <span class="literal">false</span>,</span><br><span class="line">        userInfo: <span class="literal">null</span>,</span><br><span class="line">        networkError: <span class="literal">false</span>,</span><br><span class="line">        networkType: <span class="string">'none'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在其他页面Page上使用时，使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="keyword">const</span> app = getApp();</span><br><span class="line"><span class="keyword">const</span> commonParams = app.globalData.isLogin;</span><br></pre></td></tr></table></figure>

<p>但是存在的缺点也十分明显，当数据量比较大、数据关系比较复杂时，维护会比较复杂，逻辑会很混乱。</p>
<h3 id="解决方法二：利用storage"><a href="#解决方法二：利用storage" class="headerlink" title="解决方法二：利用storage"></a>解决方法二：利用storage</h3><p>利用小程序的全局storage，对数据进行存取，原理类似于解决方案一。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储-异步</span></span><br><span class="line">swan.setStorage(&#123;</span><br><span class="line">    key: <span class="string">'key'</span>,</span><br><span class="line">    data: <span class="string">'value'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 存储-同步</span></span><br><span class="line">swan.setStorageSync(<span class="string">'key'</span>, <span class="string">'value'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取-异步</span></span><br><span class="line">swan.getStorage(&#123;</span><br><span class="line">    key: <span class="string">'key'</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res.data);</span><br><span class="line">    &#125;,</span><br><span class="line">    fail: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'错误码：'</span> + err.errCode);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'错误信息：'</span> + err.errMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取-同步</span></span><br><span class="line"><span class="keyword">const</span> result = swan.getStorageSync(<span class="string">'key'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="解决方法三：-利用事件中心"><a href="#解决方法三：-利用事件中心" class="headerlink" title="解决方法三： 利用事件中心"></a>解决方法三： 利用事件中心</h3><p>利用事件中心的进行订阅和发布。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// event.js 事件中心</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">    on(event, fn, ctx) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">'fn must be a function'</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>._stores = <span class="keyword">this</span>._stores || &#123;&#125;;</span><br><span class="line">        (<span class="keyword">this</span>._stores[event] = <span class="keyword">this</span>._stores[event] || []).push(&#123;</span><br><span class="line">            cb: fn,</span><br><span class="line">            ctx: ctx</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    emit(event, ...args) &#123;</span><br><span class="line">        <span class="keyword">this</span>._stores = <span class="keyword">this</span>._stores || &#123;&#125;;</span><br><span class="line">        <span class="keyword">let</span> store = <span class="keyword">this</span>._stores[event];</span><br><span class="line">        <span class="keyword">if</span> (store) &#123;</span><br><span class="line">            store = store.slice(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = store.length; i &lt; len; i++) &#123;</span><br><span class="line">                store[i].cb.apply(store[i].ctx, args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    off(event, fn) &#123;</span><br><span class="line">        <span class="keyword">this</span>._stores = <span class="keyword">this</span>._stores || &#123;&#125;;</span><br><span class="line">        <span class="comment">// all</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">            <span class="keyword">this</span>._stores = &#123;&#125;;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// specific event</span></span><br><span class="line">        <span class="keyword">let</span> store = <span class="keyword">this</span>._stores[event];</span><br><span class="line">        <span class="keyword">if</span> (!store) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// remove all handlers</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="keyword">this</span>._stores[event];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// remove specific handler</span></span><br><span class="line">        <span class="keyword">let</span> cb;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = store.length; i &lt; len; i++) &#123;</span><br><span class="line">            cb = store[i].cb;</span><br><span class="line">            <span class="keyword">if</span> (cb === fn) &#123;</span><br><span class="line">                store.splice(i, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Event;</span><br></pre></td></tr></table></figure>

<p>在app.js中进行声明和管理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> Event <span class="keyword">from</span> <span class="string">'./utils/event'</span>;</span><br><span class="line"></span><br><span class="line">App(&#123;</span><br><span class="line">    event: <span class="keyword">new</span> Event()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>订阅的页面中，使用on方法进行订阅</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// view.js 阅读页进行订阅</span></span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">    <span class="comment">// 页面在回退时，会调用onShow方法</span></span><br><span class="line">    onShow() &#123;</span><br><span class="line">        <span class="comment">// 支付成功的回调，调起下载弹层</span></span><br><span class="line">        app.event.on(<span class="string">'afterPaySuccess'</span>, <span class="keyword">this</span>.afterPaySuccess, <span class="keyword">this</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    afterPaySuccess(e) &#123;</span><br><span class="line">        <span class="comment">// ....业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>发布的页面中，根据业务情况进行发布emit</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// paySuccess.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = getApp();</span><br><span class="line"></span><br><span class="line">app.event.emit(<span class="string">'afterPaySuccess'</span>, &#123;</span><br><span class="line">    docId: <span class="keyword">this</span>.data.tradeInfo.docId,</span><br><span class="line">    triggerFrom: <span class="string">'docCashierBack'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>根据事件中心的发布和订阅，实现了页面之间的通信，就能实现比如页面在支付成功后回退时，页面状态的改变的场景，同时利于维护页面之间的数据关系，能通过在发布时传递参数，实现数据之间的通信。</p>
<p>欢迎疑问，希望对你有帮助~</p>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>百度小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>H5多媒体能力</title>
    <url>/2018/11/15/H5%E5%A4%9A%E5%AA%92%E4%BD%93%E8%83%BD%E5%8A%9B/</url>
    <content><![CDATA[<blockquote>
<p>H5多媒体能力<br>author: <a href="https://tiffanysbear.github.io/" target="_blank" rel="noopener">@TiffanysBear</a></p>
</blockquote>
<h2 id="H5多媒体能力"><a href="#H5多媒体能力" class="headerlink" title="H5多媒体能力"></a>H5多媒体能力</h2><blockquote>
<p>多媒体能力顾名思义就是H5提供的播放视频、音频能力。<br>在HTML5中通过HTML标签&lt;audio&gt;和&lt;video&gt;来支持嵌入式的媒体，是开发者能够方便的将媒体嵌入。</p>
</blockquote>
<p>##例子<br>###音频</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;audio src=&quot;XXX&quot;&gt;</span><br><span class="line">你的浏览器不支持audio标签</span><br><span class="line">&lt;/audio&gt;</span><br></pre></td></tr></table></figure>

<p>###视频</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;video controls&gt;</span><br><span class="line">  &lt;source src=&quot;foo.ogg&quot; type=&quot;video/ogg&quot;&gt;</span><br><span class="line">  &lt;source src=&quot;foo.mp4&quot; type=&quot;video/mp4&quot;&gt;</span><br><span class="line">  你的浏览器不支持video标签</span><br><span class="line">&lt;/video&gt;</span><br></pre></td></tr></table></figure>

<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Supported_media_formats" target="_blank" rel="noopener">audio和video元素支持的媒体格式浏览器兼容性情况</a></p>
<p>##&lt;audio&gt;标签</p>
<blockquote>
<p>如果元素包含 src 属性：零个或多个 &lt;track&gt; 元素，其后紧跟不包含 &lt;audio&gt; 或者 &lt;video&gt;媒体元素的透明内容。<br>或者：零个或多个 &lt;source&gt; 元素，其后紧跟零个或多个 &lt;track&gt; 元素，其后紧跟不包含 &lt;audio&gt; 或者 &lt;video&gt;媒体元素的透明内容。</p>
</blockquote>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li><p>autoplay [Boolean] 音频自动播放。</p>
</li>
<li><p>buffered 通过该属性获取已缓冲的资源的时间段信息。该属性包含一个 TimeRanges 对象。</p>
</li>
<li><p>controls 如果设置了该属性，浏览器将提供一个包含声音，播放进度，播放暂停的控制面板，让用户可以控制音频的播放。</p>
</li>
<li><p>loop [Boolean] 循环播放音频。</p>
</li>
<li><p>muted [Boolean] 表示是否静音的布尔值。默认值为false，表示有声音。</p>
</li>
<li><p>played 一个TimeRanges 对象，表示所有已播放的音频片段。</p>
</li>
<li><p>preload 枚举属性，让开发者自行思考来示意浏览器使用何种加载方式以达到最好的用户体验。可以是以下属性之一：</p>
<ul>
<li>none 示意用户可能不会播放该音频，或者服务器希望节省带宽；换句话说，该音频不会被缓存；</li>
<li>metadata 示意即使用户可能不会播放该音频，但获取元数据 (例如音频长度) 还是有必要的。</li>
<li>auto 示意用户可能会播放音频；换句话说，如果有必要，整个音频都将被加载，即使用户不期望使用。</li>
<li>空字符串 等效于auto属性。</li>
<li>假如不设置，默认值就是浏览器定义的了（不同浏览器会选择自己的默认值）， 即使规范建议设置为 metadata.</li>
</ul>
<blockquote>
<ul>
<li>autoplay 属性优先于 preload 假如用户想自动播放视频，那么很明显浏览器需要下载视频。同时设置autoplay 和 preload属性在规范里是允许的。</li>
<li>规范没有强制浏览器去遵循该属性的值；这仅仅只是个提示。</li>
</ul>
</blockquote>
</li>
<li><p>src 嵌入的音频的URL。 该URL应遵从 HTTP access controls. 这是一个可选属性；你可以在audio元素中使用 &lt;source&gt; 元素来替代该属性指定嵌入的音频。</p>
</li>
<li><p>volume 音频播放的音量。值从0.0 (无声) 到 1.0 (最大声).</p>
</li>
</ul>
<p>###事件<br>| 事件 | 描述 |<br>| —- | —- |<br>| <font color="#0000ff"><strong>abort</strong></font> | 在播放被终止时触发。|<br>| <font color="#0000ff"><strong>canplay</strong></font> | 在媒体数据已经有足够的数据（至少播放数帧）可供播放时触发。|<br>| canplaythrough |在媒体的readyState变为CAN_PLAY_THROUGH时触发，表明媒体可以在保持当前的下载速度的情况下不被中断地播放完毕。注意：手动设置currentTime会使得firefox触发一次canplaythrough事件，其他浏览器或许不会如此。|<br>| durationchange |元信息已载入或已改变，表明媒体的长度发生了改变。例如，在媒体已被加载足够的长度从而得知总长度时会触发这个事件。|<br>| emptied |媒体被清空（初始化）时触发。|<br>| <font color="#0000ff"><strong>ended</strong></font> |播放结束时触发。|<br>|<font color="#0000ff"><strong>error</strong></font>|在发生错误时触发。元素的error属性会包含更多信息|<br>| loadeddata | 媒体的第一帧已经加载完毕|<br>| <font color="#0000ff"><strong>loadedmetadata</strong></font> | 媒体的元数据已经加载完毕，现在所有的属性包含了它们应有的有效信息。|<br>| <font color="#0000ff"><strong>loadstart</strong></font> | 在媒体开始加载时触发。|<br>| mozaudioavailable |当音频数据缓存并交给音频层处理时|<br>| <font color="#0000ff"><strong>pause</strong></font> |播放暂停时触发。|<br>| <font color="#0000ff"><strong>play</strong></font> | 在媒体回放被暂停后再次开始时触发。即，在一次暂停事件后恢复媒体回放。|<br>| <font color="#0000ff"><strong>playing</strong></font> |在媒体开始播放时触发（不论是初次播放、在暂停后恢复、或是在结束后重新开始）。|<br>| <font color="#0000ff"><strong>progress</strong></font> | 告知媒体相关部分的下载进度时周期性地触发。有关媒体当前已下载总计的信息可以在元素的buffered属性中获取到。|<br>| ratechange | 在回放速率变化时触发。|<br>| seeked |在跳跃操作完成时触发。|<br>| seeking |在跳跃操作开始时触发。|<br>| stalled | 在尝试获取媒体数据，但数据不可用时触发。|<br>| <font color="#0000ff"><strong>suspend</strong></font> |在媒体资源加载终止时触发，这可能是因为下载已完成或因为其他原因暂停。|<br>| timeupdate |元素的currentTime属性表示的时间已经改变。|<br>| volumechange |在音频音量改变时触发（既可以是volume属性改变，也可以是muted属性改变）|<br>| waiting | 在一个待执行的操作（如回放）因等待另一个操作（如跳跃或下载）被延迟时触发。|</p>
<p>###业内实例</p>
<p>##&lt;vedio&gt;标签</p>
<blockquote>
<p>&lt;video&gt; 元素 用于在HTML或者XHTML文档中嵌入视频内容。包含任一 src 属性或是一个或多个 &lt;source&gt; 元素，其后紧跟流式内容 或 段落内容 ， 不包括&lt;video&gt; 或者 &lt;audio&gt; 元素。</p>
</blockquote>
<h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><ul>
<li>autoplay [Boolean] 视频会马上自动开始播放，不会停下来等着数据载入结束。</li>
<li>buffered 这个属性可以读取到哪段时间范围内的媒体被缓存了。该属性包含了一个 TimeRanges 对象。</li>
<li>controls Gecko 会提供用户控制，允许用户控制视频的播放，包括音量，跨帧，暂停/恢复播放。</li>
<li>crossorigin 该枚举属性指明抓取相关图片是否必须用到CORS（跨域资源共享）。不加这个属性时，抓取资源不会走CORS请求(即，不会发送 Origin: HTTP 头)，保证其在 &lt;canvas&gt; 元素中使用时不会被污染。如果指定非法值，会被当作指定了枚举关键字 anonymous 一样使用。<ul>
<li>anonymous 跨域请求（即，使用 Origin: 的HTTP头）会被执行。但是不发送凭证（即，不发送cookie， X.509 证书或者 HTTP Basic 授权）。如果服务器不提供证书给源站点 (不设置 Access-Control-Allow-Origin: HTTP头)，图片会被 污染 并且它的使用会受限。</li>
<li>use-credentials 跨域请求A cross-origin request (i.e. with Origin: HTTP header) 会被执行，且凭证会被发送 (即， 发送一个 cookie, 一个证书和HTTP Basic授权会被执行)。如果服务器不提供证书给源站点 (通过Access-Control-Allow-Credentials: HTTP 头)，图像会被 污染 且它的使用会受限。</li>
</ul>
</li>
<li>height 视频展示区域的高度，单位是CSS像素。</li>
<li>loop [Boolean] 指定后，会在视频结尾的地方，自动返回视频开始的地方。</li>
<li>muted [Boolean] 指明了视频里的音频的默认设置。设置后，音频会初始化为静音。默认值是false,意味着视频播放的时候音频也会播放 。</li>
<li>played 一个 TimeRanges 对象，指明了视频已经播放的所有范围。</li>
<li>preload 该枚举属性旨在告诉浏览器作者认为达到最佳的用户体验的方式是什么。可能是下列值之一：<ul>
<li>none 提示作者认为用户不需要查看该视频，服务器也想要最小化访问流量；换句话说就是提示浏览器该视频不需要缓存。</li>
<li>metadata 提示尽管作者认为用户不需要查看该视频，不过抓取元数据（比如：长度）还是很合理的。</li>
<li>auto 用户需要这个视频优先加载；换句话说就是提示：如果需要的话，可以下载整个视频，即使用户并不一定会用它。</li>
<li>空字符串：也就代指 auto 值。</li>
<li>autoplay 属性优先于 preload 假如用户想自动播放视频。</li>
</ul>
</li>
<li>poster 一个海报帧的URL，用于在用户播放或者跳帧之前展示。如果属性未指定，那么在第一帧可用之前什么都不会展示；之后第一帧就像海报帧一样展示。</li>
<li>src 要嵌到页面的视频的URL。可选；你也可以使用video块内的 <source> 元素来指定需要嵌到页面的视频。</li>
<li>width 视频显示区域的宽度，单位是CSS像素。</li>
</ul>
<blockquote>
<p>时间偏移量目前是指定为float类型的值，表示偏移的秒数</p>
</blockquote>
<p>###事件<br>同之前内容。</p>
<p>###业内实例<br>####爱奇艺、腾讯视频、优酷<br>三大视频网站都是使用的是&lt;video&gt;元素来播放视频。<br>####哔哩哔哩<br>哔哩哔哩使用的是自己开源的播放器<a href="https://github.com/Bilibili/flv.js">flv.js</a><br>不过基本上也是用的&lt;video&gt;元素</p>
<p>####现在github上star最多的视频播放器一个是<a href="https://github.com/videojs/video.js">videojs/video.js</a>,另一个是哔哩哔哩的<a href="https://github.com/Bilibili/flv.js">flv.js</a>,还有<a href="https://github.com/sampotts/plyr">sampotts/plyr</a>。音频视频播放器<a href="https://github.com/mediaelement/mediaelement">mediaelement/mediaelement</a></p>
]]></content>
      <categories>
        <category>HTML &amp;&amp; CSS</category>
      </categories>
      <tags>
        <tag>多媒体能力</tag>
      </tags>
  </entry>
  <entry>
    <title>《CSS世界》第六章 流的破坏与保护总结</title>
    <url>/2018/10/11/%E3%80%8ACSS%E4%B8%96%E7%95%8C%E3%80%8B%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%B5%81%E7%9A%84%E7%A0%B4%E5%9D%8F%E4%B8%8E%E4%BF%9D%E6%8A%A4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>《CSS世界》第六章 流的破坏与保护总结<br>author: <a href="https://tiffanysbear.github.io/" target="_blank" rel="noopener">@TiffanysBear</a></p>
</blockquote>
<h2 id="float属性"><a href="#float属性" class="headerlink" title="float属性"></a>float属性</h2><h3 id="float的本质与特性"><a href="#float的本质与特性" class="headerlink" title="float的本质与特性"></a>float的本质与特性</h3><blockquote>
<p>1.包裹性（包含包裹和自适应）</p>
</blockquote>
<blockquote>
<p>2.块状化并格式化上下文</p>
</blockquote>
<blockquote>
<p>3.破坏文档流</p>
</blockquote>
<blockquote>
<p>4.没有任何margin合并</p>
</blockquote>
<h3 id="float的作用机制"><a href="#float的作用机制" class="headerlink" title="float的作用机制"></a>float的作用机制</h3><blockquote>
<p>float属性使父元素高度塌陷，为了实现文字环绕效果。高度塌陷是为了让跟随的内容可以和浮动元素在一个水平线上。（行框盒子在正常定位状态下只会跟随浮动元素，不会发生重叠）</p>
</blockquote>
<h3 id="clear属性"><a href="#clear属性" class="headerlink" title="clear属性"></a>clear属性</h3><blockquote>
<p>clear属性让自身不能和前面的浮动元素相邻。clear属性只有块级元素才有效。</p>
</blockquote>
<blockquote>
<p>如果clear: both;元素前面的元素就是float元素，则margin-top负值即使设置成-9999px，也没有任何效果；</p>
</blockquote>
<blockquote>
<p>clear: both; 后面的元素依旧可能会发生文字环绕现象。</p>
</blockquote>
<a id="more"></a>

<h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><h3 id="BFC定义"><a href="#BFC定义" class="headerlink" title="BFC定义"></a>BFC定义</h3><blockquote>
<p>通过一些特定的手段形成的封闭空间，即BFC元素内部不会影响外部的元素。可以用来防止margin重叠，清楚浮动防止父元素高度坍塌。</p>
</blockquote>
<h4 id="触发BFC条件"><a href="#触发BFC条件" class="headerlink" title="触发BFC条件"></a>触发BFC条件</h4><ul>
<li><html>根元素；</html></li>
<li>float的值不为none；</li>
<li>overflow的值为auto、scroll或hidden；</li>
<li>display的值为table-cell、table-caption和inline-block中任何一个；</li>
<li>position的值不为relative和static；</li>
</ul>
<h4 id="各个BFC优缺点"><a href="#各个BFC优缺点" class="headerlink" title="各个BFC优缺点"></a>各个BFC优缺点</h4><ul>
<li>float，浮动元素本身BFC化，然而浮动元素有破坏性和包裹性，失去了元素本身的流体自适应行。</li>
<li>position: absolute; 脱离了文档流。</li>
<li>overflow: hidden; 容器盒子外的元素可能会被隐藏掉。</li>
<li>display: inline-block; IE6、7下完美，因为即BFC化又保持block也行，保留了流体特性。但在其他浏览器下会让元素尺寸包裹收缩。</li>
</ul>
<h4 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h4><blockquote>
<p>overflow裁剪的边界是border box的内边缘，而非padding box的内边缘。</p>
</blockquote>
<blockquote>
<p>overflow-x和overflow-y属性中一个值设置为visible而另一个设置为scroll、auto或者hidden，则visible的样式表现会如同auto。除非 overflow-x和overflow-y 属性值都是visible，否则会当成auto来解析。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 单行文字省略号</span><br><span class="line">.ell &#123;</span><br><span class="line">	text-overflow: ellipsis;</span><br><span class="line">	white-space: nowarp;</span><br><span class="line">	overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 多行文字省略号</span><br><span class="line">.ell-rows-2 &#123;</span><br><span class="line">	display: -webkit-box;</span><br><span class="line">	-webkit-box-orient: vertical;</span><br><span class="line">	-webkit-line-clamp: 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="overflow与锚点定位"><a href="#overflow与锚点定位" class="headerlink" title="overflow与锚点定位"></a>overflow与锚点定位</h5><p>锚点定位行为的触发条件</p>
<ul>
<li>URL地址中的锚链与锚点元素对应（a标签以及name属性）并有交互行为</li>
<li>可focus的锚点元素处于focus状态</li>
</ul>
<blockquote>
<p>锚点定位的本质通过改变<strong>容器</strong>滚动高度或者宽度实现的。锚点定位发生在普通容器元素上，定位行为是由内而外的。</p>
</blockquote>
<blockquote>
<p>设置了overflow: hidden;的元素也是可以滚动的，只是滚动条不见了而已。</p>
</blockquote>
<h2 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h2><h3 id="绝对定位特性"><a href="#绝对定位特性" class="headerlink" title="绝对定位特性"></a>绝对定位特性</h3><ul>
<li>块状化</li>
<li>破坏性</li>
<li>块状格式上下文</li>
<li>包裹性、自适应性</li>
</ul>
<h3 id="absolute的包含块"><a href="#absolute的包含块" class="headerlink" title="absolute的包含块"></a>absolute的包含块</h3><ul>
<li>根元素被称为“初始包含块”，其尺寸等同于浏览器可是窗口的大小。</li>
<li>对于其他元素，如果该元素的position是relative或者static。则“包含块”由最近的块容器祖先盒的content box边界形成。</li>
<li>如果元素position: fixed;则包含块是初始包含块。</li>
<li>如果元素position: absolute，则包含块由最近的position不为static的祖先元素建立，由该祖先的padding box边界形成。</li>
</ul>
<h3 id="无依赖absolute定位的相对特性"><a href="#无依赖absolute定位的相对特性" class="headerlink" title="无依赖absolute定位的相对特性"></a>无依赖absolute定位的相对特性</h3><blockquote>
<p>absolute是非常独立的CSS属性值，其样式和行为表现不依赖其他任何CSS属性就可以完成。单独设置position: absolute; 本质上是相对定位，只不过不占据CSS流的尺寸空间而已。</p>
</blockquote>
<blockquote>
<p>可以利用该特性实现“图片和文字水平对齐”，“表单提示词”等效果。</p>
</blockquote>
<h3 id="absolute与text-align"><a href="#absolute与text-align" class="headerlink" title="absolute与text-align"></a>absolute与text-align</h3><blockquote>
<p>text-align会改变absolute元素的位置，本质是“幽灵空白节点”和“无依赖绝对定位”共同作用的结果，具体就是由于绝对定位元素不占据CSS流中的尺寸空间，表现为一个“空白节点”，这时text-align使该节点居中，因此效果就是绝对定位元素偏右了。<strong>注意，只有原本是内联水平的元素才有这种情况</strong></p>
</blockquote>
<h3 id="absolute与overflow"><a href="#absolute与overflow" class="headerlink" title="absolute与overflow"></a>absolute与overflow</h3><blockquote>
<p>绝对定位元素不总是被父级overflow属性剪裁，尤其当overflow在绝对定位元素及其包含块之间的时候。</p>
</blockquote>
<h3 id="absolute与clip"><a href="#absolute与clip" class="headerlink" title="absolute与clip"></a>absolute与clip</h3><blockquote>
<p>当position: fixed;overflow属性就不可用了，除非根元素。这时可以使用clip来进行剪裁。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 这种方式既满足视觉上的隐藏，屏幕阅读器等辅助设备又支持很好（display: none;不识别或者不可focus）。移动端中可以使用透明度为0.</span><br><span class="line">.clip &#123;</span><br><span class="line">	position: absolute;</span><br><span class="line">	clip: rect(0 0 0 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>clip隐藏仅仅决定了那部分可见，非可见部分不响应点击事件等；虽然视觉上隐藏了，但是元素的尺寸还是不变的，在IE、firfox中抹掉了不可见区域对布局的影响，chrome没有这种问题。</p>
</blockquote>
<h3 id="absolute的流体特性"><a href="#absolute的流体特性" class="headerlink" title="absolute的流体特性"></a>absolute的流体特性</h3><blockquote>
<p>当对立方向同时发生定位时，表现为格式化宽度，自适应包含块的padding box。具备自适应性。</p>
</blockquote>
<blockquote>
<p>margin: auto;可以让绝对定位元素居中。条件是对立方向同时发生定位。</p>
</blockquote>
<h2 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h2><blockquote>
<p>相对定位的left/top等的百分比是相对于包含块计算的，而不是相对自身。</p>
</blockquote>
<blockquote>
<p>对立方向同时发生定位时，只有一个方向的定位属性起作用。</p>
</blockquote>
<h2 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h2><blockquote>
<p>与无依赖绝对定位相同，也存在无依赖固定定位。</p>
</blockquote>
]]></content>
      <categories>
        <category>HTML &amp;&amp; CSS</category>
      </categories>
      <tags>
        <tag>布局</tag>
      </tags>
  </entry>
</search>
